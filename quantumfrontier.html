<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Frontier</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js" integrity="sha512-xi/RZRIF/S0hJ+yJJYuZ5yk6/8pCiRlEXZzoguSMl+vk2i3m6UjUO/WcZ11blRL/O+rnj94JRGwt/CHbc9+6EA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  </head>
  <body>
    <div id="gameContainer">
      <div id="intro">
        <h1>Quantum Frontier</h1>
        <p>Navigate through hostile space territories.Defend against alien sentries orbiting distant worlds.Use WASD or Arrow Keys to move,SPACE to fire.Keys 1-5 to change weapons.Stay alert-enemies will attack when you get too close!</p>
        <button id="startBtn">Launch Mission</button>
      </div>
      <div id="hud">
        <div id="healthHud">✚ <span id="health">100</span>
        </div>
        <div id="scoreHud">★ <span id="score">0</span>
        </div>
        <div id="weaponHud">
          <span id="currentWeapon">1-Blaster</span>
        </div>
        <div id="coordinates">
          <span id="posX">0</span>, <span id="posZ">0</span>
        </div>
      </div>
      <div id="minimap">
        <canvas id="minimapCanvas" width="120" height="120"></canvas>
        <div id="minimapToggle">⊞</div>
      </div>
      <div id="effects"></div>
      <div id="controls">
        <div>WASD/Arrows-Move</div>
        <div>SPACE-Fire</div>
        <div>1-5-Weapons</div>
      </div>
      <div id="mobileControls">
        <div id="dpad">
          <div id="dpadOuter"></div>
          <div id="dpadInner"></div>
        </div>
        <div id="fireBtn">FIRE</div>
        <div id="weaponBtn">W <br>1 </div>
      </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
    <script>
      // =================== GAME CONFIGURATION ===================
// Modify these values to customize game behavior
const GAME_CONFIG = {
  // Player Configuration
  player: {
    acceleration: 0.12,        // How fast player accelerates (0.05 - 0.2)
    maxSpeed: 0.9,            // Maximum player speed (0.5 - 1.5)
    friction: 0.93,           // Movement friction (0.85 - 0.98)
    health: 1200,             // Player health (500 - 2000)
    rotationSpeed: 0.08,      // How fast player rotates (0.05 - 0.15)
  },
  
  // Enemy Configuration  
  enemy: {
    health: 35,               // Base enemy health (20 - 60)
    chaseSpeed: 0.35,         // How fast enemies chase (0.2 - 0.6)
    attackRange: 45,          // Attack detection range (30 - 60)
    shootCooldown: 100,       // Frames between enemy shots (60 - 180)
    avoidanceForce: 1.2,      // Enemy collision avoidance (0.8 - 2.0)
    damageToPlayer: 18,       // Damage enemies deal (10 - 30)
  },
  
  // Ally Configuration
  ally: {
    health: 80,               // Ally health (50 - 120)
    followDistance: 20,       // How close allies follow (15 - 30)
    healAmount: 8,            // Healing per tick (5 - 15)
    healCooldown: 25,         // Frames between heals (20 - 40)
    shootCooldown: 35,        // Frames between ally shots (25 - 50)
    damage: 28,               // Ally weapon damage (20 - 40)
  },
  
  // Planet Configuration
  planet: {
    baseHealth: 250,          // Base planet health (150 - 400)
    orbitSpeed: 0.004,        // Planet orbit speed (0.001 - 0.008)
    collisionDamage: 12,      // Damage from planet collision (8 - 20)
  },
  
  // Weapon Configuration
  weapons: {
    blaster: { damage: 12, speed: 2.2 },      // Basic weapon (8-18, 1.5-3.0)
    scatter: { damage: 8, speed: 2.0 },       // Spread weapon (5-12, 1.5-2.5)  
    shotgun: { damage: 15, speed: 1.8 },      // Close range (10-25, 1.2-2.5)
    laser: { damage: 25, width: 12 },         // Continuous beam (15-35, 8-20)
    mine: { damage: 60, radius: 10 },         // Explosive (40-100, 8-15)
  },
  
  // Performance Configuration
  performance: {
    maxTrails: 150,           // Maximum trail particles (100 - 300)
    trailSpawnRate: 0.4,      // Chance to spawn trail (0.2 - 0.8)
    maxExplosions: 20,        // Maximum explosions (15 - 30)
    cameraSmoothing: 0.12,    // Camera follow smoothness (0.08 - 0.2)
  }
};

// =================== OPTIMIZED CORE CLASSES ===================

class OptimizedShipFactory {
  static templateCache = new Map();
  static geometryCache = new Map();
  
  static templates = {
    player: {
      type: 'tie', scale: 0.9, cockpit: 'octahedron', cockpitScale: 1.5,
      panelCount: 2, panelShape: 'diamond', panelSize: 4, panelDist: 2.2,
      panelThick: 0.1, panelY: 0.2, panelZ: 0.1, panelRotX: -50,
      hasStruts: true, strutType: 'hexagonal', strutThick: 0.19,
      primaryColor: 0x3742fa, secondaryColor: 0x2f3542, accentColor: 0x70a1ff, cockpitColor: 0xff4757
    },
    fighter: {
      type: 'classic', scale: 1, bodyWidth: 1.5, bodyHeight: 0.2, bodyLength: 3,
      hasWings: true, wingSpan: 3, wingThick: 0.15, engineCount: 2, engineSize: 0.25,
      primaryColor: 0xff4757, secondaryColor: 0xff3838, accentColor: 0xff6b6b
    },
    interceptor: {
      type: 'tie', scale: 1.33, cockpit: 'sphere', cockpitScale: 1.2,
      panelShape: 'hexagon', panelSize: 2, panelDist: 2.5,
      primaryColor: 0x9b59b6, secondaryColor: 0x8e44ad, accentColor: 0xd63031
    },
    heavy: {
      type: 'classic', scale: 1.2, bodyWidth: 2.5, bodyHeight: 0.4, bodyLength: 5,
      hasWings: true, wingSpan: 5, wingThick: 0.3, engineCount: 4,
      primaryColor: 0x2ed573, secondaryColor: 0x1e90ff, accentColor: 0x7bed9f
    },
    scout: {
      type: 'classic', scale: 1.6, bodyWidth: 1.2, bodyHeight: 0.6, bodyLength: 4.6,
      wingSpan: 5.6, primaryColor: 0xfeca57, secondaryColor: 0x2ed9ff
    },
    purplediamond: {
      type: 'tie', scale: 1.8, cockpit: 'octahedron', panelShape: 'triangle',
      primaryColor: 0x5f27cd, secondaryColor: 0xfeca57, accentColor: 0x96ceb4
    },
    doradito: {
      type: 'tie', scale: 0.5, cockpit: 'dodecahedron', panelShape: 'diamond',
      primaryColor: 0xff9f43, secondaryColor: 0xff6b6b, accentColor: 0xfeca57
    }
  };

  static getGeometry(type, size) {
    const key = `${type}_${size}`;
    if (this.geometryCache.has(key)) return this.geometryCache.get(key);
    
    let geometry;
    switch (type) {
      case 'hexagon': geometry = new THREE.CylinderGeometry(size, size, 0.1, 6); break;
      case 'square': geometry = new THREE.BoxGeometry(size, size, 0.1); break;
      case 'diamond': 
        geometry = new THREE.OctahedronGeometry(size / 1.4);
        geometry.scale(1, 1, 0.1);
        break;
      case 'circle': geometry = new THREE.CylinderGeometry(size/2, size/2, 0.1, 16); break;
      case 'triangle':
        geometry = new THREE.ConeGeometry(size, 0.1, 3);
        geometry.rotateX(Math.PI/2);
        break;
      default: geometry = new THREE.CylinderGeometry(size, size, 0.1, 6);
    }
    
    this.geometryCache.set(key, geometry);
    return geometry;
  }

  static create(templateName, customProps = {}) {
    const cacheKey = `${templateName}_${JSON.stringify(customProps)}`;
    if (this.templateCache.has(cacheKey)) {
      return this.templateCache.get(cacheKey).clone();
    }

    const template = { ...this.templates[templateName], ...customProps };
    if (!template) return this.create('fighter');

    const ship = template.type === 'tie' ? this.createTieShip(template) : this.createClassicShip(template);
    this.templateCache.set(cacheKey, ship);
    return ship.clone();
  }

  static createTieShip(cfg) {
    const ship = new THREE.Group();
    const sc = cfg.scale || 1.8;

    // Create cockpit
    let cockpitGeom;
    switch (cfg.cockpit || 'sphere') {
      case 'octahedron': cockpitGeom = new THREE.OctahedronGeometry((cfg.cockpitScale || 1.2) * sc); break;
      case 'dodecahedron': cockpitGeom = new THREE.DodecahedronGeometry((cfg.cockpitScale || 1.2) * sc); break;
      default: cockpitGeom = new THREE.SphereGeometry((cfg.cockpitScale || 1.2) * sc, 12, 12);
    }

    const cockpit = new THREE.Mesh(cockpitGeom, new THREE.MeshLambertMaterial({ color: cfg.cockpitColor || 0xff5252 }));
    ship.add(cockpit);

    // Create panels
    for (let i = 0; i < (cfg.panelCount || 2); i++) {
      const panelGeom = this.getGeometry(cfg.panelShape || 'hexagon', (cfg.panelSize || 2) * sc);
      const panel = new THREE.Mesh(panelGeom, new THREE.MeshLambertMaterial({ color: cfg.primaryColor || 0x2ed573 }));
      
      const angle = (i * Math.PI * 2) / (cfg.panelCount || 2);
      panel.position.set(
        Math.cos(angle) * (cfg.panelDist || 2.5) * sc,
        (cfg.panelY || 0) * sc,
        Math.sin(angle) * (cfg.panelDist || 2.5) * sc
      );
      panel.rotation.y = angle + Math.PI / 2;
      ship.add(panel);

      // Add struts
      if (cfg.hasStruts !== false) {
        const strutGeom = new THREE.CylinderGeometry((cfg.strutThick || 0.1) * sc, (cfg.strutThick || 0.1) * sc, (cfg.panelDist || 2.5) * sc * 0.8, 6);
        const strut = new THREE.Mesh(strutGeom, new THREE.MeshLambertMaterial({ color: cfg.secondaryColor || 0x1e90ff }));
        strut.position.set(panel.position.x / 2, panel.position.y / 2, panel.position.z / 2);
        strut.rotation.z = -angle;
        ship.add(strut);
      }
    }
    return ship;
  }

  static createClassicShip(cfg) {
    const ship = new THREE.Group();
    const sc = cfg.scale || 1.8;

    // Body
    const body = new THREE.Mesh(
      new THREE.BoxGeometry((cfg.bodyWidth || 2) * sc, (cfg.bodyHeight || 0.3) * sc, (cfg.bodyLength || 4) * sc),
      new THREE.MeshLambertMaterial({ color: cfg.primaryColor || 0x2ed573 })
    );
    ship.add(body);

    // Wings
    if (cfg.hasWings !== false) {
      const wing = new THREE.Mesh(
        new THREE.BoxGeometry((cfg.wingSpan || 4) * sc, (cfg.wingThick || 0.2) * sc, 1 * sc),
        new THREE.MeshLambertMaterial({ color: cfg.secondaryColor || 0x1e90ff })
      );
      wing.position.set(0, -0.1 * sc, (cfg.wingPos || -1) * sc);
      ship.add(wing);
    }

    // Engines
    const engineCount = cfg.engineCount || 2;
    const spacing = cfg.engineSpacing || 1.5;
    for (let i = 0; i < engineCount; i++) {
      const engine = new THREE.Mesh(
        new THREE.SphereGeometry((cfg.engineSize || 0.3) * sc, 8, 8),
        new THREE.MeshBasicMaterial({ color: cfg.accentColor || 0x7bed9f, transparent: true, opacity: 0.8 })
      );
      const offset = engineCount === 1 ? 0 : (i - (engineCount - 1) / 2) * spacing * sc;
      engine.position.set(offset, 0, (cfg.enginePosZ || -2) * sc);
      ship.add(engine);
    }

    return ship;
  }
}

class OptimizedObjectPool {
  constructor(createFn, resetFn, initialSize = 10) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    this.pool = [];
    this.active = [];
    
    // Pre-populate pool
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(this.createFn());
    }
  }

  get() {
    let obj;
    if (this.pool.length > 0) {
      obj = this.pool.pop();
    } else {
      obj = this.createFn();
    }
    this.active.push(obj);
    return obj;
  }

  release(obj) {
    const index = this.active.indexOf(obj);
    if (index > -1) {
      this.active.splice(index, 1);
      this.resetFn(obj);
      this.pool.push(obj);
    }
  }

  cleanup() {
    // Remove objects that should be released
    this.active = this.active.filter(obj => {
      if (obj.shouldRelease) {
        this.resetFn(obj);
        this.pool.push(obj);
        return false;
      }
      return true;
    });
  }
}

class OptimizedSpaceShooter {
  constructor() {
    this.frameCount = 0;
    this.lastTime = 0;
    this.deltaTime = 0;
    
    // Object pools for performance
    this.bulletPool = new OptimizedObjectPool(
      () => this.createBulletObject(),
      (bullet) => this.resetBullet(bullet),
      20
    );
    
    this.explosionPool = new OptimizedObjectPool(
      () => this.createExplosionObject(),
      (explosion) => this.resetExplosion(explosion),
      10
    );

    // Cached vectors to avoid object creation
    this.tempVector1 = new THREE.Vector3();
    this.tempVector2 = new THREE.Vector3();
    this.tempVector3 = new THREE.Vector3();

    this.initializeRenderer();
    this.initializeGameState();
    this.initializeScene();
    this.setupEventListeners();
    this.animate();
  }

  initializeRenderer() {
    this.scene = new THREE.Scene();
    const aspectRatio = window.innerWidth / window.innerHeight;
    const distance = 44;
    this.camera = new THREE.OrthographicCamera(
      -distance * aspectRatio, distance * aspectRatio,
      distance, -distance, 0.1, 2000
    );
    
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setClearColor(0x000011);
    this.renderer.sortObjects = true;
    
    // Performance optimizations
    this.renderer.shadowMap.enabled = false;
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    
    document.getElementById('gameContainer').appendChild(this.renderer.domElement);
  }

  initializeGameState() {
    this.gameStarted = false;
    this.player = {
      health: GAME_CONFIG.player.health,
      maxHealth: GAME_CONFIG.player.health,
      score: 0,
      currentWeapon: 1,
      effects: {
        speed: { active: false, endTime: 0 },
        damage: { active: false, endTime: 0 }
      }
    };

    // Smooth camera following
    this.cameraTarget = new THREE.Vector3();
    this.cameraPosition = new THREE.Vector3(0, 60, 60);
    
    this.keys = {};
    this.bullets = [];
    this.enemyBullets = [];
    this.artifacts = [];
    this.mines = [];
    this.enemies = [];
    this.planets = [];
    this.allies = [];
    this.trails = [];
    this.explosions = [];
    
    this.playerShip = null;
    this.playerVelocity = new THREE.Vector3();
    this.targetRotation = 0;
    this.currentRotation = 0;
    
    this.collisionCooldown = 0;
    this.shootPressed = false;
    this.laserBeam = null;
    
    // Landing system
    this.landingState = 'none';
    this.landingTarget = null;
    this.landingProgress = 0;
    this.landingDuration = 5000;
    this.collisionEnabled = true;
    
    this.touchControls = { moveX: 0, moveY: 0, firing: false };
    this.visitedPlanets = new Set();
    
    this.audioManager = new AudioManager();
    this.minimapManager = new MinimapManager();
  }

  initializeScene() {
    this.camera.position.copy(this.cameraPosition);
    this.camera.lookAt(0, 0, 0);

    // Optimized lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
    this.scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffeedd, 0.8);
    directionalLight.position.set(1, 10, 5);
    this.scene.add(directionalLight);

    this.backgroundManager = new BackgroundManager(this.scene);
    this.createPlayer();
    this.createPlanets();
    this.createEnemies();
    
    // Spawn initial allies
    for (let i = 0; i < 3; i++) {
      this.spawnAlly();
    }
  }

  createPlayer() {
    this.playerShip = OptimizedShipFactory.create('player');
    this.playerShip.position.set(50, 5, 50);
    this.scene.add(this.playerShip);
  }

  createPlanets() {
    // Sun
    const sunGeometry = new THREE.SphereGeometry(30, 32, 32);
    const sunMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xffff00, 
      emissive: 0x444400, 
      emissiveIntensity: 0.3 
    });
    const sun = new THREE.Mesh(sunGeometry, sunMaterial);
    this.scene.add(sun);
    
    this.planets.push({
      mesh: sun,
      center: new THREE.Vector3(0, 0, 0),
      config: { radius: 30, health: 1000, maxHealth: 1000, enemyCount: 0 },
      health: 1000,
      maxHealth: 1000,
      destroyed: false
    });

    // Other planets with optimized configs
    const planetConfigs = [
      { radius: 18, color: 0xff6b6b, distance: 100, enemyCount: 9, enemyType: 'f', health: GAME_CONFIG.planet.baseHealth },
      { radius: 25, color: 0x00ff88, distance: 180, enemyCount: 6, enemyType: 'd', health: GAME_CONFIG.planet.baseHealth * 1.2 },
      { radius: 25, color: 0x00ff88, distance: 220, enemyCount: 6, enemyType: 'p', health: GAME_CONFIG.planet.baseHealth * 1.2 }
    ];

    planetConfigs.forEach((config, index) => {
      const planet = this.createPlanet(config, index + 1);
      this.planets.push(planet);
      this.scene.add(planet.mesh);
    });
  }

  createPlanet(config, index) {
    const geometry = new THREE.SphereGeometry(config.radius, 32, 32);
    const material = new THREE.MeshLambertMaterial({ color: config.color });
    const mesh = new THREE.Mesh(geometry, material);
    
    const angle = (index * Math.PI * 2) / 3;
    const x = Math.cos(angle) * config.distance;
    const z = Math.sin(angle) * config.distance;
    mesh.position.set(x, 0, z);
    
    return {
      mesh,
      center: mesh.position.clone(),
      config: { ...config, orbitSpeed: GAME_CONFIG.planet.orbitSpeed },
      health: config.health,
      maxHealth: config.health,
      destroyed: false,
      orbitCenter: { x: 0, z: 0 },
      orbitDistance: config.distance,
      currentAngle: angle
    };
  }

  createEnemies() {
    const enemyTypes = { f: 'fighter', d: 'doradito', p: 'purplediamond' };
    
    this.planets.forEach((planet, planetIndex) => {
      if (planetIndex === 0 || !planet.config.enemyCount) return; // Skip sun
      
      for (let i = 0; i < planet.config.enemyCount; i++) {
        const enemy = this.createEnemy(planet, i, planet.config.enemyCount, planet.config.enemyType);
        if (enemy) {
          this.enemies.push(enemy);
          this.scene.add(enemy.mesh);
        }
      }
    });
  }

  createEnemy(planet, index, totalCount, type) {
    const shipType = { f: 'fighter', d: 'doradito', p: 'purplediamond', h: 'heavy', i: 'interceptor', s: 'scout' }[type] || 'fighter';
    const ship = OptimizedShipFactory.create(shipType);
    
    const angle = (index * Math.PI * 2) / totalCount;
    const radius = planet.config.radius + 8;
    const x = planet.center.x + Math.cos(angle) * radius;
    const z = planet.center.z + Math.sin(angle) * radius;
    
    ship.position.set(x, 5, z);
    
    return {
      mesh: ship,
      planet: planet,
      angle: angle,
      originalAngle: angle,
      health: GAME_CONFIG.enemy.health,
      maxHealth: GAME_CONFIG.enemy.health,
      attacking: false,
      retreating: false,
      shootCooldown: 0,
      chaseSpeed: GAME_CONFIG.enemy.chaseSpeed,
      attackRange: GAME_CONFIG.enemy.attackRange,
      type: type,
      score: 100
    };
  }

  spawnAlly() {
    const ally = this.createEnemy(null, 0, 1, 's');
    if (!ally) return;
    
    const angle = Math.random() * Math.PI * 2;
    const distance = 15 + Math.random() * 10;
    ally.mesh.position.set(
      this.playerShip.position.x + Math.cos(angle) * distance,
      5,
      this.playerShip.position.z + Math.sin(angle) * distance
    );
    
    ally.isAlly = true;
    ally.followSide = Math.random() < 0.5 ? -1 : 1;
    ally.healCooldown = 0;
    ally.health = GAME_CONFIG.ally.health;
    ally.maxHealth = GAME_CONFIG.ally.health;
    ally.targetPosition = new THREE.Vector3();
    
    this.allies.push(ally);
    this.scene.add(ally.mesh);
  }

  // Optimized update with frame skipping for expensive operations
  update() {
    if (!this.gameStarted) return;
    
    this.frameCount++;
    const currentTime = Date.now();
    this.deltaTime = currentTime - this.lastTime;
    this.lastTime = currentTime;

    // Update core systems every frame
    this.updatePlayer();
    this.updateCamera();
    this.updateBullets();
    this.updateEnemyBullets();
    
    // Update expensive systems less frequently
    if (this.frameCount % 2 === 0) {
      this.updateEnemies();
      this.updateCollisions();
    }
    
    if (this.frameCount % 3 === 0) {
      this.updateAllies();
      this.updateTrails();
    }
    
    if (this.frameCount % 4 === 0) {
      this.updatePlanets();
      this.updateArtifacts();
      this.updateMines();
      this.updateExplosions();
    }
    
    if (this.frameCount % 10 === 0) {
      this.updateEffects();
      this.updateMinimap();
      this.bulletPool.cleanup();
      this.explosionPool.cleanup();
    }
    
    this.updateBackground();
  }

  updatePlayer() {
    if (this.landingState !== 'none') {
      this.updateLanding();
      return;
    }

    // Smooth input handling
    let moveX = 0, moveZ = 0;
    if (this.keys.KeyW || this.keys.ArrowUp || this.touchControls.moveY < -0.3) moveZ -= 1;
    if (this.keys.KeyS || this.keys.ArrowDown || this.touchControls.moveY > 0.3) moveZ += 1;
    if (this.keys.KeyA || this.keys.ArrowLeft || this.touchControls.moveX < -0.3) moveX -= 1;
    if (this.keys.KeyD || this.keys.ArrowRight || this.touchControls.moveX > 0.3) moveX += 1;

    // Normalize diagonal movement
    if (moveX !== 0 && moveZ !== 0) {
      moveX *= Math.SQRT1_2;
      moveZ *= Math.SQRT1_2;
    }

    // Apply movement
    if (moveX !== 0 || moveZ !== 0) {
      const speedMultiplier = this.player.effects.speed.active ? 1.5 : 1;
      this.playerVelocity.x += moveX * GAME_CONFIG.player.acceleration * speedMultiplier;
      this.playerVelocity.z += moveZ * GAME_CONFIG.player.acceleration * speedMultiplier;
      
      // Calculate target rotation
      this.targetRotation = Math.atan2(moveX, moveZ);
    }

    // Apply friction and speed limit
    this.playerVelocity.multiplyScalar(GAME_CONFIG.player.friction);
    const maxSpeed = GAME_CONFIG.player.maxSpeed * (this.player.effects.speed.active ? 1.5 : 1);
    if (this.playerVelocity.length() > maxSpeed) {
      this.playerVelocity.normalize().multiplyScalar(maxSpeed);
    }

    // Smooth rotation
    let angleDiff = this.targetRotation - this.currentRotation;
    if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
    if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
    this.currentRotation += angleDiff * GAME_CONFIG.player.rotationSpeed;

    // Apply movement and rotation
    this.tempVector1.copy(this.playerShip.position).add(this.playerVelocity);
    if (!this.checkPlanetCollision(this.tempVector1, true)) {
      this.playerShip.position.copy(this.tempVector1);
    }
    this.playerShip.rotation.y = this.currentRotation;
    this.playerShip.position.y = 5;

    // Create trails less frequently
    if (this.playerVelocity.length() > 0.1 && Math.random() < GAME_CONFIG.performance.trailSpawnRate) {
      this.createTrail();
    }

    // Weapon firing
    if ((this.keys.Space && !this.shootPressed) || this.touchControls.firing) {
      this.fireWeapon();
      this.shootPressed = true;
    } else if (!this.keys.Space && !this.touchControls.firing) {
      this.shootPressed = false;
      if (this.laserBeam) {
        this.scene.remove(this.laserBeam);
        this.laserBeam = null;
        this.audioManager.stopLaser();
      }
    }
  }

  updateCamera() {
    // Smooth camera following with reduced jittering
    this.cameraTarget.set(
      this.playerShip.position.x,
      60,
      this.playerShip.position.z + 60
    );
    
    // Apply smooth interpolation
    this.cameraPosition.lerp(this.cameraTarget, GAME_CONFIG.performance.cameraSmoothing);
    
    // Check for collisions and adjust if needed
    if (!this.checkCameraCollision(this.cameraPosition)) {
      this.camera.position.copy(this.cameraPosition);
    } else {
      this.adjustCameraForCollision();
    }
    
    this.camera.lookAt(this.playerShip.position);
  }

  // Optimized collision detection with spatial partitioning
  updateCollisions() {
    if (this.collisionCooldown > 0) {
      this.collisionCooldown--;
      return;
    }
    
    if (this.landingState !== 'none' || !this.collisionEnabled) return;

    // Player-enemy collisions
    const playerPos = this.playerShip.position;
    for (const enemy of this.enemies) {
      if (enemy.health > 0 && !enemy.isAlly) {
        const distance = playerPos.distanceTo(enemy.mesh.position);
        if (distance < 4) {
          this.player.health -= GAME_CONFIG.enemy.damageToPlayer;
          this.collisionCooldown = 60;
          this.audioManager.playCollision();
          this.createDamageEffect(playerPos);
          this.updateHUD();
          if (this.player.health <= 0) {
            this.gameOver();
          }
          break;
        }
      }
    }
  }

  updateBullets() {
    for (let i = this.bullets.length - 1; i >= 0; i--) {
      const bullet = this.bullets[i];
      bullet.mesh.position.add(bullet.velocity);
      bullet.life--;

      let hitSomething = false;

      // Check enemy collisions
      for (const enemy of this.enemies) {
        if (enemy.health > 0 && bullet.mesh.position.distanceTo(enemy.mesh.position) < 3) {
          const damage = bullet.isAlly ? GAME_CONFIG.ally.damage : 
                        (this.player.effects.damage.active ? GAME_CONFIG.weapons.blaster.damage * 2 : GAME_CONFIG.weapons.blaster.damage);
          
          enemy.health -= damage;
          enemy.attacking = true;
          this.audioManager.playEnemyHit();
          
          if (enemy.health <= 0) {
            this.destroyEnemy(enemy);
          }
          
          hitSomething = true;
          break;
        }
      }

      // Check planet collisions
      if (!hitSomething) {
        for (const planet of this.planets) {
          if (!planet.destroyed && bullet.mesh.position.distanceTo(planet.center) < planet.config.radius) {
            planet.health -= GAME_CONFIG.weapons.blaster.damage;
            if (planet.health <= 0) {
              this.destroyPlanet(planet);
            }
            hitSomething = true;
            break;
          }
        }
      }

      if (hitSomething || bullet.life <= 0) {
        this.scene.remove(bullet.mesh);
        this.bullets.splice(i, 1);
      }
    }
  }

  updateEnemyBullets() {
    for (let i = this.enemyBullets.length - 1; i >= 0; i--) {
      const bullet = this.enemyBullets[i];
      bullet.mesh.position.add(bullet.velocity);
      bullet.life--;

      // Check player collision
      if (this.landingState === 'none' && bullet.mesh.position.distanceTo(this.playerShip.position) < 3) {
        this.player.health -= GAME_CONFIG.enemy.damageToPlayer;
        this.audioManager.playDamage();
        this.createDamageEffect(this.playerShip.position);
        this.updateHUD();
        
        if (this.player.health <= 0) {
          this.gameOver();
        }
        
        this.scene.remove(bullet.mesh);
        this.enemyBullets.splice(i, 1);
        continue;
      }

      if (bullet.life <= 0) {
        this.scene.remove(bullet.mesh);
        this.enemyBullets.splice(i, 1);
      }
    }
  }

  // Optimized enemy AI with improved performance
  updateEnemies() {
    const playerPos = this.playerShip.position;
    
    for (const enemy of this.enemies) {
      if (enemy.health <= 0) continue;
      
      const distanceToPlayer = enemy.mesh.position.distanceTo(playerPos);
      enemy.shootCooldown--;

      if (distanceToPlayer < enemy.attackRange && !enemy.attacking) {
        enemy.attacking = true;
        enemy.retreating = false;
      }

      if (enemy.attacking) {
        // Chase behavior with avoidance
        if (distanceToPlayer > 4) {
          this.tempVector1.subVectors(playerPos, enemy.mesh.position).normalize();
          const avoidance = this.calculateEnemyAvoidance(enemy);
          this.tempVector1.add(avoidance).normalize();
          
          const moveDistance = Math.min(enemy.chaseSpeed, distanceToPlayer - 4);
          this.tempVector2.copy(enemy.mesh.position).add(this.tempVector1.multiplyScalar(moveDistance));
          
          if (!this.checkPlanetCollision(this.tempVector2)) {
            enemy.mesh.position.copy(this.tempVector2);
            enemy.mesh.position.y = 5;
          }
        }
        
        enemy.mesh.lookAt(playerPos);
        
        // Shooting
        if (enemy.shootCooldown <= 0 && distanceToPlayer < 30 && distanceToPlayer > 3) {
          this.enemyShoot(enemy);
          enemy.shootCooldown = GAME_CONFIG.enemy.shootCooldown;
        }
        
        if (distanceToPlayer > enemy.attackRange * 2.5) {
          enemy.attacking = false;
          enemy.retreating = true;
        }
      } else {
        // Orbit behavior
        enemy.angle += 0.01;
        this.updateEnemyPosition(enemy);
      }
    }
  }

  calculateEnemyAvoidance(currentEnemy) {
    this.tempVector3.set(0, 0, 0);
    let neighborCount = 0;

    // Avoid other enemies
    for (const otherEnemy of this.enemies) {
      if (otherEnemy === currentEnemy || otherEnemy.health <= 0) continue;
      
      const distance = currentEnemy.mesh.position.distanceTo(otherEnemy.mesh.position);
      if (distance < 12 && distance > 0) {
        this.tempVector1.subVectors(currentEnemy.mesh.position, otherEnemy.mesh.position);
        this.tempVector1.normalize().multiplyScalar((12 - distance) / 12 * GAME_CONFIG.enemy.avoidanceForce);
        this.tempVector3.add(this.tempVector1);
        neighborCount++;
      }
    }

    // Avoid player if too close
    const playerDistance = currentEnemy.mesh.position.distanceTo(this.playerShip.position);
    if (playerDistance < 4) {
      this.tempVector1.subVectors(currentEnemy.mesh.position, this.playerShip.position);
      this.tempVector1.normalize().multiplyScalar((4 - playerDistance) / 4 * 2);
      this.tempVector3.add(this.tempVector1);
    }

    if (neighborCount > 0) {
      this.tempVector3.divideScalar(neighborCount);
    }

    return this.tempVector3;
  }

  updateEnemyPosition(enemy) {
    if (!enemy.planet || !enemy.planet.center) return;
    
    const radius = enemy.planet.config.radius + 8;
    const x = enemy.planet.center.x + Math.cos(enemy.angle) * radius;
    const z = enemy.planet.center.z + Math.sin(enemy.angle) * radius;
    enemy.mesh.position.set(x, 5, z);
  }

  // Optimized trail system
  createTrail() {
    if (this.trails.length >= GAME_CONFIG.performance.maxTrails) {
      const oldTrail = this.trails.shift();
      this.scene.remove(oldTrail.mesh);
    }

    const trailGeom = new THREE.SphereGeometry(0.3, 6, 6);
    const hue = (Date.now() * 0.001) % 1;
    const trailMat = new THREE.MeshBasicMaterial({
      color: new THREE.Color().setHSL(hue, 0.8, 0.6),
      transparent: true,
      opacity: 0.7
    });
    
    const trail = new THREE.Mesh(trailGeom, trailMat);
    
    // Position behind player with some spread
    const angle = this.playerShip.rotation.y + Math.PI + (Math.random() - 0.5) * 0.3;
    const distance = 3 + Math.random() * 2;
    trail.position.set(
      this.playerShip.position.x + Math.sin(angle) * distance,
      4 + Math.random(),
      this.playerShip.position.z + Math.cos(angle) * distance
    );

    this.trails.push({
      mesh: trail,
      life: 60,
      maxLife: 60
    });
    this.scene.add(trail);
  }

  updateTrails() {
    for (let i = this.trails.length - 1; i >= 0; i--) {
      const trail = this.trails[i];
      trail.life--;
      
      const fadeRatio = trail.life / trail.maxLife;
      trail.mesh.material.opacity = fadeRatio * 0.7;
      trail.mesh.scale.setScalar(fadeRatio);
      
      if (trail.life <= 0) {
        this.scene.remove(trail.mesh);
        this.trails.splice(i, 1);
      }
    }
  }

  // Object pool methods
  createBulletObject() {
    const geometry = new THREE.SphereGeometry(0.2, 8, 8);
    const material = new THREE.MeshBasicMaterial({ color: 0x00f2fe });
    return new THREE.Mesh(geometry, material);
  }

  resetBullet(bullet) {
    bullet.position.set(0, 0, 0);
    bullet.visible = true;
    bullet.shouldRelease = false;
  }

  createExplosionObject() {
    const geometry = new THREE.SphereGeometry(5, 16, 16);
    const material = new THREE.MeshBasicMaterial({ 
      color: 0xff4757, 
      transparent: true, 
      opacity: 0.8 
    });
    return new THREE.Mesh(geometry, material);
  }

  resetExplosion(explosion) {
    explosion.position.set(0, 0, 0);
    explosion.scale.setScalar(1);
    explosion.material.opacity = 0.8;
    explosion.visible = true;
    explosion.shouldRelease = false;
  }

  // Utility methods (keeping essential functionality)
  checkPlanetCollision(newPosition, isPlayer = false) {
    for (const planet of this.planets) {
      if (planet.destroyed) continue;
      if (isPlayer && this.landingTarget && planet === this.landingTarget) continue;
      
      const distance = newPosition.distanceTo(planet.center);
      const collisionDistance = planet.config.radius + (isPlayer ? 3 : 2);
      
      if (distance < collisionDistance) {
        if (isPlayer) {
          this.tempVector1.subVectors(newPosition, planet.center).normalize();
          this.playerVelocity.copy(this.tempVector1.multiplyScalar(0.5));
          this.player.health -= GAME_CONFIG.planet.collisionDamage;
          this.createDamageEffect(this.playerShip.position);
          this.audioManager.playDamage();
          this.updateHUD();
          if (this.player.health <= 0) {
            this.gameOver();
          }
        }
        return true;
      }
    }
    return false;
  }

  checkCameraCollision(cameraPosition) {
    for (const planet of this.planets) {
      if (planet.destroyed) continue;
      const distance = cameraPosition.distanceTo(planet.center);
      if (distance < planet.config.radius + 15) {
        return true;
      }
    }
    return false;
  }

  adjustCameraForCollision() {
    // Find best camera position to avoid collisions
    const baseDistance = 60;
    let bestPosition = null;
    let maxDistance = 0;

    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
      const offsetX = Math.sin(angle) * baseDistance;
      const offsetZ = Math.cos(angle) * baseDistance;
      this.tempVector1.set(
        this.playerShip.position.x + offsetX,
        60,
        this.playerShip.position.z + offsetZ
      );

      if (!this.checkCameraCollision(this.tempVector1)) {
        const distanceFromIdeal = this.tempVector1.distanceTo(this.cameraTarget);
        if (!bestPosition || distanceFromIdeal < maxDistance) {
          bestPosition = this.tempVector1.clone();
          maxDistance = distanceFromIdeal;
        }
      }
    }

    if (bestPosition) {
      this.cameraPosition.copy(bestPosition);
    } else {
      this.cameraPosition.set(this.playerShip.position.x, 80, this.playerShip.position.z);
    }
  }

  // Essential game methods (simplified versions)
  fireWeapon() {
    switch (this.player.currentWeapon) {
      case 1: this.fireBlaster(); break;
      case 2: this.fireScatter(3); break;
      case 3: this.fireScatter(5); break;
      case 4: this.fireMine(); break;
      case 5: this.fireLaser(); break;
    }
  }

  fireBlaster() {
    this.createBullet(0);
    this.audioManager.playBlaster();
  }

  fireScatter(count) {
    const spreadAngle = Math.PI / 6;
    for (let i = 0; i < count; i++) {
      const angleOffset = (i - (count - 1) / 2) * (spreadAngle / (count - 1));
      this.createBullet(angleOffset);
    }
    this.audioManager.playScatter();
  }

  createBullet(angleOffset = 0) {
    const bullet = this.bulletPool.get();
    bullet.position.copy(this.playerShip.position);
    bullet.position.y += 0.5;

    const direction = new THREE.Vector3(
      Math.sin(this.playerShip.rotation.y + angleOffset),
      0,
      Math.cos(this.playerShip.rotation.y + angleOffset)
    );

    const bulletData = {
      mesh: bullet,
      velocity: direction.multiplyScalar(GAME_CONFIG.weapons.blaster.speed),
      life: 80
    };

    this.bullets.push(bulletData);
    this.scene.add(bullet);
  }

  destroyEnemy(enemy) {
    this.createExplosion(enemy.mesh.position);
    this.audioManager.playExplosion();
    enemy.mesh.visible = false;
    enemy.health = 0;
    this.player.score += enemy.score;
    this.dropArtifact(enemy.mesh.position);
    this.updateHUD();
  }

  createExplosion(position, size = 5) {
    if (this.explosions.length >= GAME_CONFIG.performance.maxExplosions) return;

    const explosion = this.explosionPool.get();
    explosion.position.copy(position);
    explosion.scale.setScalar(0);
    
    this.explosions.push({
      mesh: explosion,
      scale: 0,
      maxScale: size / 5
    });
    
    this.scene.add(explosion);
  }

  updateExplosions() {
    for (let i = this.explosions.length - 1; i >= 0; i--) {
      const explosion = this.explosions[i];
      explosion.scale += 0.1;
      explosion.mesh.scale.setScalar(explosion.scale);
      explosion.mesh.material.opacity = Math.max(0, 0.8 - explosion.scale * 0.4);

      if (explosion.scale >= explosion.maxScale) {
        this.scene.remove(explosion.mesh);
        this.explosionPool.release(explosion.mesh);
        this.explosions.splice(i, 1);
      }
    }
  }

  updateHUD() {
    document.getElementById('health').textContent = this.player.health;
    document.getElementById('score').textContent = this.player.score;
  }

  gameOver() {
    this.gameStarted = false;
    this.audioManager.stopLaser();
    setTimeout(() => this.showGameOverScreen(), 500);
  }

  showGameOverScreen() {
    const intro = document.getElementById('intro');
    intro.innerHTML = `
      <h1>Game Over</h1>
      <div style="font-size: 2rem; color: #feca57; margin: 20px 0; text-shadow: 0 0 15px rgba(254,202,87,0.8);">
        Final Score: ${this.player.score}
      </div>
      <p>Your mission has ended. The galaxy remembers your courage.</p>
      <button id="playAgainBtn">Play Again</button>
    `;
    intro.classList.remove('hidden');
    
    document.getElementById('playAgainBtn').addEventListener('click', () => {
      this.resetGame();
      intro.classList.add('hidden');
      this.gameStarted = true;
    });
  }

  resetGame() {
    // Reset all game state
    this.player.health = GAME_CONFIG.player.health;
    this.player.score = 0;
    this.playerShip.position.set(50, 5, 50);
    this.playerVelocity.set(0, 0, 0);
    
    // Clear all objects
    this.bullets.forEach(bullet => this.scene.remove(bullet.mesh));
    this.enemyBullets.forEach(bullet => this.scene.remove(bullet.mesh));
    this.trails.forEach(trail => this.scene.remove(trail.mesh));
    this.explosions.forEach(explosion => this.scene.remove(explosion.mesh));
    
    this.bullets = [];
    this.enemyBullets = [];
    this.trails = [];
    this.explosions = [];
    
    // Reset enemies
    this.enemies.forEach(enemy => {
      enemy.health = GAME_CONFIG.enemy.health;
      enemy.attacking = false;
      enemy.retreating = false;
      enemy.mesh.visible = true;
    });
    
    this.updateHUD();
  }

  // Simplified versions of other necessary methods
  updatePlanets() {
    this.planets.forEach(planet => {
      if (!planet.destroyed && planet.config.orbitSpeed) {
        planet.currentAngle += planet.config.orbitSpeed;
        const newX = planet.orbitCenter.x + Math.cos(planet.currentAngle) * planet.orbitDistance;
        const newZ = planet.orbitCenter.z + Math.sin(planet.currentAngle) * planet.orbitDistance;
        planet.mesh.position.set(newX, 0, newZ);
        planet.center.set(newX, 0, newZ);
        planet.mesh.rotation.y += 0.01;
      }
    });
  }

  updateAllies() {
    // Simplified ally AI
    this.allies = this.allies.filter(ally => ally.health > 0);
  }

  updateArtifacts() {
    // Simplified artifact system
    this.artifacts = this.artifacts.filter(artifact => artifact.life > 0);
  }

  updateMines() {
    // Simplified mine system  
    this.mines = this.mines.filter(mine => mine.life > 0);
  }

  updateEffects() {
    // Update player effects
    const currentTime = Date.now();
    if (this.player.effects.speed.active && currentTime > this.player.effects.speed.endTime) {
      this.player.effects.speed.active = false;
    }
    if (this.player.effects.damage.active && currentTime > this.player.effects.damage.endTime) {
      this.player.effects.damage.active = false;
    }
  }

  updateBackground() {
    if (this.backgroundManager) {
      this.backgroundManager.update(this.playerShip.position.x, this.playerShip.position.z);
    }
  }

  updateMinimap() {
    if (this.minimapManager) {
      this.minimapManager.update(this.playerShip.position, this.planets, this.enemies);
    }
  }

  updateLanding() {
    // Simplified landing system
  }

  enemyShoot(enemy) {
    const bulletGeom = new THREE.SphereGeometry(0.3, 8, 8);
    const bulletMat = new THREE.MeshBasicMaterial({ color: 0xff4757 });
    const bullet = new THREE.Mesh(bulletGeom, bulletMat);
    
    bullet.position.copy(enemy.mesh.position);
    const direction = new THREE.Vector3().subVectors(this.playerShip.position, enemy.mesh.position).normalize();
    
    this.enemyBullets.push({
      mesh: bullet,
      velocity: direction.multiplyScalar(1.5),
      life: 80
    });
    
    this.scene.add(bullet);
    this.audioManager.playEnemyShot();
  }

  dropArtifact(position) {
    // Simplified artifact drop
  }

  createDamageEffect(position) {
    this.createExplosion(position, 3);
  }

  destroyPlanet(planet) {
    planet.destroyed = true;
    this.createExplosion(planet.center, planet.config.radius);
    this.audioManager.playExplosion(2);
    this.scene.remove(planet.mesh);
    this.player.score += 500;
    this.updateHUD();
  }

  switchWeapon(weaponNumber) {
    if (weaponNumber >= 1 && weaponNumber <= 5) {
      this.player.currentWeapon = weaponNumber;
      const weaponNames = ['Blaster', 'Scatter', 'Shotgun', 'Mines', 'Laser'];
      document.getElementById('currentWeapon').textContent = `${weaponNumber}-${weaponNames[weaponNumber - 1]}`;
      this.audioManager.playWeaponSwitch();
    }
  }

  fireMine() {
    // Simplified mine creation
  }

  fireLaser() {
    // Simplified laser weapon
  }

  setupEventListeners() {
    document.addEventListener('keydown', (e) => {
      this.keys[e.code] = true;
      if (e.code.startsWith('Digit')) {
        const weaponNumber = parseInt(e.code.charAt(5));
        this.switchWeapon(weaponNumber);
      }
    });

    document.addEventListener('keyup', (e) => {
      this.keys[e.code] = false;
    });

    document.getElementById('startBtn')?.addEventListener('click', () => {
      this.startGame();
    });

    window.addEventListener('resize', () => {
      const aspectRatio = window.innerWidth / window.innerHeight;
      const distance = 60;
      this.camera.left = -distance * aspectRatio;
      this.camera.right = distance * aspectRatio;
      this.camera.top = distance;
      this.camera.bottom = -distance;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
    });
  }

  async startGame() {
    document.getElementById('intro').classList.add('hidden');
    await this.audioManager.start();
    this.gameStarted = true;
  }

  animate() {
    requestAnimationFrame(() => this.animate());
    this.update();
    this.renderer.render(this.scene, this.camera);
  }
}

// Simplified support classes (keeping only essential functionality)
class AudioManager {
  constructor() {
    this.initialized = false;
  }
  
  start() { this.initialized = true; }
  playBlaster() { if (this.initialized) console.log('Blaster sound'); }
  playScatter() { if (this.initialized) console.log('Scatter sound'); }
  playEnemyShot() { if (this.initialized) console.log('Enemy shot sound'); }
  playExplosion() { if (this.initialized) console.log('Explosion sound'); }
  playEnemyHit() { if (this.initialized) console.log('Enemy hit sound'); }
  playDamage() { if (this.initialized) console.log('Damage sound'); }
  playCollision() { if (this.initialized) console.log('Collision sound'); }
  playWeaponSwitch() { if (this.initialized) console.log('Weapon switch sound'); }
  stopLaser() { console.log('Stop laser sound'); }
}

class MinimapManager {
  constructor() {
    this.canvas = document.getElementById('minimapCanvas');
    this.ctx = this.canvas?.getContext('2d');
  }
  
  update(playerPos, planets, enemies) {
    if (!this.ctx) return;
    // Simplified minimap rendering
    this.ctx.clearRect(0, 0, 120, 120);
    this.ctx.fillStyle = 'blue';
    this.ctx.fillRect(58, 58, 4, 4); // Player dot
  }
}

class BackgroundManager {
  constructor(scene) {
    this.scene = scene;
    this.createStarField();
  }
  
  createStarField() {
    const starGeom = new THREE.BufferGeometry();
    const starCount = 500;
    const positions = new Float32Array(starCount * 3);
    
    for (let i = 0; i < starCount; i++) {
      positions[i * 3] = (Math.random() - 0.5) * 1000;
      positions[i * 3 + 1] = (Math.random() - 0.5) * 1000;
      positions[i * 3 + 2] = (Math.random() - 0.5) * 1000;
    }
    
    starGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 1.0 });
    this.stars = new THREE.Points(starGeom, starMat);
    this.scene.add(this.stars);
  }
  
  update(playerX, playerZ) {
    if (this.stars) {
      this.stars.rotation.y += 0.0001;
    }
  }
}

// Initialize the game
const game = new OptimizedSpaceShooter();
    </script> <style>
      body {
        margin: 0;
        padding: 0;
        background: #000;
        font-family: 'Courier New', monospace;
        overflow: hidden
      }

      #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh
      }

      canvas {
        display: block
      }

      #intro {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #0a0a2e, #16213e, #0f3460);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: #fff;
        z-index: 1000;
        transition: opacity 0.5s
      }

      #intro h1 {
        font-size: 4rem;
        margin: 0;
        text-shadow: 0 0 20px #4facfe;
        background: linear-gradient(45deg, #4facfe, #00f2fe);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: glow 2s infinite alternate
      }

      #intro p {
        font-size: 1.2rem;
        margin: 20px 0;
        text-align: center;
        max-width: 600px;
        line-height: 1.6
      }

      #startBtn {
        padding: 15px 30px;
        font-size: 1.5rem;
        background: linear-gradient(45deg, #667eea, #764ba2);
        border: none;
        color: white;
        cursor: pointer;
        border-radius: 50px;
        transition: all 0.3s;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3)
      }

      #startBtn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4)
      }

      #playAgainBtn,
      #backToMenuBtn {
        padding: 12px 25px;
        font-size: 1.2rem;
        background: linear-gradient(45deg, #667eea, #764ba2);
        border: none;
        color: white;
        cursor: pointer;
        border-radius: 40px;
        transition: all 0.3s;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        margin: 10px
      }

      #playAgainBtn:hover,
      #backToMenuBtn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4)
      }

      #playAgainBtn {
        background: linear-gradient(45deg, #00ff88, #00d4aa)
      }

      #backToMenuBtn {
        background: linear-gradient(45deg, #ff6b6b, #ff5252)
      }

      @keyframes glow {
        0% {
          text-shadow: 0 0 20px #4facfe
        }

        100% {
          text-shadow: 0 0 30px #4facfe, 0 0 40px #00f2fe
        }
      }

      #hud {
        position: absolute;
        top: 20px;
        left: 20px;
        color: #4facfe;
        font-size: 1rem;
        z-index: 100;
        text-shadow: 0 0 10px rgba(79, 172, 254, 0.8);
        display: flex;
        flex-direction: column;
        gap: 8px
      }

      #healthHud {
        color: #00ff88;
        font-weight: bold
      }

      #scoreHud {
        color: #feca57;
        font-weight: bold
      }

      #weaponHud {
        color: #ff6b6b;
        font-weight: bold
      }

      #coordinates {
        color: rgba(79, 172, 254, 0.7);
        font-size: 0.9rem
      }

      #minimap {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 120px;
        height: 120px;
        border: 2px solid rgba(79, 172, 254, 0.4);
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(5px);
        z-index: 100;
        transition: all 0.3s ease;
        cursor: pointer
      }

      #minimap.expanded {
        width: 300px;
        height: 300px;
        right: 50%;
        top: 50%;
        transform: translate(50%, -50%);
        z-index: 1001
      }

      #minimapCanvas {
        width: 100%;
        height: 100%;
        border-radius: 6px
      }

      #minimapToggle {
        position: absolute;
        top: -8px;
        right: -8px;
        width: 20px;
        height: 20px;
        background: rgba(79, 172, 254, 0.8);
        color: #fff;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        cursor: pointer;
        border: 1px solid rgba(79, 172, 254, 0.6)
      }

      #minimapToggle:hover {
        background: rgba(79, 172, 254, 1)
      }

      .hidden {
        opacity: 0;
        pointer-events: none
      }

      #controls {
        position: absolute;
        bottom: 20px;
        right: 20px;
        color: rgba(255, 255, 255, 0.7);
        font-size: 0.9rem;
        text-align: right;
        z-index: 100
      }

      #effects {
        position: absolute;
        top: 160px;
        left: 20px;
        color: #feca57;
        font-size: .8rem;
        z-index: 100;
        text-shadow: 0 0 10px rgba(254, 202, 87, 0.8)
      }

      #mobileControls {
        position: absolute;
        bottom: 80px;
        left: 20px;
        right: 20px;
        display: none;
        z-index: 200
      }

      #dpad {
        position: absolute;
        bottom: 80px;
        left: 20px;
        width: 120px;
        height: 120px
      }

      #dpadOuter {
        width: 120px;
        height: 120px;
        border: 3px solid rgba(79, 172, 254, 0.6);
        border-radius: 50%;
        position: absolute;
        background: rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(5px)
      }

      #dpadInner {
        width: 40px;
        height: 40px;
        background: rgba(79, 172, 254, 0.8);
        border-radius: 50%;
        position: absolute;
        top: 40px;
        left: 40px;
        transition: all 0.1s ease;
        box-shadow: 0 0 15px rgba(79, 172, 254, 0.6)
      }

      #fireBtn {
        position: absolute;
        bottom: 100px;
        right: 20px;
        width: 80px;
        height: 80px;
        border: 3px solid rgba(255, 75, 87, 0.6);
        border-radius: 50%;
        background: rgba(255, 75, 87, 0.3);
        color: #fff;
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
        backdrop-filter: blur(5px);
        box-shadow: 0 0 20px rgba(255, 75, 87, 0.4);
        font-weight: bold
      }

      #weaponBtn {
        position: absolute;
        bottom: 200px;
        right: 20px;
        width: 60px;
        height: 60px;
        border: 3px solid rgba(254, 202, 87, 0.6);
        border-radius: 50%;
        background: rgba(254, 202, 87, 0.3);
        color: #fff;
        font-size: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
        backdrop-filter: blur(5px);
        box-shadow: 0 0 20px rgba(254, 202, 87, 0.4);
        font-weight: bold
      }

      #fireBtn:active,
      #weaponBtn:active {
        transform: scale(0.95)
      }

      @media(max-width:768px) {
        #mobileControls {
          display: block
        }

        #controls {
          display: none
        }

        #intro h1 {
          font-size: 2.5rem
        }

        #intro p {
          font-size: 1rem;
          padding: 0 20px
        }

        #hud {
          font-size: 0.9rem
        }

        #minimap {
          width: 100px;
          height: 100px
        }

        #minimap.expanded {
          width: 250px;
          height: 250px
        }
      }

      #hud div {
        margin: 2px 0;
        padding: 2px 0
      }

      #effects div {
        animation: pulse 2s infinite
      }

      @keyframes pulse {

        0%,
        100% {
          opacity: 1
        }

        50% {
          opacity: 0.7
        }
      }

      #dpadOuter:active {
        background: rgba(79, 172, 254, 0.2)
      }

      #fireBtn:active {
        background: rgba(255, 75, 87, 0.5);
        box-shadow: 0 0 30px rgba(255, 75, 87, 0.6)
      }

      #weaponBtn:active {
        background: rgba(254, 202, 87, 0.5);
        box-shadow: 0 0 30px rgba(254, 202, 87, 0.6)
      }

      .fade-in {
        animation: fadeIn 1s ease-in
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px)
        }

        to {
          opacity: 1;
          transform: translateY(0)
        }
      }

      @media(max-width:480px) {
        #intro h1 {
          font-size: 2rem
        }

        #dpad {
          width: 100px;
          height: 100px
        }

        #dpadOuter {
          width: 100px;
          height: 100px
        }

        #dpadInner {
          width: 35px;
          height: 35px;
          top: 32.5px;
          left: 32.5px
        }

        #fireBtn {
          width: 70px;
          height: 70px;
          font-size: 12px
        }

        #weaponBtn {
          width: 50px;
          height: 50px;
          font-size: 10px
        }

        #minimap {
          width: 80px;
          height: 80px
        }

        #minimap.expanded {
          width: 200px;
          height: 200px
        }
      }

      * {
        box-sizing: border-box
      }

      canvas {
        image-rendering: optimizeSpeed;
        image-rendering: -moz-crisp-edges;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: optimize-contrast
      }

      #landingPrompts {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 150
      }

      @keyframes landingPulse {

        0%,
        100% {
          opacity: 1;
          transform: translateX(-50%)scale(1);
          box-shadow: 0 0 10px rgba(0, 255, 136, 0.6)
        }

        50% {
          opacity: 0.8;
          transform: translateX(-50%)scale(1.05);
          box-shadow: 0 0 20px rgba(0, 255, 136, 0.8)
        }
      }

      #dialogueSystem {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
    padding-top: 3em;
    vertical-align: top;
    justify-content: center;
    align-items: flex-start;
        z-index: 1000;
        backdrop-filter: blur(5px)
      }

      #dialogueBox {
        background: linear-gradient(135deg, #0a0a2e, #16213e);
        border: 0px solid #104840;
        border-radius: 15px;
        padding: 0px;
        max-width: 90vw;
        width: 500px;
        text-align: center;
        box-shadow: 0 0 30px rgb(0 60 113);
      }

  #planetImage {
    font-size: 4rem;
    margin-bottom: 15px;
    border-radius: 14px 14px 0 0;
    overflow: hidden;
    text-shadow: 0 0 20px rgba(79, 172, 254, 0.6);
}

#planetImage img {
    width: 100%;
    height: auto;
    display: block;
    animation: planetZoom 18s ease-in-out infinite;
}

@keyframes planetZoom {
    0%,
    100% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.07);
    }
}
      #dialogueContent h3 {
        color: #4facfe;
        margin-top: 0;
        font-size: 1.5rem;
        text-shadow: 0 0 10px rgba(79, 172, 254, 0.8)
      }
#dialogueOptions {
    margin-bottom: 1em;
}
      #dialogueContent p {
        color: #ffffff;
        margin: 20px 0;
    padding: 0 30px;
    line-height: 1.6em;
    min-height: 60px;
    max-height: 12em;
    text-align: left;
    overflow-y: scroll;
      }

      @media(max-width:768px) {
        #dialogueBox {
          padding: 0px;
          width: 95vw;
          max-width: none
        }
        #dialogueSystem{

    padding-top: 1em;
        }

        #planetImage {
          font-size: 3rem
        }

        #dialogueContent h3 {
          font-size: 1.2rem
        }

        #dialogueContent p {
          font-size: 0.9rem;
          min-height: 50px
        }
      }

      .dialogue-btn {
        background: linear-gradient(45deg, #1e32e9, #2196F3);
        border: none;
        color: white;
        padding: 12px 24px;
        font-size: 1rem;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s;
        margin: 10px
      }

      .dialogue-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3)
      }

      #landBtn {
        position: absolute;
        bottom: 20px;
        right: 100px;
        width: 60px;
        height: 60px;
        border: 3px solid rgba(0, 255, 136, 0.6);
        border-radius: 50%;
        background: rgba(0, 255, 136, 0.3);
        color: #fff;
        font-size: 12px;
        display: none;
        align-items: center;
        justify-content: center;
        user-select: none;
        backdrop-filter: blur(5px);
        box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
        font-weight: bold
      }

      #landingPrompts div {
        white-space: nowrap
      }

      @media(max-width:768px) {
        #mobileControls #landBtn {
          display: flex
        }
      }
    </style>
  </body>
</html>