<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Frontier</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js" integrity="sha512-xi/RZRIF/S0hJ+yJJYuZ5yk6/8pCiRlEXZzoguSMl+vk2i3m6UjUO/WcZ11blRL/O+rnj94JRGwt/CHbc9+6EA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  </head>
  <body>
    <div id="gameContainer">
      <div id="intro">
        <h1>Quantum Frontier</h1>
        <p>Navigate through hostile space territories.Defend against alien sentries orbiting distant worlds.Use WASD or Arrow Keys to move,SPACE to fire.Keys 1-5 to change weapons.Stay alert-enemies will attack when you get too close!</p>
        <button id="startBtn">Launch Mission</button>
      </div>
      <div id="hud">
        <div id="healthHud">✚ <span id="health">100</span>
        </div>
        <div id="scoreHud">★ <span id="score">0</span>
        </div>
        <div id="weaponHud">
          <span id="currentWeapon">1-Blaster</span>
        </div>
        <div id="coordinates">
          <span id="posX">0</span>, <span id="posZ">0</span>
        </div>
      </div>
      <div id="minimap">
        <canvas id="minimapCanvas" width="120" height="120"></canvas>
        <div id="minimapToggle">⊞</div>
      </div>
      <div id="effects"></div>
      <div id="controls">
        <div>WASD/Arrows-Move</div>
        <div>SPACE-Fire</div>
        <div>1-5-Weapons</div>
      </div>
      <div id="mobileControls">
        <div id="dpad">
          <div id="dpadOuter"></div>
          <div id="dpadInner"></div>
        </div>
        <div id="fireBtn">FIRE</div>
        <div id="weaponBtn">W <br>1 </div>
      </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
    <script>
      const CONFIG = {
        player: {
          acc: 0.1,
          maxSpeed: 0.8,
          friction: 0.92,
          health: 1000
        },
        space: {
          starCount: 1000,
          rotSpeed: 0.0001,
          size: 600
        },
        enemy: {
          orbitMod: 8,
          baseSpeed: 0.015,
          speedVar: 0.005,
          attackRange: 40,
          health: 30,
          chaseSpeed: 0.3,
          retSpeed: 0.3,
          shootCooldown: 120,
          minDistance: 4
        },
        bullet: {
          speed: 2,
          life: 80,
          damage: 10,
          enemySpeed: 1.5,
          enemyDamage: 15
        },
        weapons: {
          laser: {
            damage: 20,
            width: 10,
            maxDist: 100
          }
        },
        audio: {
          speed: {
            color: 0x00ff00,
            effect: 'speed',
            mult: 1.5,
            duration: 30000
          },
          damage: {
            color: 0xff0000,
            effect: 'damage',
            mult: 2,
            duration: 30000
          },
          health: {
            color: 0x0088ff,
            effect: 'health',
            amount: 200,
            duration: 0
          }
        }
      };
      class ShipFactory {
        static templates = {
          player: {
            type: 'tie',
            scale: 0.9,
            cockpit: 'octahedron',
            cockpitScale: 1.5,
            panelCount: 2,
            panelShape: 'diamond',
            panelSize: 4,
            panelDist: 2.2,
            panelThick: 0.1,
            panelY: 0.2,
            panelZ: 0.1,
            panelRotX: -50,
            panelRotY: 0,
            panelAngle: 0,
            hasStruts: !0,
            strutType: 'hexagonal',
            strutThick: 0.19,
            strutCount: 1,
            strutAngle: -90,
            primaryColor: 0x3742fa,
            secondaryColor: 0x2f3542,
            accentColor: 0x70a1ff,
            cockpitColor: 0xff4757
          },
          fighter: {
            type: 'classic',
            scale: 1,
            bodyWidth: 1.5,
            bodyHeight: 0.2,
            bodyLength: 3,
            hasWings: !0,
            wingSpan: 3,
            wingThick: 0.15,
            wingPos: 0,
            wingRotY: 0,
            wingDihedral: 0,
            engineCount: 2,
            engineSize: 0.25,
            enginePosZ: -1.5,
            engineSpacing: 1.5,
            hasCockpit: !0,
            cockpit: 'sphere',
            cockpitScale: 0.3,
            cockpitY: 0.2,
            cockpitZ: 1,
            primaryColor: 0xff4757,
            secondaryColor: 0xff3838,
            accentColor: 0xff6b6b,
            cockpitColor: 0x2f3542
          },
          interceptor: {
            type: 'tie',
            scale: 1.33,
            cockpit: 'sphere',
            cockpitScale: 1.2,
            panelCount: 2,
            panelShape: 'hexagon',
            panelSize: 2,
            panelDist: 2.5,
            panelThick: 0.1,
            panelY: 0,
            panelZ: 0,
            panelRotX: 5,
            panelRotY: -90,
            panelAngle: 90,
            hasStruts: !0,
            strutType: 'cylinder',
            strutThick: 0.11,
            strutCount: 1,
            strutAngle: 90,
            primaryColor: 0x9b59b6,
            secondaryColor: 0x8e44ad,
            accentColor: 0xd63031,
            cockpitColor: 0x2d3436
          },
          heavy: {
            type: 'classic',
            scale: 1.2,
            bodyWidth: 2.5,
            bodyHeight: 0.4,
            bodyLength: 5,
            hasWings: !0,
            wingSpan: 5,
            wingThick: 0.3,
            wingPos: -1.5,
            wingRotY: 0,
            wingDihedral: 0,
            engineCount: 4,
            engineSize: 0.4,
            enginePosZ: -2.5,
            engineSpacing: 1.5,
            hasCockpit: !0,
            cockpit: 'sphere',
            cockpitScale: 0.5,
            cockpitY: 0.4,
            cockpitZ: 1.5,
            primaryColor: 0x2ed573,
            secondaryColor: 0x1e90ff,
            accentColor: 0x7bed9f,
            cockpitColor: 0xff5252
          },
          scout: {
            type: 'classic',
            scale: 1.6,
            bodyWidth: 1.2,
            bodyHeight: 0.6,
            bodyLength: 4.6,
            hasWings: !0,
            wingSpan: 5.6,
            wingThick: 0.15,
            wingPos: -1.5,
            wingRotY: 0,
            wingDihedral: 0,
            engineCount: 2,
            engineSize: 0.4,
            enginePosZ: -2,
            engineSpacing: 1.6,
            hasCockpit: !0,
            cockpit: 'sphere',
            cockpitScale: 0.5,
            cockpitY: 0.3,
            cockpitZ: -0.5,
            primaryColor: 0xfeca57,
            secondaryColor: 0x2ed9ff,
            accentColor: 0xfeca57,
            cockpitColor: 0x616161
          },
          purplediamond: {
            type: 'tie',
            scale: 1.8,
            cockpit: 'octahedron',
            cockpitScale: 2.1,
            panelCount: 2,
            panelShape: 'triangle',
            panelSize: 1.4,
            panelDist: 2,
            panelThick: 0.5,
            panelY: 0,
            panelZ: 0.1,
            panelRotX: 35,
            panelRotY: 5,
            panelAngle: 0,
            hasStruts: !1,
            strutType: 'cylinder',
            strutThick: 0.19,
            strutCount: 3,
            strutAngle: -10,
            primaryColor: 0x5f27cd,
            secondaryColor: 0xfeca57,
            accentColor: 0x96ceb4,
            cockpitColor: 0x5f27cd
          },
          doradito: {
            type: 'tie',
            scale: 0.5,
            cockpit: 'dodecahedron',
            cockpitScale: 2.1,
            panelCount: 2,
            panelShape: 'diamond',
            panelSize: 4,
            panelDist: 3.3,
            panelThick: 0.4,
            panelY: 0.2,
            panelZ: -2,
            panelRotX: -90,
            panelRotY: 90,
            panelAngle: 0,
            hasStruts: !0,
            strutType: 'box',
            strutThick: 0.29,
            strutCount: 2,
            strutAngle: -40,
            primaryColor: 0xff9f43,
            secondaryColor: 0xff6b6b,
            accentColor: 0xfeca57,
            cockpitColor: 0xfeca57
          }
        };
        static geometries = {
          hexagon: (sz) => new THREE.CylinderGeometry(sz, sz, 0.1, 6),
          square: (sz) => new THREE.BoxGeometry(sz, sz, 0.1),
          diamond: (sz) => {
            const g = new THREE.OctahedronGeometry(sz / 1.4);
            g.scale(1, 1, 0.1);
            return g
          },
          circle: (sz) => new THREE.CylinderGeometry(sz / 2, sz / 2, 0.1, 16),
          triangle: (sz) => {
            const g = new THREE.ConeGeometry(sz, 0.1, 3);
            g.rotateX(Math.PI / 2);
            return g
          },
          star: (sz) => {
            const shape = new THREE.Shape();
            const outerRadius = sz;
            const innerRadius = sz * 0.5;
            const spikes = 5;
            for (let i = 0; i < spikes * 2; i++) {
              const angle = (i / (spikes * 2)) * Math.PI * 2;
              const radius = i % 2 === 0 ? outerRadius : innerRadius;
              const x = Math.cos(angle) * radius;
              const y = Math.sin(angle) * radius;
              if (i === 0) shape.moveTo(x, y);
              else shape.lineTo(x, y)
            }
            return new THREE.ExtrudeGeometry(shape, {
              depth: 0.1,
              bevelEnabled: !1
            })
          }
        };
        static create(templateName, customProps = {}) {
          const template = {
            ...this.templates[templateName],
            ...customProps
          };
          if (!template) {
            console.warn(`Ship template '${templateName}' not found`);
            return this.create('fighter')
          }
          return template.type === 'tie' ? this.createTieShip(template) : this.createClassicShip(template)
        }
        static createTieShip(cfg) {
          const ship = new THREE.Group();
          const sc = cfg.scale || 1.8;
          let cockpitGeom;
          switch (cfg.cockpit || 'sphere') {
            case 'sphere':
              cockpitGeom = new THREE.SphereGeometry((cfg.cockpitScale || 1.2) * sc, 12, 12);
              break;
            case 'box':
              cockpitGeom = new THREE.BoxGeometry((cfg.cockpitScale || 1.2) * sc, (cfg.cockpitScale || 1.2) * sc, (cfg.cockpitScale || 1.2) * sc);
              break;
            case 'octahedron':
              cockpitGeom = new THREE.OctahedronGeometry((cfg.cockpitScale || 1.2) * sc);
              break;
            case 'cylinder':
              cockpitGeom = new THREE.CylinderGeometry((cfg.cockpitScale || 1.2) * sc, (cfg.cockpitScale || 1.2) * sc, (cfg.cockpitScale || 1.2) * sc, 8);
              break;
            case 'dodecahedron':
              cockpitGeom = new THREE.DodecahedronGeometry((cfg.cockpitScale || 1.2) * sc);
              break;
            default:
              cockpitGeom = new THREE.SphereGeometry((cfg.cockpitScale || 1.2) * sc, 12, 12)
          }
          const cockpitMat = new THREE.MeshLambertMaterial({
            color: cfg.cockpitColor || 0xff5252
          });
          const cockpit = new THREE.Mesh(cockpitGeom, cockpitMat);
          ship.add(cockpit);
          for (let i = 0; i < (cfg.panelCount || 2); i++) {
            const panelGeom = this.geometries[cfg.panelShape || 'hexagon']((cfg.panelSize || 2) * sc);
            panelGeom.scale(1, 1, (cfg.panelThick || 0.1) * sc * 10);
            const panelMat = new THREE.MeshLambertMaterial({
              color: cfg.primaryColor || 0x2ed573
            });
            const panel = new THREE.Mesh(panelGeom, panelMat);
            const angle = (i * Math.PI * 2) / (cfg.panelCount || 2);
            const x = Math.cos(angle) * (cfg.panelDist || 2.5) * sc;
            const z = Math.sin(angle) * (cfg.panelDist || 2.5) * sc;
            panel.position.set(x, (cfg.panelY || 0) * sc, z + (cfg.panelZ || 0) * sc);
            panel.rotation.x = ((cfg.panelRotX || 0) * Math.PI) / 180;
            panel.rotation.y = angle + Math.PI / 2 + ((cfg.panelRotY || 0) * Math.PI) / 180;
            panel.rotation.z = ((cfg.panelAngle || 0) * Math.PI) / 180;
            ship.add(panel);
            if (cfg.hasStruts !== !1) {
              for (let s = 0; s < (cfg.strutCount || 1); s++) {
                let strutGeom;
                const strutLength = (cfg.panelDist || 2.5) * sc * 0.8;
                switch (cfg.strutType || 'cylinder') {
                  case 'cylinder':
                    strutGeom = new THREE.CylinderGeometry((cfg.strutThick || 0.1) * sc, (cfg.strutThick || 0.1) * sc, strutLength, 8);
                    break;
                  case 'box':
                    strutGeom = new THREE.BoxGeometry((cfg.strutThick || 0.1) * sc * 2, strutLength, (cfg.strutThick || 0.1) * sc * 2);
                    break;
                  case 'hexagonal':
                    strutGeom = new THREE.CylinderGeometry((cfg.strutThick || 0.1) * sc, (cfg.strutThick || 0.1) * sc, strutLength, 6);
                    break;
                  default:
                    strutGeom = new THREE.CylinderGeometry((cfg.strutThick || 0.1) * sc, (cfg.strutThick || 0.1) * sc, strutLength, 8)
                }
                const strutMat = new THREE.MeshLambertMaterial({
                  color: cfg.secondaryColor || 0x1e90ff
                });
                const strut = new THREE.Mesh(strutGeom, strutMat);
                const strutOffset = (cfg.strutCount || 1) > 1 ? (s - ((cfg.strutCount || 1) - 1) / 2) * 0.3 * sc : 0;
                const strutX = x / 2;
                const strutZ = (z + (cfg.panelZ || 0) * sc) / 2 + strutOffset;
                strut.position.set(strutX, (cfg.panelY || 0) * sc / 2, strutZ);
                strut.rotation.z = -angle + ((cfg.strutAngle || 0) * Math.PI) / 180;
                if ((cfg.strutType || 'cylinder') === 'box') {
                  strut.rotation.y = angle
                }
                ship.add(strut)
              }
            }
          }
          return ship
        }
        static createClassicShip(cfg) {
          const ship = new THREE.Group();
          const sc = cfg.scale || 1.8;
          const bodyGeom = new THREE.BoxGeometry((cfg.bodyWidth || 2) * sc, (cfg.bodyHeight || 0.3) * sc, (cfg.bodyLength || 4) * sc);
          const bodyMat = new THREE.MeshLambertMaterial({
            color: cfg.primaryColor || 0x2ed573
          });
          const body = new THREE.Mesh(bodyGeom, bodyMat);
          ship.add(body);
          if (cfg.hasWings !== !1) {
            const wingGeom = new THREE.BoxGeometry((cfg.wingSpan || 4) * sc, (cfg.wingThick || 0.2) * sc, 1 * sc);
            const wingMat = new THREE.MeshLambertMaterial({
              color: cfg.secondaryColor || 0x1e90ff
            });
            const wing = new THREE.Mesh(wingGeom, wingMat);
            wing.position.set(0, -0.1 * sc, (cfg.wingPos || -1) * sc);
            wing.rotation.z = ((cfg.wingRotY || 0) * Math.PI) / 180;
            wing.rotation.x = ((cfg.wingDihedral || 0) * Math.PI) / 180;
            ship.add(wing)
          }
          const engineCount = cfg.engineCount || 2;
          const engineSpacing = cfg.engineSpacing || 1.5;
          const enginePositions = [];
          if (engineCount === 1) {
            enginePositions.push([0, 0])
          } else if (engineCount === 2) {
            enginePositions.push([-(engineSpacing * sc), 0], [engineSpacing * sc, 0])
          } else if (engineCount === 3) {
            enginePositions.push([0, 0], [-(engineSpacing * sc), 0], [engineSpacing * sc, 0])
          } else if (engineCount === 4) {
            enginePositions.push([-(engineSpacing * sc), 0], [engineSpacing * sc, 0], [-(engineSpacing * sc), 0.3 * sc], [engineSpacing * sc, 0.3 * sc])
          } else if (engineCount === 6) {
            enginePositions.push([-(engineSpacing * sc), 0], [engineSpacing * sc, 0], [-(engineSpacing * sc) * 0.7, 0.3 * sc], [engineSpacing * sc * 0.7, 0.3 * sc], [-(engineSpacing * sc) * 0.7, -0.3 * sc], [engineSpacing * sc * 0.7, -0.3 * sc])
          }
          for (let i = 0; i < enginePositions.length; i++) {
            const engineGeom = new THREE.SphereGeometry((cfg.engineSize || 0.3) * sc, 8, 8);
            const engineMat = new THREE.MeshBasicMaterial({
              color: cfg.accentColor || 0x7bed9f,
              transparent: !0,
              opacity: 0.8
            });
            const engine = new THREE.Mesh(engineGeom, engineMat);
            engine.position.set(enginePositions[i][0], enginePositions[i][1], (cfg.enginePosZ || -2) * sc);
            ship.add(engine)
          }
          if (cfg.hasCockpit !== !1) {
            let cockpitGeom;
            switch (cfg.cockpit || 'sphere') {
              case 'sphere':
                cockpitGeom = new THREE.SphereGeometry((cfg.cockpitScale || 0.4) * sc, 8, 8);
                break;
              case 'box':
                cockpitGeom = new THREE.BoxGeometry((cfg.cockpitScale || 0.4) * sc, (cfg.cockpitScale || 0.4) * sc, (cfg.cockpitScale || 0.4) * sc);
                break;
              case 'cylinder':
                cockpitGeom = new THREE.CylinderGeometry((cfg.cockpitScale || 0.4) * sc, (cfg.cockpitScale || 0.4) * sc, (cfg.cockpitScale || 0.4) * sc, 8);
                break;
              case 'cone':
                cockpitGeom = new THREE.ConeGeometry((cfg.cockpitScale || 0.4) * sc, (cfg.cockpitScale || 0.4) * sc * 1.5, 8);
                break;
              default:
                cockpitGeom = new THREE.SphereGeometry((cfg.cockpitScale || 0.4) * sc, 8, 8)
            }
            const cockpitMat = new THREE.MeshLambertMaterial({
              color: cfg.cockpitColor || 0xff5252
            });
            const cockpit = new THREE.Mesh(cockpitGeom, cockpitMat);
            cockpit.position.set(0, (cfg.cockpitY || 0.3) * sc, (cfg.cockpitZ || 0.5) * sc);
            ship.add(cockpit)
          }
          return ship
        }
      }
      class EnemyFactory {
        static types = {
          'f': {
            shipType: 'fighter',
            health: 30,
            chaseSpeed: 0.4,
            weaponType: 'rapid',
            attackRange: 40,
            score: 100
          },
          'i': {
            shipType: 'interceptor',
            health: 50,
            chaseSpeed: 0.5,
            weaponType: 'burst',
            attackRange: 40,
            score: 150
          },
          's': {
            shipType: 'scout',
            health: 50,
            chaseSpeed: 0.6,
            weaponType: 'burst',
            attackRange: 40,
            score: 150
          },
          'd': {
            shipType: 'doradito',
            health: 50,
            chaseSpeed: 0.6,
            weaponType: 'burst',
            attackRange: 40,
            score: 150
          },
          'p': {
            shipType: 'purplediamond',
            health: 50,
            chaseSpeed: 0.6,
            weaponType: 'burst',
            attackRange: 40,
            score: 150
          },
          'h': {
            shipType: 'heavy',
            health: 100,
            chaseSpeed: 0.3,
            weaponType: 'heavy',
            attackRange: 45,
            score: 200
          }
        };
        static create(type, planet, index, totalCount) {
          const config = this.types[type];
          if (!config) {
            console.warn(`Enemy type '${type}' not found`);
            return null
          }
          const ship = ShipFactory.create(config.shipType);
          const angle = (index * Math.PI * 2) / totalCount;
          return {
            mesh: ship,
            planet: planet,
            angle: angle,
            originalAngle: angle,
            speed: CONFIG.enemy.baseSpeed + Math.random() * CONFIG.enemy.speedVar,
            attackRange: config.attackRange,
            attacking: !1,
            retreating: !1,
            health: config.health,
            maxHealth: config.health,
            type: type,
            chaseSpeed: config.chaseSpeed,
            shootCooldown: 0,
            weaponType: config.weaponType,
            score: config.score,
            stuck: !1
          }
        }
      }
      class PlanetFactory {
        static configs = [{
          radius: 18,
          color: 0xff6b6b,
          distance: 100,
          enemyCount: 9,
          enemyType: 'f',
           style: 'sharp',          // 🔧 Angular mining/industrial surface
          irregularity: 0,   
          health: 200,
          orbitCenter: {
            x: 0,
            z: 0
          },
          orbitSpeed: 0.005,
          startAngle: 0,
          dialogue: {
            name: 'Asteria Prime',
            image: './quantumfrontier/assets/images/planets.jpeg',
             setStoryWaypoint:'Helion IV',
            baseText: 'Asteria Prime fue una vez el mayor exportador de minerales raros del sector, con flotas de cargueros despegando diariamente hacia los mundos centrales. Ahora solo quedan torres de perforación oxidadas y pueblos fantasma barridos por tormentas de polvo./n Entre los datos fragmentados de las últimas semanas antes del abandono, algo no encaja. Transferencias nocturnas, códigos de embarque alterados, y un patrón que solo alguien con tu experiencia podría reconocer: contrabando a gran escala./nEl rastro apunta hacia los cañones rocosos de Helion IV, donde los mercenarios no hacen preguntas.',
            flagTexts: {
              visited_proxima: 'Energy readings from Proxima Centauri b indicate this planet was part of an interconnected network.',
              visited_trappist: 'The quantum signatures resonate with TRAPPIST-1e readings - confirming the ancient network theory.'
            }
          }
        }, {
          radius: 25,
          color: 0xff0000,
          distance: 180,
          enemyCount: 6,
          enemyType: 'd',
          health: 300,
          orbitCenter: {
            x: 0,
            z: 0
          },
          orbitSpeed: 0.003,
          startAngle: Math.PI / 4,
          dialogue: {
            name: 'Pyrrhos',
             setStoryWaypoint:'Helion IV',
            image: './quantumfrontier/assets/images/planets44.jpeg',
            baseText: 'Pyrrhos es un infierno de lava y roca fundida donde los ríos de magma serpentean entre picos de basalto negro. El calor es tan intenso que incluso los drones más resistentes fallan después de pocas horas de exposición. Aquí, la supervivencia se mide en minutos./n Enterrada en las profundidades rocosas, una forja milenaria late con el resplandor de cristales semi-formados. Los grabados en las paredes hablan de una civilización que dominaba energías capaces de abrir puertas entre mundos. Pero también advierten sobre el precio de tal poder./n Las inscripciones apuntan hacia "los guardianes del mundo verde" en Viridara, donde el conocimiento ancestral aguarda entre las ruinas envueltas en vegetación.',
            flagTexts: {
              visited_kepler: 'The crystalline formations here match those found on Kepler-442b - part of the same stellar engineering project.',
              visited_trappist: 'Cross-referencing with TRAPPIST-1e data reveals this is a mining outpost for the ancient network.'
            }
          }
        }, {
          radius: 25,
          color: 0x00ff88,
          distance: 220,
          enemyCount: 6,
          irregularity: 0.4,   
          enemyType: 'p',
          health: 300,
          orbitCenter: {
            x: 50,
            z: 50
          },
          orbitSpeed: 0.002,
          startAngle: Math.PI / 2,
          dialogue: {
            name: 'Helion IV',
            image: 'quantumfrontier/assets/images/planets3.jpeg',
            baseText: 'Los cañones de arenisca roja de Helion IV ocultan una de las fortalezas mercenarias más temidas del sector exterior. Durante décadas, estas paredes rocosas han protegido operaciones que los mundos centrales prefieren ignorar: tráfico de armas, información clasificada, y cargamentos que oficialmente nunca existieron./n Las patrullas aéreas que surcan los desfiladeros son solo la primera advertencia. Aquí, la lealtad se compra con créditos y las preguntas equivocadas pueden costarte más que tu nave. Pero los registros de Asteria Prime no mienten: algo importante pasó por esta fortaleza./n Un contacto en las cantinas subterráneas menciona algo perturbador: el FSA intentó un asalto reciente que terminó en desastre. Los mercenarios hablan de "fragmentos cristalinos" y una guerra que apenas está comenzando.',
            flagTexts: {
              visited_kepler: 'The quantum signatures here resonate with similar readings from Kepler-442b. This confirms the ancient network theory.',
              visited_proxima: 'Data correlation with Proxima Centauri b suggests this was the central hub of an ancient civilization.'
            }
          }
        }];

        static createPlanetTexture(color, radius, type) {
          const canvas = document.createElement('canvas');
          canvas.width = 512;
          canvas.height = 512;
          const ctx = canvas.getContext('2d');
          const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
          if (type === 'gas') {
            gradient.addColorStop(0, `hsl(${(color >> 16) & 255}, 70%, 60%)`);
            gradient.addColorStop(0.3, `hsl(${((color >> 8) & 255) + 20}, 80%, 45%)`);
            gradient.addColorStop(0.7, `hsl(${(color & 255) + 40}, 60%, 35%)`);
            gradient.addColorStop(1, `hsl(${(color >> 16) & 255}, 50%, 25%)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            for (let i = 0; i < 8; i++) {
              ctx.strokeStyle = `hsla(${((color >> 8) & 255) + i * 10}, 60%, ${40 + i * 3}%, 0.6)`;
              ctx.lineWidth = 2 + Math.random() * 3;
              ctx.beginPath();
              ctx.moveTo(0, 100 + i * 40 + Math.sin(i) * 20);
              for (let x = 0; x < 512; x += 10) {
                ctx.lineTo(x, 100 + i * 40 + Math.sin(x * 0.02 + i) * 15 + Math.cos(x * 0.01) * 10)
              }
              ctx.stroke()
            }
          } else if (type === 'ice') {
            const iceGrad = ctx.createLinearGradient(0, 0, 512, 512);
            iceGrad.addColorStop(0, '#b3e5fc');
            iceGrad.addColorStop(0.5, '#81d4fa');
            iceGrad.addColorStop(1, '#4fc3f7');
            ctx.fillStyle = iceGrad;
            ctx.fillRect(0, 0, 512, 512);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            for (let i = 0; i < 200; i++) {
              const x = Math.random() * 512;
              const y = Math.random() * 512;
              const size = Math.random() * 3 + 1;
              ctx.fillRect(x, y, size, size)
            }
            for (let i = 0; i < 50; i++) {
              ctx.strokeStyle = 'rgba(200, 230, 255, 0.6)';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.arc(Math.random() * 512, Math.random() * 512, Math.random() * 20 + 5, 0, Math.PI * 2);
              ctx.stroke()
            }
          } else {
            const baseHue = (color >> 16) & 255;
            ctx.fillStyle = `hsl(${baseHue}, 40%, 35%)`;
            ctx.fillRect(0, 0, 512, 512);
            for (let i = 0; i < 100; i++) {
              const x = Math.random() * 512;
              const y = Math.random() * 512;
              const size = Math.random() * 15 + 5;
              ctx.fillStyle = `hsla(${baseHue + Math.random() * 30 - 15}, 50%, ${25 + Math.random() * 20}%, 0.7)`;
              ctx.beginPath();
              ctx.arc(x, y, size, 0, Math.PI * 2);
              ctx.fill()
            }
            for (let i = 0; i < 50; i++) {
              const x = Math.random() * 512;
              const y = Math.random() * 512;
              const size = Math.random() * 8 + 3;
              ctx.fillStyle = `hsla(${baseHue}, 30%, 20%, 0.8)`;
              ctx.beginPath();
              ctx.arc(x, y, size, 0, Math.PI * 2);
              ctx.fill()
            }
          }
          return new THREE.CanvasTexture(canvas)
        }
static createIrregularPlanet(radius, irregularity = 0, style = 'highdetail') {
  // Configurar subdivisiones según el estilo
   
  let subdivisions;
  switch(style) {
    case 'lowpoly':     subdivisions = [8, 6];   break;  // 🔧 Muy angular
    case 'sharp':       subdivisions = [16, 12]; break;  // 🔧 Angular pero con más detalle
    case 'medium':      subdivisions = [32, 24]; break;  // 🔧 Balance
    case 'smooth':      subdivisions = [64, 64]; break;  // 🔧 Suave (original)
    case 'highdetail':  subdivisions = [128, 96]; break; // 🔧 Muy detallado
    default:            subdivisions = [32, 24];
  }
  
  const geometry = new THREE.SphereGeometry(radius, subdivisions[0], subdivisions[1]);
  const positions = geometry.attributes.position.array;
  const noise = new PerlinNoise(Math.random());
  
  for (let i = 0; i < positions.length; i += 3) {
    const x = positions[i];
    const y = positions[i + 1];
    const z = positions[i + 2];
    const distance = Math.sqrt(x*x + y*y + z*z);
    
    const nx = x / radius;
    const ny = y / radius;
    const nz = z / radius;
    
    // Aplicar ruido según el estilo
    let heightVariation = 0;
    
    if (style === 'lowpoly') {
      // 🔧 ESTILO LOW POLY - Pocos detalles, cambios dramáticos
      heightVariation += noise.noise(nx * 2, ny * 2, nz * 2) * 0.8;
      heightVariation += noise.noise(nx * 4, ny * 4, nz * 4) * 0.4;
      
      // Cuantizar para crear "steps" más marcados
      heightVariation = Math.floor(heightVariation * 4) / 4;
      
    } else if (style === 'sharp') {
      // 🔧 ESTILO SHARP - Detalles medios con bordes definidos
      heightVariation += noise.noise(nx * 3, ny * 3, nz * 3) * 0.7;
      heightVariation += noise.noise(nx * 6, ny * 6, nz * 6) * 0.3;
      heightVariation += noise.noise(nx * 12, ny * 12, nz * 12) * 0.1;
      
      // Aplicar función que acentúa los contrastes
      heightVariation = Math.sign(heightVariation) * Math.pow(Math.abs(heightVariation), 0.7);
      
    } else if (style === 'terraced') {
      // 🔧 ESTILO TERRAZAS - Como mesas/escalones
      heightVariation += noise.noise(nx * 4, ny * 4, nz * 4) * 0.6;
      heightVariation += noise.noise(nx * 8, ny * 8, nz * 8) * 0.3;
      
      // Crear terrazas/escalones
      const steps = 6;
      heightVariation = Math.floor(heightVariation * steps) / steps;
      
    } else {
      // 🔧 ESTILO SMOOTH (original)
      heightVariation += noise.noise(nx * 4, ny * 4, nz * 4) * 0.6;
      heightVariation += noise.noise(nx * 8, ny * 8, nz * 8) * 0.3;
      heightVariation += noise.noise(nx * 16, ny * 16, nz * 16) * 0.1;
    }
    
    const newDistance = radius + (heightVariation * irregularity * radius);
    const factor = newDistance / distance;
    
    positions[i] = x * factor;
    positions[i + 1] = y * factor;
    positions[i + 2] = z * factor;
  }
  
  geometry.attributes.position.needsUpdate = true;
  
  // 🔧 CONTROL DE SUAVIZADO
  if (style === 'lowpoly' || style === 'sharp' || style === 'terraced') {
    // NO computar normales suaves = mantener bordes sharp
    geometry.computeFaceNormals();
  } else {
    // Computar normales suaves para apariencia "blobby"
    geometry.computeVertexNormals();
  }
  
  return geometry;
}
 static create(index,config=null){
    const cfg=config||this.configs[index%this.configs.length];
    const planetTypes=['rocky','ice','rocky','rocky','gas'];
    const initialAngle=cfg.startAngle||((Math.PI*2/this.configs.length)*index);
    let planetGeom;
    const irregularity=cfg.irregularity!==undefined?cfg.irregularity:0.3;
    if(irregularity===0){
        planetGeom=new THREE.SphereGeometry(cfg.radius,32,24)
    }else{
        planetGeom=this.createIrregularPlanet(cfg.radius,irregularity,cfg.style||'medium')
    }
    
    // Don't use complex textures for highly emissive objects (like suns)
    const isHighlyEmissive = cfg.emissiveIntensity && cfg.emissiveIntensity > 0.5;
    const texture = isHighlyEmissive ? null : this.createPlanetTexture(cfg.color,cfg.radius,planetTypes[index%planetTypes.length]);
    const materialProps = texture ? {map:texture,color:cfg.color} : {color:cfg.color};
    
    if(cfg.emissive!==undefined){
        materialProps.emissive=new THREE.Color(cfg.emissive);
        materialProps.emissiveIntensity=cfg.emissiveIntensity||0.3
    }
    
    let planetMat;
    if(cfg.emissiveIntensity&&cfg.emissiveIntensity>0.5){
        // Fix: MeshBasicMaterial doesn't support emissiveIntensity, so we multiply the color
        const emissiveColor = materialProps.emissive || new THREE.Color(cfg.color);
        const intensity = cfg.emissiveIntensity || 1.0;
        emissiveColor.multiplyScalar(intensity);
        
        const basicMaterialProps = {
            color:cfg.color,
            emissive:emissiveColor
        };
        if(texture) basicMaterialProps.map = texture;
        
        planetMat=new THREE.MeshBasicMaterial(basicMaterialProps)
    }else{
        const lambertMaterialProps = {color: cfg.color};
        if(texture) lambertMaterialProps.map = texture;
        if(materialProps.emissive) lambertMaterialProps.emissive = materialProps.emissive;
        if(materialProps.emissiveIntensity) lambertMaterialProps.emissiveIntensity = materialProps.emissiveIntensity;
        
        planetMat=new THREE.MeshLambertMaterial(lambertMaterialProps)
    }
    
    const planet=new THREE.Mesh(planetGeom,planetMat);
    const x=(cfg.orbitCenter?.x||0)+Math.cos(initialAngle)*cfg.distance;
    const z=(cfg.orbitCenter?.z||0)+Math.sin(initialAngle)*cfg.distance;
    planet.position.set(x,0,z);
    planet.rotation.y=Math.random()*Math.PI*2;
    const orbitRadius=cfg.radius+CONFIG.enemy.orbitMod;
    
    return{
        mesh:planet,
        radius:orbitRadius,
        center:planet.position.clone(),
        config:cfg,
        health:cfg.health,
        maxHealth:cfg.health,
        destroyed:!1,
        orbitCenter:{x:cfg.orbitCenter?.x||0,z:cfg.orbitCenter?.z||0},
        orbitDistance:cfg.distance,
        orbitSpeed:cfg.orbitSpeed||0.001,
        currentAngle:initialAngle
    }
}

      }
      class PerlinNoise {
        constructor(seed = Math.random()) {
          this.seed = seed;
          this.p = [];
          for (let i = 0; i < 512; i++) {
            this.p[i] = Math.floor(Math.random() * 256)
          }
          for (let i = 0; i < 256; i++) {
            this.p[256 + i] = this.p[i]
          }
        }
        fade(t) {
          return t * t * t * (t * (t * 6 - 15) + 10)
        }
        lerp(t, a, b) {
          return a + t * (b - a)
        }
        grad(hash, x, y, z) {
          const h = hash & 15;
          const u = h < 8 ? x : y;
          const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
          return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v)
        }
        noise(x, y, z) {
          const X = Math.floor(x) & 255;
          const Y = Math.floor(y) & 255;
          const Z = Math.floor(z) & 255;
          x -= Math.floor(x);
          y -= Math.floor(y);
          z -= Math.floor(z);
          const u = this.fade(x);
          const v = this.fade(y);
          const w = this.fade(z);
          const A = this.p[X] + Y;
          const AA = this.p[A] + Z;
          const AB = this.p[A + 1] + Z;
          const B = this.p[X + 1] + Y;
          const BA = this.p[B] + Z;
          const BB = this.p[B + 1] + Z;
          return this.lerp(w, this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y, z), this.grad(this.p[BA], x - 1, y, z)), this.lerp(u, this.grad(this.p[AB], x, y - 1, z), this.grad(this.p[BB], x - 1, y - 1, z))), this.lerp(v, this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1), this.grad(this.p[BA + 1], x - 1, y, z - 1)), this.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1), this.grad(this.p[BB + 1], x - 1, y - 1, z - 1))))
        }
        turbulence2d(x, y, octaves, persistence) {
          let value = 0;
          let amplitude = 1;
          let frequency = 1;
          let maxValue = 0;
          for (let i = 0; i < octaves; i++) {
            value += Math.abs(this.noise(x * frequency, y * frequency, 0)) * amplitude;
            maxValue += amplitude;
            amplitude *= persistence;
            frequency *= 2
          }
          return value / maxValue
        }
      }
      class Gradient {
        constructor() {
          this.points = []
        }
        add(point) {
          this.points.push(point);
          this.points.sort((a, b) => a[0] - b[0])
        }
        get(t) {
          if (this.points.length === 0) return [0, 0, 0];
          if (t <= this.points[0][0]) return [this.points[0][1], this.points[0][2], this.points[0][3]];
          if (t >= this.points[this.points.length - 1][0]) {
            const last = this.points[this.points.length - 1];
            return [last[1], last[2], last[3]]
          }
          for (let i = 0; i < this.points.length - 1; i++) {
            const p1 = this.points[i];
            const p2 = this.points[i + 1];
            if (t >= p1[0] && t <= p2[0]) {
              const factor = (t - p1[0]) / (p2[0] - p1[0]);
              return [Math.floor(p1[1] + (p2[1] - p1[1]) * factor), Math.floor(p1[2] + (p2[2] - p1[2]) * factor), Math.floor(p1[3] + (p2[3] - p1[3]) * factor)]
            }
          }
          return [0, 0, 0]
        }
      }
      class DeepSpaceGenerator {
        constructor() {
          this.createTexture()
        }
        createTexture() {
          const canvas = document.createElement('canvas');
          canvas.width = canvas.height = 1024;
          const ctx = canvas.getContext('2d');
          const imageData = ctx.getImageData(0, 0, 1024, 1024);
          const noise1 = new PerlinNoise(Math.random());
          const noise2 = new PerlinNoise(Math.random());
          const noise3 = new PerlinNoise(Math.random());
          const gradient = new Gradient();
          const colorThemes = [
            [
              [5, 5, 15],
              [15, 25, 45],
              [25, 15, 60],
              [10, 5, 25]
            ],
            [
              [15, 5, 5],
              [45, 15, 25],
              [60, 25, 15],
              [25, 10, 5]
            ],
            [
              [5, 15, 10],
              [15, 45, 35],
              [25, 60, 45],
              [10, 25, 15]
            ],
            [
              [15, 5, 15],
              [35, 15, 45],
              [50, 25, 60],
              [20, 10, 25]
            ]
          ];
          const theme = colorThemes[Math.floor(Math.random() * colorThemes.length)];
          gradient.add([0, theme[0][0], theme[0][1], theme[0][2]]);
          gradient.add([0.3, theme[1][0], theme[1][1], theme[1][2]]);
          gradient.add([0.6, theme[2][0], theme[2][1], theme[2][2]]);
          gradient.add([1, theme[3][0], theme[3][1], theme[3][2]]);
          const data = imageData.data;
          for (let y = 0; y < 1024; y++) {
            for (let x = 0; x < 1024; x++) {
              const nx = x / 1024 * 8;
              const ny = y / 1024 * 8;
              let noiseValue = noise1.turbulence2d(nx, ny, 8, 0.6);
              noiseValue += noise2.turbulence2d(nx * 2, ny * 2, 4, 0.3) * 0.5;
              noiseValue += noise3.noise(nx * 4, ny * 4, 0) * 0.3;
              noiseValue = Math.pow(Math.max(0, Math.min(1, noiseValue)), 2);
              const color = gradient.get(noiseValue);
              const index = (y * 1024 + x) * 4;
              data[index] = color[0];
              data[index + 1] = color[1];
              data[index + 2] = color[2];
              data[index + 3] = 255
            }
          }
          ctx.putImageData(imageData, 0, 0);
          const texture = new THREE.CanvasTexture(canvas);
          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(1, 1);
          texture.needsUpdate = !0;
          const geometry = new THREE.PlaneGeometry(3000, 3000);
          const material = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: !1,
            opacity: 1
          });
          this.mesh = new THREE.Mesh(geometry, material);
          this.mesh.position.z = -800;
          this.texture = texture
        }
        update(playerX, playerZ) {
          this.mesh.position.x = playerX * 0.2;
          this.mesh.position.y = playerZ * 0.2;
          this.texture.offset.x += 0.000005;
          this.texture.offset.y += 0.000005;
          this.texture.offset.x += playerX * 0.0000009;
          this.texture.offset.y += playerZ * 0.0000009
        }
      }
      class NebulaGenerator {
        constructor() {
          this.group = new THREE.Group();
          this.createNebulas()
        }
        createNebulas() {
          const nebulaColors = [
  [[0,0,0],[30,60,120],[60,150,255],[120,200,255]],     // Brighter blue
  [[0,0,0],[120,30,60],[255,80,150],[255,150,200]],     // Brighter pink
  [[0,0,0],[30,80,60],[100,255,150],[150,255,200]],     // Brighter green
  [[0,0,0],[80,30,120],[180,100,255],[220,150,255]],    // Brighter purple
  [[0,0,0],[120,60,30],[255,150,100],[255,200,150]]     // Brighter orange
];

          for (let layer = 0; layer < 1; layer++) {
            const nebulaTexture = this.createNebulaTexture(layer, nebulaColors[layer]);
            const size = 800 + layer * 200;
            const geometry = new THREE.PlaneGeometry(size, size);
            const material = new THREE.MeshBasicMaterial({
              map: nebulaTexture,
              transparent: !0,
              opacity: 0.33 - layer * 0.03,
              blending: THREE.AdditiveBlending
            });
            const nebula = new THREE.Mesh(geometry, material);
  //          nebula.position.set((Math.random() - 0.5) * 1000, (Math.random() - 0.5) * 1000, -300 - layer * 150);
            // Change Z position:
nebula.position.set(
  (Math.random() - 0.5) * 1000,
  (Math.random() - 0.5) * 1000,
  -100 - layer * 50    // Closer to camera
);
            nebula.rotation.z = Math.random() * Math.PI * 2;
            this.group.add(nebula)
          }
        }
        createNebulaTexture(layer, colorScheme) {
          const canvas = document.createElement('canvas');
          canvas.width = canvas.height = 512;
          const ctx = canvas.getContext('2d');
          const imageData = ctx.getImageData(0, 0, 512, 512);
          const noise = new PerlinNoise(Math.random());
          const gradient = new Gradient();
          gradient.add([0, colorScheme[0][0], colorScheme[0][1], colorScheme[0][2]]);
          gradient.add([0.2, colorScheme[1][0], colorScheme[1][1], colorScheme[1][2]]);
          gradient.add([0.6, colorScheme[2][0], colorScheme[2][1], colorScheme[2][2]]);
          gradient.add([1, colorScheme[3][0], colorScheme[3][1], colorScheme[3][2]]);
          const data = imageData.data;
          for (let y = 0; y < 512; y++) {
            for (let x = 0; x < 512; x++) {
              const nx = (x - 256) / 512 * 8;
              const ny = (y - 256) / 512 * 8;
              const distance = Math.sqrt(nx * nx + ny * ny);
              const angle = Math.atan2(ny, nx);
              const spiral = Math.sin(angle * 3 + distance * 2) * 0.3;
              const radialFalloff = Math.max(0, (1 - distance / 4) + spiral * 0.2);
              let noiseValue = noise.turbulence2d(x / 80, y / 80, 6, 0.6);
              noiseValue += noise.turbulence2d(x / 40, y / 40, 4, 0.4) * 0.7;
              noiseValue += noise.noise(x / 20, y / 20, layer * 5) * 0.5;
              const flow = Math.sin(x / 30 + y / 20) * Math.cos(y / 25) * 0.3;
              noiseValue += flow;
              let intensity = noiseValue * radialFalloff;
              intensity = Math.pow(Math.max(0, Math.min(1, intensity)), 1.8);
              const color = gradient.get(intensity);
              const index = (y * 512 + x) * 4;
              data[index] = color[0];
              data[index + 1] = color[1];
              data[index + 2] = color[2];
              data[index + 3] = Math.floor(intensity * 200 * radialFalloff)
            }
          }
          ctx.putImageData(imageData, 0, 0);
          const texture = new THREE.CanvasTexture(canvas);
          texture.needsUpdate = !0;
          return texture
        }
        update(playerX, playerZ) {
          this.group.children.forEach((nebula, index) => {
            const parallax = 0.005 + index * 0.02;
            const targetX = playerX * parallax + (index - 2) * 200;
            const targetY = playerZ * parallax + (index - 2) * 150;
            nebula.position.x += (targetX - nebula.position.x) * 0.01;
            nebula.position.y += (targetY - nebula.position.y) * 0.01;
            nebula.rotation.z += 0.0001 * (index + 1)
          })
        }
      }
      class BackgroundManager {
        constructor(scene) {
          this.scene = scene;
          this.createStarField();
          this.createDeepSpace();
          this.createNebulas()
        }
        createStarField() {
          const starGeom = new THREE.BufferGeometry();
          const starCount = CONFIG.space.starCount;
          const positions = new Float32Array(starCount * 3);
          const colors = new Float32Array(starCount * 3);
          const sizes = new Float32Array(starCount);
          for (let i = 0; i < starCount; i++) {
            const i3 = i * 3;
            positions[i3] = (Math.random() - 0.5) * CONFIG.space.size;
            positions[i3 + 1] = (Math.random() - 0.5) * CONFIG.space.size;
            positions[i3 + 2] = (Math.random() - 0.5) * CONFIG.space.size;
            const starType = Math.random();
            if (starType < 0.7) {
              colors[i3] = colors[i3 + 1] = colors[i3 + 2] = 1.0
            } else if (starType < 0.85) {
              colors[i3] = 0.7;
              colors[i3 + 1] = 0.8;
              colors[i3 + 2] = 1.0
            } else if (starType < 0.95) {
              colors[i3] = 1.0;
              colors[i3 + 1] = 1.0;
              colors[i3 + 2] = 0.7
            } else {
              colors[i3] = 1.0;
              colors[i3 + 1] = 0.7;
              colors[i3 + 2] = 0.7
            }
            sizes[i] = Math.random() * 2 + 0.5
          }
          starGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          starGeom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
          starGeom.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
          const starMat = new THREE.PointsMaterial({
            size: 1.0,
            vertexColors: !0,
            transparent: !0,
            opacity: 0.8,
            sizeAttenuation: !0
          });
          this.stars = new THREE.Points(starGeom, starMat);
          this.scene.add(this.stars)
        }
        createDeepSpace() {
          this.deepSpaceGenerator = new DeepSpaceGenerator();
          this.scene.add(this.deepSpaceGenerator.mesh)
        }
        createNebulas() {
          this.nebulaGenerator = new NebulaGenerator();
          this.scene.add(this.nebulaGenerator.group)
        }
        update(playerX, playerZ) {
          this.stars.rotation.y += CONFIG.space.rotSpeed;
          if (this.deepSpaceGenerator) {
            this.deepSpaceGenerator.update(playerX, playerZ)
          }
          if (this.nebulaGenerator) {
            this.nebulaGenerator.update(playerX, playerZ)
          }
        }
      }
      class MinimapManager {
        constructor() {
          this.canvas = document.getElementById('minimapCanvas');
          this.ctx = this.canvas.getContext('2d');
          this.expanded = !1;
            this.waypoint = null;
          this.setupEvents()
        }
setupEvents(){
    document.getElementById('minimapToggle').addEventListener('click',()=>{
        this.toggleExpanded()
    });
    
    // Improved click handling for desktop
    this.canvas.addEventListener('click',(e)=>{
        if(this.expanded){
            e.preventDefault();
            e.stopPropagation();
            this.setWaypoint(e);
        }
    });
    
    // Fixed touch handling for mobile
    this.canvas.addEventListener('touchstart',(e)=>{
        if(this.expanded){
            e.preventDefault();
            e.stopPropagation();
        }
    });
    
    this.canvas.addEventListener('touchend',(e)=>{
        if(this.expanded){
            e.preventDefault();
            e.stopPropagation();
            
            // Get the first touch that ended
            const touch = e.changedTouches[0];
            if(touch) {
                // Create a proper event-like object
                const touchEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };
                this.setWaypoint(touchEvent);
            }
        }
    });
    
    this.canvas.addEventListener('touchmove',(e)=>{
        if(this.expanded){
            e.preventDefault();
        }
    });
}

        updateWaypoint() {
    if (this.waypoint && this.waypoint.type === 'planet' && this.waypoint.planet) {
        // Update waypoint position to follow the planet
        this.waypoint.x = this.waypoint.planet.center.x;
        this.waypoint.z = this.waypoint.planet.center.z;
    }
}
setWaypoint(event){
    const rect=this.canvas.getBoundingClientRect();
    
    // Get actual canvas size (not just CSS size)
    const canvasWidth = this.canvas.width;
    const canvasHeight = this.canvas.height;
    
    // Calculate click position relative to canvas, accounting for any scaling
    const scaleX = canvasWidth / rect.width;
    const scaleY = canvasHeight / rect.height;
    
    const clickX = (event.clientX - rect.left) * scaleX;
    const clickY = (event.clientY - rect.top) * scaleY;
    
    const size = this.expanded ? 300 : 120;
    const scale = this.expanded ? 0.8 : 0.3;
    const centerX = size / 2;
    const centerY = size / 2;
    
    // Convert canvas coordinates to world coordinates
    const worldX = (clickX - centerX) / scale + game.playerShip.position.x;
    const worldZ = (clickY - centerY) / scale + game.playerShip.position.z;
    
    let targetPlanet = null;
    let minDistance = Infinity;
    
    // Check for planet clicks with better precision
    game.planets.forEach(planet => {
        if(planet.destroyed) return;
        
        const distance = Math.sqrt(Math.pow(worldX - planet.center.x, 2) + Math.pow(worldZ - planet.center.z, 2));
        const clickRadius = Math.max(planet.config.radius + 10, 20); // Increased minimum click radius for mobile
        
        if(distance < clickRadius && distance < minDistance){
            minDistance = distance;
            targetPlanet = planet;
        }
    });
    
    if(targetPlanet){
        this.waypoint = {
            x: targetPlanet.center.x,
            z: targetPlanet.center.z,
            planet: targetPlanet,
            type: 'planet'
        };
    } else {
        this.waypoint = {
            x: worldX,
            z: worldZ,
            type: 'static'
        };
    }
    
    this.showWaypointSetFeedback(event.clientX, event.clientY);
}
        toggleExpanded() {
          this.expanded = !this.expanded;
          const minimap = document.getElementById('minimap');
          const toggle = document.getElementById('minimapToggle');
          if (this.expanded) {
            minimap.classList.add('expanded');
            toggle.textContent = '⊟';
            this.canvas.width = this.canvas.height = 300
          } else {
            minimap.classList.remove('expanded');
            toggle.textContent = '⊞';
            this.canvas.width = this.canvas.height = 120
          }
        }
update(playerPos,planets,enemies){
    const ctx=this.ctx;
    const size=this.expanded?300:120;
    const scale=this.expanded?0.8:0.3;
    const centerX=size/2;
    const centerY=size/2;
    
    ctx.clearRect(0,0,size,size);
    ctx.fillStyle='rgba(0, 0, 20, 0.9)';
    ctx.fillRect(0,0,size,size);
    ctx.strokeStyle='rgba(79, 172, 254, 0.3)';
    ctx.lineWidth=1;
    ctx.strokeRect(1,1,size-2,size-2);
    
    // Draw orbits when expanded - show all planet orbits
    if(this.expanded){
        planets.forEach(planet=>{
            if(planet.destroyed) return;
            
            // Use the correct orbit properties from the planet object
            const orbitCenterX = (planet.orbitCenter.x - playerPos.x) * scale + centerX;
            const orbitCenterY = (planet.orbitCenter.z - playerPos.z) * scale + centerY;
            const orbitRadius = planet.orbitDistance * scale;
            
            // Show orbit if it has a meaningful radius (skip the sun at center)
            if(orbitRadius > 1) {
                ctx.strokeStyle = 'rgba(150, 150, 150, 0.4)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.arc(orbitCenterX, orbitCenterY, orbitRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        });
    }
    
    // Draw planets - show all planets when expanded, with broader view when collapsed
    planets.forEach(planet=>{
        if(planet.destroyed) return;
        
        const relX = (planet.center.x - playerPos.x) * scale + centerX;
        const relY = (planet.center.z - playerPos.z) * scale + centerY;
        
        // Expanded minimap shows all planets, collapsed shows nearby ones
        const boundary = this.expanded ? size * 2 : 10; // Much larger boundary for expanded view
        
        if(relX >= -boundary && relX <= size + boundary && relY >= -boundary && relY <= size + boundary){
            const radius = Math.max(2, planet.config.radius * scale * 0.3);
            ctx.fillStyle = `#${planet.config.color.toString(16).padStart(6, '0')}`;
            ctx.beginPath();
            ctx.arc(relX, relY, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            if(this.expanded && planet.config.dialogue){
                ctx.fillStyle = '#ffffff';
                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(planet.config.dialogue.name, relX, relY - radius - 5);
            }
        }
    });
    
    // Draw enemies
    enemies.forEach(enemy=>{
        if(enemy.health<=0)return;
        const relX=(enemy.mesh.position.x-playerPos.x)*scale+centerX;
        const relY=(enemy.mesh.position.z-playerPos.z)*scale+centerY;
        
        if(relX>=-5&&relX<=size+5&&relY>=-5&&relY<=size+5){
            ctx.fillStyle=enemy.attacking?'#ff4757':'#ff9f43';
            ctx.beginPath();
            ctx.arc(relX,relY,2,0,Math.PI*2);
            ctx.fill();
        }
    });
    
    // Draw waypoint
    if(this.waypoint){
        const waypointX=(this.waypoint.x-playerPos.x)*scale+centerX;
        const waypointY=(this.waypoint.z-playerPos.z)*scale+centerY;
        
        if(waypointX>=-10&&waypointX<=size+10&&waypointY>=-10&&waypointY<=size+10){
            ctx.fillStyle='#feca57';
            ctx.strokeStyle='#ffffff';
            ctx.lineWidth=2;
            ctx.beginPath();
            ctx.arc(waypointX,waypointY,4,0,Math.PI*2);
            ctx.fill();
            ctx.stroke();
            
            ctx.strokeStyle='#000000';
            ctx.lineWidth=1;
            ctx.beginPath();
            ctx.moveTo(waypointX-2,waypointY-2);
            ctx.lineTo(waypointX+2,waypointY+2);
            ctx.moveTo(waypointX+2,waypointY-2);
            ctx.lineTo(waypointX-2,waypointY+2);
            ctx.stroke();
        }
        
        // Draw waypoint compass arrow
        const dx=this.waypoint.x-playerPos.x;
        const dz=this.waypoint.z-playerPos.z;
        const distance=Math.sqrt(dx*dx+dz*dz);
        
        if(distance>5){
            const angle=Math.atan2(dx,dz);
            const compassRadius=size*0.35;
            const arrowX=centerX+Math.sin(angle)*compassRadius;
            const arrowY=centerY+Math.cos(angle)*compassRadius;
            
            ctx.strokeStyle='#feca57';
            ctx.fillStyle='#feca57';
            ctx.lineWidth=2;
            const arrowSize=6;
            ctx.beginPath();
            ctx.moveTo(arrowX,arrowY);
            ctx.lineTo(arrowX-arrowSize*Math.sin(angle+0.5),arrowY-arrowSize*Math.cos(angle+0.5));
            ctx.lineTo(arrowX-arrowSize*Math.sin(angle-0.5),arrowY-arrowSize*Math.cos(angle-0.5));
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
    }
    
    // Draw player
    ctx.fillStyle='#00f2fe';
    ctx.strokeStyle='#ffffff';
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.arc(centerX,centerY,4,0,Math.PI*2);
    ctx.fill();
    ctx.stroke();
    
    // Draw player direction indicator
    const angle=Math.atan2(0,1);
    const arrowLength=8;
    const arrowX=centerX+Math.cos(angle)*arrowLength;
    const arrowY=centerY+Math.sin(angle)*arrowLength;
    ctx.strokeStyle='#00f2fe';
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(centerX,centerY);
    ctx.lineTo(arrowX,arrowY);
    ctx.stroke();
}
clearWaypoint() {
    this.waypoint = null;
}
      }

class AudioManager {
    constructor() {
        this.initialized = false;
        this.lastCollisionTime = 0;
        this.lastBlasterTime = 0;
        this.lastEnemyShotTime = 0;
        this.mineHum = false;
        this.engineRunning = false;
        this.backgroundMusic = null;
        this.sfxSprite = null;
        this.engineSound = null;
        
        // Track playing sounds to prevent spam
        this.activeSounds = new Map();
        this.maxConcurrentSounds = {
            blaster: 3,
            enemyShot: 4,
            explosion: 2,
            collision: 1
        };
        
        this.setup();
    }

    setup() {
        try {
            const spriteMap = {
                blaster: [0, 132],
                enemyShot: [392, 628],
                scatter: [630, 1372],
                shotgun: [242, 553],
                laser: [4252, 4425],
                explosion: [1996, 2527],
                damage: [3092, 3542],
                collision: [6144, 6530],
                enemyHit: [2538, 3034],
                weaponSwitch: [5278, 5573],
                powerUp: [5278, 5573],
                //powerUp: [4517, 5261],
                mine: [5278, 5573],
                landing: [5607, 7007],
                takeoff: [7112, 8414]
            };

            this.sfxSprite = new Howl({
                src: ['sfx-sprite.mp3'],
                sprite: spriteMap,
                volume: 0.7,
                preload: true,
                onloaderror: (id, error) => {
                    console.warn('Failed to load SFX sprite:', error);
                }
            });

            // Remove background music for now as requested
            this.backgroundMusic = null;
            this.engineSound = null;
            
            this.laserActive = false;
            this.laserSoundId = null;
        } catch (error) {
            console.warn('Audio setup failed:', error);
        }
    }

    // Add spatial audio support
    calculateSpatialVolume(sourcePosition, listenerPosition, baseVolume = 1.0, maxDistance = 100) {
        if (!sourcePosition || !listenerPosition) return baseVolume;
        
        const distance = sourcePosition.distanceTo(listenerPosition);
        if (distance >= maxDistance) return 0;
        
        // Linear falloff - closer = louder
        const spatialVolume = Math.max(0, 1 - (distance / maxDistance));
        return baseVolume * spatialVolume;
    }

    // Improved sound management to prevent spam
    canPlaySound(soundType) {
        const maxConcurrent = this.maxConcurrentSounds[soundType] || 1;
        const activeSoundsOfType = this.activeSounds.get(soundType) || [];
        
        // Clean up finished sounds
        const stillPlaying = activeSoundsOfType.filter(soundId => this.sfxSprite.playing(soundId));
        this.activeSounds.set(soundType, stillPlaying);
        
        return stillPlaying.length < maxConcurrent;
    }

    trackSound(soundType, soundId) {
        if (!this.activeSounds.has(soundType)) {
            this.activeSounds.set(soundType, []);
        }
        this.activeSounds.get(soundType).push(soundId);
    }

    playBlaster(sourcePos = null, listenerPos = null) {
        if (!this.initialized || !this.sfxSprite) return;
        
        // Prevent spam
        const currentTime = Date.now();
        if (currentTime - this.lastBlasterTime < 50) return;
        this.lastBlasterTime = currentTime;
        
        if (!this.canPlaySound('blaster')) return;
        
        try {
            const soundId = this.sfxSprite.play('blaster');
            this.trackSound('blaster', soundId);
            
            // Apply spatial audio if positions provided
            if (sourcePos && listenerPos) {
                const volume = this.calculateSpatialVolume(sourcePos, listenerPos, 0.7, 80);
                this.sfxSprite.volume(volume, soundId);
            }
        } catch (e) {}
    }

    playEnemyShot(sourcePos = null, listenerPos = null) {
        if (!this.initialized || !this.sfxSprite) return;
        
        // Prevent spam
        const currentTime = Date.now();
        if (currentTime - this.lastEnemyShotTime < 30) return;
        this.lastEnemyShotTime = currentTime;
        
        if (!this.canPlaySound('enemyShot')) return;
        
        try {
            const soundId = this.sfxSprite.play('enemyShot');
            this.trackSound('enemyShot', soundId);
            
            // Apply spatial audio
            if (sourcePos && listenerPos) {
                const volume = this.calculateSpatialVolume(sourcePos, listenerPos, 0.6, 100);
                this.sfxSprite.volume(volume, soundId);
            }
        } catch (e) {}
    }

    playExplosion(size = 1, sourcePos = null, listenerPos = null) {
        if (!this.initialized || !this.sfxSprite) return;
        
        if (!this.canPlaySound('explosion')) return;
        
        try {
            const soundId = this.sfxSprite.play('explosion');
            this.trackSound('explosion', soundId);
            
            let volume = Math.min(size * 0.7, 1.0);
            
            // Apply spatial audio
            if (sourcePos && listenerPos) {
                volume = this.calculateSpatialVolume(sourcePos, listenerPos, volume, 150);
            }
            
            this.sfxSprite.volume(volume, soundId);
        } catch (e) {}
    }

    playCollision() {
        if (!this.initialized || !this.sfxSprite) return;
        const currentTime = Date.now();
        if (currentTime - this.lastCollisionTime < 300) return; // Increased cooldown
        this.lastCollisionTime = currentTime;
        
        try {
            this.sfxSprite.play('collision');
        } catch (e) {}
    }

    playDamage() {
        if (!this.initialized || !this.sfxSprite) return;
        const currentTime = Date.now();
        if (currentTime - this.lastCollisionTime < 200) return; // Increased cooldown
        this.lastCollisionTime = currentTime;
        
        try {
            this.sfxSprite.play('damage');
        } catch (e) {}
    }

    // Simplified laser audio
    playLaser() {
        if (!this.initialized || !this.sfxSprite || this.laserActive) return;
        
        try {
            this.laserActive = true;
            this.laserSoundId = this.sfxSprite.play('laser');
            this.sfxSprite.loop(true, this.laserSoundId);
            this.sfxSprite.volume(0.5, this.laserSoundId); // Lower volume for laser
        } catch (e) {
            this.laserActive = false;
        }
    }

    stopLaser() {
        if (!this.initialized || !this.sfxSprite || !this.laserActive) return;
        
        try {
            if (this.laserSoundId) {
                this.sfxSprite.stop(this.laserSoundId);
            }
            this.laserActive = false;
            this.laserSoundId = null;
        } catch (e) {
            this.laserActive = false;
        }
    }

    // Keep all other methods unchanged
    start() {
        if (!this.initialized) {
            try {
                this.initialized = true;
            } catch (error) {
                console.warn('Audio start failed:', error);
            }
        }
    }

    dispose() {
        try {
            if (this.sfxSprite) {
                this.sfxSprite.stop();
                this.sfxSprite.unload();
            }
            if (this.backgroundMusic) {
                this.backgroundMusic.stop();
                this.backgroundMusic.unload();
            }
            if (this.engineSound) {
                this.engineSound.stop();
                this.engineSound.unload();
            }
            this.laserActive = false;
            this.engineRunning = false;
        } catch (error) {
            console.warn('Audio disposal error:', error);
        }
    }

    // Keep other methods as they are, just add spatial audio support where needed
    playScatter() { if (this.initialized && this.sfxSprite) try { this.sfxSprite.play('scatter'); } catch (e) {} }
    playShotgun() { if (this.initialized && this.sfxSprite) try { this.sfxSprite.play('shotgun'); } catch (e) {} }
    playEnemyHit() { if (this.initialized && this.sfxSprite) try { this.sfxSprite.play('enemyHit'); } catch (e) {} }
    playWeaponSwitch() { if (this.initialized && this.sfxSprite) try { this.sfxSprite.play('weaponSwitch'); } catch (e) {} }
    playPowerUp() { if (this.initialized && this.sfxSprite) try { this.sfxSprite.play('powerUp'); } catch (e) {} }
    playMine() { if (this.initialized && this.sfxSprite) try { this.sfxSprite.play('mine'); } catch (e) {} }
    playLanding() { if (this.initialized && this.sfxSprite) try { this.sfxSprite.play('landing'); } catch (e) {} }
    playTakeoff() { if (this.initialized && this.sfxSprite) try { this.sfxSprite.play('takeoff'); } catch (e) {} }

    // Stub methods for removed features
    startBackgroundMusic() {}
    stopBackgroundMusic() {}
    pauseBackgroundMusic() {}
    resumeBackgroundMusic() {}
    startEngine() {}
    stopEngine() {}
    setMasterVolume(volume) { try { Howler.volume(Math.max(0, Math.min(1, volume))); } catch (e) {} }
    setSFXVolume(volume) { if (this.sfxSprite) try { this.sfxSprite.volume(Math.max(0, Math.min(1, volume))); } catch (e) {} }
    setMusicVolume(volume) {}
    setEngineVolume(volume) {}
    mute() { try { Howler.mute(true); } catch (e) {} }
    unmute() { try { Howler.mute(false); } catch (e) {} }
}
      class SpaceShooter {
        constructor() {
          this.initializeRenderer();
          this.initializeGameState();
          this.initializeScene();
          this.setupEventListeners();
          this.animate()
        }

        
// 2. Add helper method to find planet by name (add to SpaceShooter class)
findPlanetByName(planetName){
    return this.planets.find(planet => 
        planet.config.dialogue && 
        planet.config.dialogue.name === planetName
    );
}

// 3. Add method to show navigation notification (add to SpaceShooter class)
showNavigationNotification(targetName){
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 30px;
        left: 50%;
        transform: translateX(-50%);
        color: #00ff88;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        font-weight: bold;
        text-shadow: 0 0 15px rgba(0, 255, 136, 0.9);
        background: rgba(0, 0, 0, 0.8);
        padding: 15px 25px;
        border-radius: 10px;
        border: 2px solid rgba(0, 255, 136, 0.6);
        z-index: 1000;
        animation: waypointFadeTop 3s ease-out forwards;
        pointer-events: none;
        backdrop-filter: blur(5px);
    `;
    notification.textContent = `Navigate to: ${targetName}`;
    document.body.appendChild(notification);
    
    setTimeout(() => {
        if (document.body.contains(notification)) {
            document.body.removeChild(notification);
        }
    }, 33000);
}

        updatePlanets() {
          this.planets.forEach(planet => {
            if (planet.destroyed) return;
            planet.currentAngle += planet.orbitSpeed;
            const newX = planet.orbitCenter.x + Math.cos(planet.currentAngle) * planet.orbitDistance;
            const newZ = planet.orbitCenter.z + Math.sin(planet.currentAngle) * planet.orbitDistance;
            planet.mesh.position.set(newX, 0, newZ);
            planet.center.set(newX, 0, newZ);
            planet.mesh.rotation.y += 0.01
          })
        }
        initializeRenderer() {
          this.scene = new THREE.Scene();
          const aspectRatio = window.innerWidth / window.innerHeight;
          const distance = 44;
          this.camera = new THREE.OrthographicCamera(-distance * aspectRatio, distance * aspectRatio, distance, -distance, 0.1, 2000);
          this.renderer = new THREE.WebGLRenderer({
            antialias: !0
          });
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.setClearColor(0x000011);
          this.renderer.sortObjects = !0;
          document.getElementById('gameContainer').appendChild(this.renderer.domElement)
        }
        spawnAlly() {
    const ally = EnemyFactory.create('f', null, 0, 1); // Red fighter ship
    if (!ally) return;
    
    // Position ally near player
    const angle = Math.random() * Math.PI * 2;
    const distance = 15 + Math.random() * 10;
    ally.mesh.position.set(
        this.playerShip.position.x + Math.cos(angle) * distance,
        5,
        this.playerShip.position.z + Math.sin(angle) * distance
    );
    
    // Mark as ally and set properties
    ally.isAlly = true;
    ally.followSide = Math.random() < 0.5 ? -1 : 1; // Random side
    ally.healCooldown = 0;
    ally.targetPosition = new THREE.Vector3();
    
    this.allies.push(ally);
    this.scene.add(ally.mesh);
}
createWaypointIndicator() {
    this.removeWaypointIndicator();
    
    // Create a bigger arrow indicator
    const arrowGeometry = new THREE.ConeGeometry(1.2, 4, 8); // CHANGED: bigger size (was 0.5, 2)
    const arrowMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x6EFFEE, 
        transparent: true, 
        opacity: 0.8 
    });
    this.waypointIndicator = new THREE.Mesh(arrowGeometry, arrowMaterial);
    // REMOVED: this.waypointIndicator.rotation.x = -Math.PI / 2; // Let lookAt handle direction
    this.scene.add(this.waypointIndicator);
}

removeWaypointIndicator() {
    if (this.waypointIndicator) {
        this.scene.remove(this.waypointIndicator);
        this.waypointIndicator = null;
    }
}

updateWaypointIndicator() {
    const waypoint = this.minimapManager.waypoint;
    
    if (!waypoint) {
        this.removeWaypointIndicator();
        return;
    }
    
    // Check if we've reached the waypoint
    const distance = Math.sqrt(
        Math.pow(this.playerShip.position.x - waypoint.x, 2) + 
        Math.pow(this.playerShip.position.z - waypoint.z, 2)
    );
    
    const reachDistance = waypoint.type === 'planet' ? 
        (waypoint.planet ? waypoint.planet.config.radius + 25 : 20) : 20;
    
    if (distance < reachDistance) {
        if (this.waypointReachedCooldown <= 0) {
            this.showWaypointReachedNotification(waypoint);
            this.minimapManager.waypoint = null; // Clear waypoint
            this.removeWaypointIndicator();
            this.waypointReachedCooldown = 180; // 3 second cooldown
        }
        return;
    }
    
    // Create indicator if it doesn't exist
    if (!this.waypointIndicator) {
        this.createWaypointIndicator();
    }
    
    // Position the indicator
    const direction = new THREE.Vector3(
        waypoint.x - this.playerShip.position.x,
        0,
        waypoint.z - this.playerShip.position.z
    ).normalize();
    
    // Place indicator in front of player
    const indicatorDistance = 8;
    this.waypointIndicator.position.copy(this.playerShip.position);
    this.waypointIndicator.position.add(direction.multiplyScalar(indicatorDistance));
    this.waypointIndicator.position.y = 6;
    
    // Point toward waypoint
    // Point toward waypoint - UPDATED FOR PROPER DIRECTION
const waypointTarget = new THREE.Vector3(waypoint.x, this.waypointIndicator.position.y, waypoint.z);
this.waypointIndicator.lookAt(waypointTarget);
this.waypointIndicator.rotateX(Math.PI / 2); // ADDED: Adjust for cone orientation
    
    // Add subtle pulsing animation
    const pulse = 0.8 + 0.2 * Math.sin(Date.now() * 0.005);
    this.waypointIndicator.scale.setScalar(pulse);
    // Animate rings
this.waypointIndicator.children.forEach(child => {
    if (child.userData.ringIndex !== undefined) {
        child.rotation.z += 0.02 * (child.userData.ringIndex + 1);
        child.material.opacity = (0.4 - child.userData.ringIndex * 0.1) * pulse;
    }
});
}

showWaypointReachedNotification(waypoint) {
    // Create subtle notification - POSITIONED NEAR TOP
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 30px;
        left: 50%;
        transform: translateX(-50%);
        color: #feca57;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        font-weight: bold;
        text-shadow: 0 0 15px rgba(254, 202, 87, 0.9);
        background: rgba(0, 0, 0, 0.8);
        padding: 15px 25px;
        border-radius: 10px;
        border: 2px solid rgba(254, 202, 87, 0.6);
        z-index: 1000;
        animation: waypointFadeTop 2s ease-out forwards;
        pointer-events: none;
        backdrop-filter: blur(5px);
    `;
    
    const message = waypoint.type === 'planet' && waypoint.planet?.config.dialogue ?
        `Reached: ${waypoint.planet.config.dialogue.name}` :
        'Waypoint Reached';
    
    notification.textContent = message;
    document.body.appendChild(notification);
    
    // Add CSS animation if not exists - UPDATED ANIMATION NAME
    if (!document.querySelector('#waypointStyles')) {
        const style = document.createElement('style');
        style.id = 'waypointStyles';
        style.textContent = `
            @keyframes waypointFadeTop {
                0% { 
                    opacity: 0; 
                    transform: translateX(-50%) translateY(-20px) scale(0.8); 
                }
                20% { 
                    opacity: 1; 
                    transform: translateX(-50%) translateY(0px) scale(1); 
                }
                80% { 
                    opacity: 1; 
                    transform: translateX(-50%) translateY(0px) scale(1); 
                }
                100% { 
                    opacity: 0; 
                    transform: translateX(-50%) translateY(-10px) scale(1.05); 
                }
            }
        `;
        document.head.appendChild(style);
    }
    
    // Remove notification after animation
    setTimeout(() => {
        if (document.body.contains(notification)) {
            document.body.removeChild(notification);
        }
    }, 2000);
    
    // Play subtle sound
    this.audioManager.playWeaponSwitch();
}
showWaypointSetFeedback(x, y) {
    // Create brief visual feedback for mobile users
    const feedback = document.createElement('div');
    feedback.style.cssText = `
        position: fixed;
        left: ${x}px;
        top: ${y}px;
        width: 20px;
        height: 20px;
        border: 2px solid #feca57;
        border-radius: 50%;
        background: rgba(254, 202, 87, 0.3);
        transform: translate(-50%, -50%);
        z-index: 1001;
        pointer-events: none;
        animation: waypointSetPulse 0.6s ease-out forwards;
    `;
    
    document.body.appendChild(feedback);
    
    // Add CSS if not exists
    if (!document.querySelector('#waypointSetStyles')) {
        const style = document.createElement('style');
        style.id = 'waypointSetStyles';
        style.textContent = `
            @keyframes waypointSetPulse {
                0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
                50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.8; }
                100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
    }
    
    setTimeout(() => {
        if (document.body.contains(feedback)) {
            document.body.removeChild(feedback);
        }
    }, 600);
}
        initializeGameState() {
          this.gameStarted = !1;
          this.trails = [];
          this.allies = [];

    this.waypointIndicator = null; // ADD THIS
    this.waypointReachedCooldown = 0; // ADD THIS
          this.collisionEnabled = !0;
          this.trailStyle = 'nebula';
          this.player = {
            health: CONFIG.player.health,
            score: 0,
            currentWeapon: 1,
            effects: {
              speed: {
                active: !1,
                endTime: 0
              },
              damage: {
                active: !1,
                endTime: 0
              }
            }
          };
          this.keys = {};
          this.bullets = [];
          this.enemyBullets = [];
          this.artifacts = [];
          this.mines = [];
          this.enemies = [];
          this.planets = [];
          this.stars = [];
          this.collisionCooldown = 0;
          this.shootPressed = !1;
          this.playerShip = null;
          this.playerVelocity = new THREE.Vector3();
          this.laserBeam = null;
          this.landingGlow = null;
          this.originalPlayerMaterials = null;
          this.touchControls = {
            moveX: 0,
            moveY: 0,
            firing: !1
          };
          this.audioManager = new AudioManager();
          this.minimapManager = new MinimapManager();
          this.explosions = [];
          this.landingState = 'none';
          this.landingTarget = null;
          this.landingStartPos = null;
          this.landingProgress = 0;
          this.landingDuration = 5000;
          this.landingStartTime = 0;
          this.wasPlayerVisible = !0;
          this.visitedPlanets = new Set();
          this.typewriterSpeed = 7;

        }
        initializeScene() {
          this.camera.position.set(0, 60, 60);
          this.camera.lookAt(0, 0, 0);
          const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
          this.scene.add(ambientLight);
          const directionalLight = new THREE.DirectionalLight(0xffeedd, 0.8);
          directionalLight.position.set(1, 10, 5);
          this.scene.add(directionalLight);
          this.backgroundManager = new BackgroundManager(this.scene);
          this.createPlayer();
          this.createPlanets();
          this.createEnemies();
          this.spawnAlly();
          this.spawnAlly();
          this.spawnAlly();
        }
        createPlayer() {
          this.playerShip = ShipFactory.create('player');
          this.playerShip.position.set(50, 5, 50);
          this.scene.add(this.playerShip)
        }
        createPlanets() {
          const sunConfig = {
            radius: 10,
            color: 0xffdf22,
            distance: 0,
            enemyCount: 0,
            irregularity:0,
               emissive: 0xffffff,        // 🔧 Orange-yellow glow
    emissiveIntensity: 1,    // 🔧 Triggers MeshBasicMaterial
    
    enemyType: 'f',
            health: 1000,
            orbitCenter: {
              x: 0,
              z: 0
            },
            orbitSpeed: 0,
            startAngle: 0
          };
          const sun = PlanetFactory.create(0, sunConfig);
          
          this.planets.push(sun);
          this.scene.add(sun.mesh);
           // Add point light at sun position for realistic lighting
  const sunLight = new THREE.PointLight(0xffaa00, 1, 1000);
  sunLight.position.copy(sun.mesh.position);
  this.scene.add(sunLight);


          for (let i = 0; i < PlanetFactory.configs.length; i++) {
            const planet = PlanetFactory.create(i);
            this.planets.push(planet);
            this.scene.add(planet.mesh)
          }
        }
        createEnemies() {
          this.planets.forEach((planet, planetIndex) => {
            const config = planet.config;
            for (let i = 0; i < config.enemyCount; i++) {
              const enemy = EnemyFactory.create(config.enemyType, planet, i, config.enemyCount);
              if (enemy) {
                this.updateEnemyPosition(enemy);
                this.enemies.push(enemy);
                this.scene.add(enemy.mesh)
              }
            }
          })
        }
        updateEnemyPosition(enemy) {
          const x = enemy.planet.center.x + Math.cos(enemy.angle) * enemy.planet.radius;
          const z = enemy.planet.center.z + Math.sin(enemy.angle) * enemy.planet.radius;
          enemy.mesh.position.set(x, 5, z)
        }
        switchWeapon(weaponNumber) {
    if (weaponNumber >= 1 && weaponNumber <= 5) {
        this.player.currentWeapon = weaponNumber;
        const weaponNames = ['Blaster', 'Scatter', 'Shotgun', 'Mines', 'Laser'];
        document.getElementById('currentWeapon').textContent = `${weaponNumber}-${weaponNames[weaponNumber-1]}`;
        document.getElementById('weaponBtn').innerHTML = `W<br>${weaponNumber}`;
        
        if (this.laserBeam) {
            this.scene.remove(this.laserBeam);
            this.laserBeam = null;
            this.audioManager.stopLaser();
        }
        
        // Use weaponSwitch sound, NOT powerUp
        //this.audioManager.playWeaponSwitch();
    }
}
        cycleWeapon() {
          const nextWeapon = this.player.currentWeapon % 5 + 1;
          this.switchWeapon(nextWeapon)
        }
        isPlanetLandable(planet){
    if(planet.destroyed) return false;
    
    // Don't allow landing on emissive planets (like the sun)
    if(planet.config.emissiveIntensity && planet.config.emissiveIntensity > 0.5) return false;
    
    const livingEnemies = this.enemies.filter(enemy => 
        enemy.planet === planet && enemy.health > 0
    ).length;
    
    return livingEnemies === 0;
}
        renderLandingPrompts() {
          const promptsContainer = document.getElementById('landingPrompts');
          if (!promptsContainer) {
            const container = document.createElement('div');
            container.id = 'landingPrompts';
            container.style.cssText = `position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 150;`;
            document.getElementById('gameContainer').appendChild(container)
          }
          promptsContainer.innerHTML = '';
          if (this.landingState !== 'none') return;
          this.planets.forEach(planet => {
            if (!this.isPlanetLandable(planet)) return;
            const distanceToPlayer = planet.center.distanceTo(this.playerShip.position);
            if (distanceToPlayer > 80) return;
            const vector = planet.center.clone();
            vector.project(this.camera);
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (vector.y * -0.5 + 0.5) * window.innerHeight;
            if (x >= -100 && x <= window.innerWidth + 100 && y >= -100 && y <= window.innerHeight + 100) {
              const planetName = document.createElement('div');
              planetName.style.cssText = `position: absolute;left: ${x}px;top: ${y - 70}px;transform: translateX(-50%);color: #4facfe;font-family: 'Courier New', monospace;font-size: 18px;font-weight: bold;text-shadow: 0 0 15px rgba(79, 172, 254, 0.9);text-align: center;`;
              planetName.textContent = this.getPlanetName(planet);
              promptsContainer.appendChild(planetName);
              const prompt = document.createElement('div');
              prompt.style.cssText = `position: absolute;left: ${x}px;top: ${y - 45}px;transform: translateX(-50%);color: #00ff88;font-family: 'Courier New', monospace;font-size: 14px;font-weight: bold;text-shadow: 0 0 10px rgba(0, 255, 136, 0.8);background: rgba(0, 0, 0, 0.8);padding: 6px 14px;border-radius: 15px;border: 2px solid rgba(0, 255, 136, 0.6);animation: landingPulse 2s infinite;backdrop-filter: blur(3px);pointer-events: auto;cursor: pointer;user-select: none;`;
              prompt.textContent = 'Press [E] to Land';
              prompt.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.startLanding()
              });
              prompt.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.startLanding()
              });
              promptsContainer.appendChild(prompt)
            }
          })
        }
        startLanding() {
          if (this.landingState !== 'none') return;
          let nearestPlanet = null;
          let nearestDistance = Infinity;
          this.planets.forEach(planet => {
            if (!this.isPlanetLandable(planet)) return;
            const distance = planet.center.distanceTo(this.playerShip.position);
            if (distance < 80 && distance < nearestDistance) {
              nearestDistance = distance;
              nearestPlanet = planet
            }
          });
          if (!nearestPlanet) return;
          this.landingState = 'landing';
          this.landingTarget = nearestPlanet;
          this.landingStartPos = this.playerShip.position.clone();
          this.landingStartTime = Date.now();
          this.landingProgress = 0;
          this.wasPlayerVisible = this.playerShip.visible;
          this.audioManager.playLanding()
        }
        updateLanding() {
          if (this.landingState === 'none') return;
          // Safety check - if landing target is null, reset landing state
          if (!this.landingTarget || !this.landingTarget.center) {
            console.warn('Landing target is null, resetting landing state');
            this.landingState = 'none';
            this.landingTarget = null;
            this.removeLandingGlow();
            this.collisionEnabled = true;
            // Ensure player is visible and properly positioned
            if (this.playerShip) {
              this.playerShip.visible = true;
              this.playerShip.scale.setScalar(1.0);
            }
            return;
          }
          const currentTime = Date.now();
          const elapsedTime = currentTime - this.landingStartTime;
          this.landingProgress = Math.min(elapsedTime / this.landingDuration, 1);
          if (this.landingState === 'landing') {
            this.collisionEnabled = false;
            if (this.landingProgress >= 1) {
              this.removeLandingGlow();
              this.restorePlayerDepth();
              this.landingState = 'landed';
              this.showDialogue();
              return;
            }
            this.playerShip.visible = true;
            const planetCenter = this.landingTarget.center.clone();
            const targetPos = planetCenter.clone();
            const currentPos = this.landingStartPos.clone().lerp(targetPos, this.easeInOutCubic(this.landingProgress));
            this.playerShip.position.copy(currentPos);
            this.makePlayerAlwaysVisible();
            this.createLandingGlow();
            const scale = 1.0 - (this.landingProgress * 0.95);
            this.playerShip.scale.setScalar(Math.max(0.05, scale));
            const planetRadius = this.landingTarget.config.radius;
            const cameraDistance = planetRadius * 2.2;
            const cameraHeight = planetRadius * 1.2;
            const cameraAngle = this.landingProgress * 0.3;
            const cameraPos = new THREE.Vector3(planetCenter.x + Math.cos(cameraAngle) * cameraDistance, planetCenter.y + cameraHeight, planetCenter.z + Math.sin(cameraAngle) * cameraDistance);
            this.camera.position.copy(cameraPos);
            this.camera.lookAt(currentPos);
            this.playerVelocity.set(0, 0, 0);
          } else if (this.landingState === 'taking_off') {
            this.collisionEnabled = false;
            if (this.landingProgress >= 1) {
              this.landingState = 'none';
              this.removeLandingGlow();
              this.restorePlayerDepth();
              this.playerShip.visible = this.wasPlayerVisible;
              this.scheduleCollisionReactivation();
              return;
            }
            const planetCenter = this.landingTarget.center.clone();
            const safeDistance = this.landingTarget.config.radius + 20;
            let bestDirection = this.findSafeTakeoffDirection(planetCenter);
            const endPos = planetCenter.clone().add(bestDirection.multiplyScalar(safeDistance));
            endPos.y = 5;
            this.makePlayerAlwaysVisible();
            this.createLandingGlow();
            const startCameraPos = new THREE.Vector3(planetCenter.x, planetCenter.y + 20, planetCenter.z + 30);
            const endCameraPos = new THREE.Vector3(endPos.x, 60, endPos.z + 60);
            const progress = this.easeInOutCubic(this.landingProgress);
            const currentCameraPos = startCameraPos.clone().lerp(endCameraPos, progress);
            this.camera.position.copy(currentCameraPos);
            const currentPlayerPos = planetCenter.clone().lerp(endPos, progress);
            this.playerShip.position.copy(currentPlayerPos);
            const scale = 0.05 + (this.landingProgress * 0.95);
            this.playerShip.scale.setScalar(scale);
            if (this.landingProgress > 0.98) {
              this.playerShip.scale.setScalar(1.0);
            }
            this.playerShip.visible = this.wasPlayerVisible;
            this.camera.lookAt(this.playerShip.position);
          }
        }
        findSafeTakeoffDirection(planetCenter) {
          const testDirections = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1), new THREE.Vector3(0.707, 0, 0.707), new THREE.Vector3(-0.707, 0, 0.707), new THREE.Vector3(0.707, 0, -0.707), new THREE.Vector3(-0.707, 0, -0.707)];
          let bestDirection = testDirections[0];
          let maxMinDistance = 0;
          for (let direction of testDirections) {
            const testPoint = planetCenter.clone().add(direction.clone().multiplyScalar(this.landingTarget.config.radius + 25));
            let minDistance = Infinity;
            for (let planet of this.planets) {
              if (planet === this.landingTarget || planet.destroyed) continue;
              const distance = testPoint.distanceTo(planet.center) - planet.config.radius;
              minDistance = Math.min(minDistance, distance)
            }
            if (minDistance > maxMinDistance) {
              maxMinDistance = minDistance;
              bestDirection = direction
            }
          }
          return bestDirection.normalize()
        }
        scheduleCollisionReactivation() {
          let consecutiveFramesAtSafeDistance = 0;
          const requiredFrames = 10;
          const checkDistance = () => {
            // Safety check
            if (!this.landingTarget || !this.landingTarget.center) {
              this.collisionEnabled = true;
              this.landingTarget = null;
              return;
            }
            const distanceFromPlanet = this.playerShip.position.distanceTo(this.landingTarget.center);
            const safeDistance = this.landingTarget.config.radius + 15;
            const playerToPlanet = new THREE.Vector3().subVectors(this.landingTarget.center, this.playerShip.position);
            const isMovingAway = this.playerVelocity.dot(playerToPlanet) < 0;
            if (distanceFromPlanet > safeDistance && (isMovingAway || this.playerVelocity.length() < 0.1)) {
              consecutiveFramesAtSafeDistance++;
              if (consecutiveFramesAtSafeDistance >= requiredFrames) {
                this.collisionEnabled = true;
                this.landingTarget = null;
                return;
              }
            } else {
              consecutiveFramesAtSafeDistance = 0;
            }
            requestAnimationFrame(checkDistance);
          };
          requestAnimationFrame(checkDistance);
        }
        easeInOutCubic(t) {
          return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2
        }
        easeInOutQuad(t) {
          return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t
        }
        showDialogue() {
          const dialogueSystem = document.getElementById('dialogueSystem');
          if (!dialogueSystem) {
            const dialogue = document.createElement('div');
            dialogue.id = 'dialogueSystem';
            dialogue.className = 'hidden';
            dialogue.innerHTML = `
                                                                                
              <div id="dialogueBox">
                <div id="dialogueContent">
                  <div id="planetImage"></div>
                  <h3 id="dialogueTitle">Planet</h3>
                  <p id="dialogueText"></p>
                  <div id="dialogueOptions">
                    <button class="dialogue-btn" onclick="game.closeDialogue()">Take Off</button>
                  </div>
                </div>
              </div>`;
            document.getElementById('gameContainer').appendChild(dialogue)
          }
          document.getElementById('dialogueSystem').classList.remove('hidden');
          const planetConfig = this.landingTarget.config;
          const dialogue = planetConfig.dialogue;
          //document.getElementById('planetImage').textContent = dialogue.image || '🪐';
          function setPlanetImage(dialogue) {
  const planetImageElement = document.getElementById('planetImage');
  
  if (!planetImageElement) {
    console.error('Element with id "planetImage" not found');
    return;
  }
  
  const imageContent = dialogue.image || '🪐';
  
  // Limpiar el contenido actual
  planetImageElement.innerHTML = '';
  
  // Verificar si es una ruta de imagen (más flexible)
  const isImagePath = imageContent.includes('/') || /\.(jpg|jpeg|png|gif|webp|svg)$/i.test(imageContent);
  
  if (isImagePath) {
    // Crear elemento img para rutas de imagen
    const imgElement = document.createElement('img');
    imgElement.src = imageContent;
    imgElement.alt = dialogue.name || 'Planet';
    imgElement.style.cssText = `
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      display: block;
    `;
    
    // Manejar error de carga - fallback al emoji por defecto
    imgElement.onerror = () => {
      console.warn(`Failed to load image: ${imageContent}`);
      planetImageElement.innerHTML = '';
      planetImageElement.textContent = '🪐';
    };
    
    // Confirmar que la imagen se está cargando
    imgElement.onload = () => {
      console.log(`Image loaded successfully: ${imageContent}`);
    };
    
    planetImageElement.appendChild(imgElement);
  } else {
    // Si no es una ruta de imagen, usar como emoji/texto
    planetImageElement.textContent = imageContent;
  }
}
 setPlanetImage(dialogue);
          document.getElementById('dialogueTitle').textContent = `${dialogue.name}`;
          let dialogueText = dialogue.baseText;
          if (dialogue.flagTexts) {
            for (const [flag, text] of Object.entries(dialogue.flagTexts)) {
              if (this.visitedPlanets.has(flag)) {
                dialogueText += ' ' + text;
                break
              }
            }
          }
          this.typeWriter(dialogueText, 'dialogueText');
          const planetKey = `visited_${dialogue.name.toLowerCase().replace(/[^a-z]/g,'')}`;
          this.visitedPlanets.add(planetKey)
        }
        typeWriter(text, elementId, index = 0) {
  const element = document.getElementById(elementId);
  if (index === 0) element.textContent = '';
  
  if (index < text.length) {
    element.textContent += text.charAt(index);
    
    // Auto-scroll to bottom to show newly typed content
    element.scrollTop = element.scrollHeight;
    
    setTimeout(() => this.typeWriter(text, elementId, index + 1), this.typewriterSpeed);
  }
}
        closeDialogue(){
    const currentPlanet = this.landingTarget;
    const storyWaypoint = currentPlanet.config.dialogue?.setStoryWaypoint;
    
    document.getElementById('dialogueSystem').classList.add('hidden');
    this.landingState = 'taking_off';
    this.landingStartTime = Date.now();
    this.landingProgress = 0;
    this.playerShip.visible = false;
    
    // Set story waypoint based on type (coordinates or planet name)
    if (storyWaypoint) {
        let waypointData = null;
        let displayName = '';
        
        // Check if it's coordinates (object with x, z properties)
        if (typeof storyWaypoint === 'object' && storyWaypoint.x !== undefined && storyWaypoint.z !== undefined) {
            waypointData = {
                x: storyWaypoint.x,
                z: storyWaypoint.z,
                type: 'static'
            };
            displayName = `Coordinates (${storyWaypoint.x}, ${storyWaypoint.z})`;
        }
        // Otherwise treat as planet name
        else if (typeof storyWaypoint === 'string') {
            const targetPlanet = this.findPlanetByName(storyWaypoint);
            if (targetPlanet) {
                waypointData = {
                    x: targetPlanet.center.x,
                    z: targetPlanet.center.z,
                    planet: targetPlanet,
                    type: 'planet'
                };
                displayName = storyWaypoint;
            }
        }
        
        // Set the waypoint and show notification
        if (waypointData) {
            this.minimapManager.waypoint = waypointData;
            
            // Show navigation notification after a short delay
            setTimeout(() => {
                this.showNavigationNotification(displayName);
                //this.audioManager.playWeaponSwitch(); // Reuse power-up sound
            }, 100);
        }
    }
}
        getPlanetName(planet) {
          return planet.config.dialogue?.name || `Planet ${this.planets.indexOf(planet) + 1}`
        }
        fireWeapon() {
          switch (this.player.currentWeapon) {
            case 1:
              this.fireBlaster();
              break;
            case 2:
              this.fireScatter(3);
              break;
            case 3:
              this.fireScatter(5);
              break;
            case 4:
              this.fireMine();
              break;
            case 5:
              this.fireLaser();
              break
          }
        }
        fireBlaster() {
    this.createBullet(0);
    this.audioManager.playBlaster(this.playerShip.position, this.playerShip.position); // Same position for player sounds
}

        fireScatter(count) {
          const spreadAngle = Math.PI / 6;
          for (let i = 0; i < count; i++) {
            const angleOffset = (i - (count - 1) / 2) * (spreadAngle / (count - 1));
            this.createBullet(angleOffset)
          }
          if (count === 3) {
            this.audioManager.playScatter()
          } else {
            this.audioManager.playShotgun()
          }
        }
        createBullet(angleOffset = 0) {
          try {
            const bulletGeom = new THREE.SphereGeometry(0.2, 8, 8);
            const bulletMat = new THREE.MeshBasicMaterial({
              color: 0x00f2fe
            });
            const bullet = new THREE.Mesh(bulletGeom, bulletMat);
            if (!this.playerShip || !this.playerShip.position) {
              console.warn('Player ship not available for bullet creation');
              return;
            }
            bullet.position.copy(this.playerShip.position);
            bullet.position.y += 0.5;
            const direction = new THREE.Vector3(Math.sin(this.playerShip.rotation.y + angleOffset), 0, Math.cos(this.playerShip.rotation.y + angleOffset));
            const bulletVelocity = direction.clone().multiplyScalar(CONFIG.bullet.speed);
            const bulletObject = {
              mesh: bullet,
              velocity: bulletVelocity,
              life: CONFIG.bullet.life
            };
            this.bullets.push(bulletObject);
            this.scene.add(bullet);
          } catch (e) {
            console.error('Failed to create bullet:', e);
          }
        }
        fireMine() {
          const mineGeom = new THREE.SphereGeometry(0.5, 8, 8);
          const mineMat = new THREE.MeshBasicMaterial({
            color: 0xff4757,
            transparent: !0,
            opacity: 0.8
          });
          const mine = new THREE.Mesh(mineGeom, mineMat);
          mine.position.copy(this.playerShip.position);
          mine.position.y += 0.5;
          this.mines.push({
            mesh: mine,
            life: 600,
            exploded: !1
          });
          this.scene.add(mine);
          this.audioManager.playMine()
        }
        fireLaser() {
          if (this.laserBeam) {
            this.scene.remove(this.laserBeam)
          }
          const direction = new THREE.Vector3(Math.sin(this.playerShip.rotation.y), 0, Math.cos(this.playerShip.rotation.y));
          const laserEnd = this.playerShip.position.clone().add(direction.clone().multiplyScalar(CONFIG.weapons.laser.maxDist));
          const laserGeom = new THREE.BufferGeometry().setFromPoints([this.playerShip.position.clone().add(new THREE.Vector3(0, 0.5, 0)), laserEnd]);
          const laserMat = new THREE.LineBasicMaterial({
            color: 0x00ff00,
            transparent: !0,
            opacity: 0.8
          });
          this.laserBeam = new THREE.Line(laserGeom, laserMat);
          this.scene.add(this.laserBeam);
          this.audioManager.playLaser();
          let hitSomething = !1;
          const damage = this.player.effects.damage.active ? CONFIG.weapons.laser.damage * CONFIG.audio.damage.mult : CONFIG.weapons.laser.damage;
          this.enemies.forEach(enemy => {
            if (enemy.health > 0) {
              const distanceToLine = this.distancePointToLine(enemy.mesh.position, this.playerShip.position, laserEnd);
              if (distanceToLine < 2) {
                enemy.health -= damage;
                hitSomething = !0;
                if (enemy.health <= 0) {
                  this.createExplosion(enemy.mesh.position);
                  this.audioManager.playExplosion();
                  enemy.mesh.visible = !1;
                  this.player.score += enemy.score;
                  this.dropArtifact(enemy.mesh.position);
                  this.updateHUD()
                } else {
                  this.audioManager.playEnemyHit()
                }
              }
            }
          });
          this.planets.forEach(planet => {
            if (!planet.destroyed) {
              const distanceToLine = this.distancePointToLine(planet.center, this.playerShip.position, laserEnd);
              if (distanceToLine < planet.config.radius) {
                planet.health -= damage;
                hitSomething = !0;
                if (planet.health <= 0) {
                  this.destroyPlanet(planet)
                }
              }
            }
          })
        }
        distancePointToLine(point, lineStart, lineEnd) {
          const lineDir = new THREE.Vector3().subVectors(lineEnd, lineStart);
          const pointToStart = new THREE.Vector3().subVectors(point, lineStart);
          const t = Math.max(0, Math.min(1, pointToStart.dot(lineDir) / lineDir.dot(lineDir)));
          const projection = lineStart.clone().add(lineDir.multiplyScalar(t));
          return point.distanceTo(projection)
        }
        makePlayerAlwaysVisible() {
          if (!this.originalPlayerMaterials) {
            this.originalPlayerMaterials = [];
            this.playerShip.traverse((child) => {
              if (child.isMesh) {
                this.originalPlayerMaterials.push({
                  mesh: child,
                  material: child.material.clone()
                })
              }
            })
          }
          this.playerShip.traverse((child) => {
            if (child.isMesh) {
              child.material.depthTest = !1;
              child.material.depthWrite = !1;
              child.renderOrder = 999
            }
          });
          this.playerShip.renderOrder = 999
        }
        restorePlayerDepth() {
          if (this.originalPlayerMaterials) {
            this.originalPlayerMaterials.forEach(({
              mesh,
              material
            }) => {
              mesh.material.depthTest = !0;
              mesh.material.depthWrite = !0;
              mesh.renderOrder = 0
            });
            this.playerShip.renderOrder = 0
          }
        }
        createLandingGlow() {
          this.removeLandingGlow();
          this.landingGlow = this.playerShip.clone();
          this.landingGlow.scale.multiplyScalar(1.3);
          this.landingGlow.traverse((child) => {
            if (child.isMesh) {
              child.material = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: !0,
                opacity: 0.4,
                side: THREE.DoubleSide,
                depthTest: !1,
                depthWrite: !1
              });
              child.renderOrder = 998
            }
          });
          this.landingGlow.renderOrder = 998;
          this.scene.add(this.landingGlow)
        }
        removeLandingGlow() {
          if (this.landingGlow) {
            this.scene.remove(this.landingGlow);
            this.landingGlow = null
          }
        }
        updateLandingGlowEffect() {
          if (this.landingGlow && this.playerShip) {
            this.landingGlow.position.copy(this.playerShip.position);
            this.landingGlow.rotation.copy(this.playerShip.rotation);
            const baseScale = this.playerShip.scale.x * 1.3;
            this.landingGlow.scale.setScalar(baseScale);
            const pulseIntensity = 0.2 + 0.8 * Math.sin(Date.now() * 0.008);
            this.landingGlow.traverse((child) => {
              if (child.isMesh && child.material) {
                child.material.opacity = 0.2 + pulseIntensity * 0.4;
                const hue = (Date.now() * 0.001) % 1;
                child.material.color.setHSL(0.5 + hue * 0.2, 1, 0.6)
              }
            })
          }
        }
        update() {
          if (!this.gameStarted) return;
          this.updateLanding();
          this.updateLandingGlowEffect();
          this.renderLandingPrompts();
          if (this.landingState === 'none' || this.landingState === 'landed') {
            this.updatePlayer()
          }
          this.updateTrails();
          this.updatePlanets();
          this.updateEnemies();
          this.updateAllies();
          this.updateBullets();
          this.updateEnemyBullets();
          this.updateArtifacts();
          this.updateMines();
          this.updateCollisions();
          this.updateBackground();
          this.updateEffects();
           this.minimapManager.updateWaypoint(); // Update planet waypoints
    this.updateWaypointIndicator(); // Update 3D indicator
    if (this.waypointReachedCooldown > 0) this.waypointReachedCooldown--;
          this.updateMinimap();
          this.updateExplosions()
        }
        updateAllies() {
    this.allies = this.allies.filter(ally => {
        if (ally.health <= 0) {
            this.scene.remove(ally.mesh);
            return false;
        }
        
        const distanceToPlayer = ally.mesh.position.distanceTo(this.playerShip.position);
        const combatRadius = 40;
        const followDistance = 25;
        
        // Find nearby enemies
        const nearbyEnemies = this.enemies.filter(enemy => 
            enemy.health > 0 && 
            enemy.mesh.position.distanceTo(this.playerShip.position) < combatRadius
        );
        
        let moveDirection = new THREE.Vector3();
        
        if (nearbyEnemies.length > 0) {
            // Combat mode - attack nearest enemy
            const target = nearbyEnemies.reduce((nearest, enemy) => 
                enemy.mesh.position.distanceTo(ally.mesh.position) < 
                nearest.mesh.position.distanceTo(ally.mesh.position) ? enemy : nearest
            );
            
            moveDirection.subVectors(target.mesh.position, ally.mesh.position).normalize();
            ally.mesh.position.add(moveDirection.multiplyScalar(0.9));
            
            // Shoot at enemy
            ally.shootCooldown--;
            if (ally.shootCooldown <= 0) {
                this.createAllyBullet(ally, target);
                ally.shootCooldown = 40;
            }
        } else {
            // Follow/heal mode
            if (distanceToPlayer > followDistance) {
                // Follow player directly when too far
                moveDirection.subVectors(this.playerShip.position, ally.mesh.position).normalize();
                ally.mesh.position.add(moveDirection.multiplyScalar(0.8));
            } else {
               // Stay in formation behind and to side with improved positioning
const baseDistance = 15 + (ally.followSide * 2); // Vary distance per ally
const sideAngle = ally.followSide * Math.PI/3 + (Math.sin(Date.now() * 0.001 + ally.followSide) * 0.1); // Slight dynamic movement

const behindOffset = new THREE.Vector3(
    Math.sin(this.playerShip.rotation.y + sideAngle) * baseDistance,
    Math.sin(Date.now() * 0.002 + ally.followSide * 2) * 0.5, // Subtle vertical bobbing
    Math.cos(this.playerShip.rotation.y + sideAngle) * baseDistance
);

ally.targetPosition.copy(this.playerShip.position).add(behindOffset);

const distanceToTarget = ally.mesh.position.distanceTo(ally.targetPosition);
if (distanceToTarget > 2) {
    moveDirection.subVectors(ally.targetPosition, ally.mesh.position).normalize();
    
    // Improved movement with better speed scaling and smoothing
    const moveSpeed = Math.min(0.4, distanceToTarget * 0.15) * (0.8 + Math.random() * 0.4);
    ally.mesh.position.add(moveDirection.multiplyScalar(moveSpeed));
    
    // Smooth rotation towards movement direction
    const targetRotation = Math.atan2(moveDirection.x, moveDirection.z);
    ally.mesh.rotation.y += (targetRotation - ally.mesh.rotation.y) * 0.1;
}
            }
            
            // Heal player with visual effect
            ally.healCooldown--;
            if (ally.healCooldown <= 0 && this.player.health < CONFIG.player.health) {
                this.player.health = Math.min(CONFIG.player.health, this.player.health + 5);
                ally.healCooldown = 30;
                this.updateHUD();
                
                // Create healing beam visual
                this.createHealingBeam(ally, this.playerShip);
            }
        }
        
        // Always rotate to face movement direction
        if (moveDirection.length() > 0.1) {
            const targetRotation = Math.atan2(moveDirection.x, moveDirection.z);
            ally.mesh.rotation.y = targetRotation;
        } else if (nearbyEnemies.length === 0) {
            // Face same direction as player when in formation
            ally.mesh.rotation.y = this.playerShip.rotation.y;
        }
        const avoidanceRadius = 13;
this.allies.forEach(otherAlly => {
    if (otherAlly === ally) return;
    const distance = ally.mesh.position.distanceTo(otherAlly.mesh.position);
    if (distance < avoidanceRadius && distance > 0) {
        const avoidDirection = new THREE.Vector3()
            .subVectors(ally.mesh.position, otherAlly.mesh.position)
            .normalize()
            .multiplyScalar((avoidanceRadius - distance) * 1);
        ally.mesh.position.add(avoidDirection);
    }
});
        ally.mesh.position.y = 5;
        return true;
    });
}
createAllyBullet(ally, target) {
    const bulletGeom = new THREE.SphereGeometry(0.3, 8, 8);
    const bulletMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const bullet = new THREE.Mesh(bulletGeom, bulletMat);
    bullet.position.copy(ally.mesh.position);
    bullet.position.y += 0.5;
    const direction = new THREE.Vector3().subVectors(target.mesh.position, ally.mesh.position).normalize();
    const bulletVelocity = direction.multiplyScalar(CONFIG.bullet.speed * 1.5);
    
    this.bullets.push({
        mesh: bullet,
        velocity: bulletVelocity,
        life: CONFIG.bullet.life,
        isAlly: true,
        damage: 25
    });
    this.scene.add(bullet);
    
    // Add spatial audio for ally shots
    this.audioManager.playBlaster(ally.mesh.position, this.playerShip.position);
}
        createTrail() {
          if (Math.random() > 0.3) return;
          const trailCount = 3;
          const coneAngle = Math.PI / 4;
          const behindDistance = 3;
          for (let i = 0; i < trailCount; i++) {
            const spreadAngle = (Math.random() - 0.5) * coneAngle;
            const playerAngle = this.playerShip.rotation.y + Math.PI;
            const finalAngle = playerAngle + spreadAngle;
            const distance = behindDistance + Math.random() * 2;
            const x = this.playerShip.position.x + Math.sin(finalAngle) * distance;
            const z = this.playerShip.position.z + Math.cos(finalAngle) * distance;
            const noiseValue = new PerlinNoise().noise(x * 0.1, z * 0.1, Date.now() * 0.001);
            const intensity = Math.abs(noiseValue);
            const trailGeom = new THREE.SphereGeometry(0.3 + intensity * 0.5, 6, 6);
            const hue = (intensity * 360 + 200) % 360;
            const trailMat = new THREE.MeshBasicMaterial({
              color: new THREE.Color().setHSL(hue / 360, 0.8, 0.6),
              transparent: !0,
              opacity: 0.7
            });
            const trail = new THREE.Mesh(trailGeom, trailMat);
            trail.position.set(x, 4 + Math.random(), z);
            this.trails.push({
              mesh: trail,
              life: 60 + Math.random() * 40,
              maxLife: 60 + Math.random() * 40
            });
            this.scene.add(trail)
          }
        }
        updateTrails() {
          this.trails = this.trails.filter(trail => {
            trail.life--;
            const fadeRatio = trail.life / trail.maxLife;
            trail.mesh.material.opacity = fadeRatio * 0.7;
            trail.mesh.scale.setScalar(fadeRatio);
            if (trail.life <= 0) {
              this.scene.remove(trail.mesh);
              return !1
            }
            return !0
          })
        }
        updatePlayer() {
          let moveX = 0,
            moveZ = 0;
          if (this.keys.KeyW || this.keys.ArrowUp || this.touchControls.moveY < -0.3) moveZ -= 1;
          if (this.keys.KeyS || this.keys.ArrowDown || this.touchControls.moveY > 0.3) moveZ += 1;
          if (this.keys.KeyA || this.keys.ArrowLeft || this.touchControls.moveX < -0.3) moveX -= 1;
          if (this.keys.KeyD || this.keys.ArrowRight || this.touchControls.moveX > 0.3) moveX += 1;
          if (moveX !== 0 || moveZ !== 0) {
            if (moveX !== 0 && moveZ !== 0) {
              moveX *= Math.SQRT1_2;
              moveZ *= Math.SQRT1_2
            }
            const speedMultiplier = this.player.effects.speed.active ? CONFIG.audio.speed.mult : 1;
            this.playerVelocity.x += moveX * CONFIG.player.acc * speedMultiplier;
            this.playerVelocity.z += moveZ * CONFIG.player.acc * speedMultiplier
          }
          this.playerVelocity.multiplyScalar(CONFIG.player.friction);
          const maxSpeed = CONFIG.player.maxSpeed * (this.player.effects.speed.active ? CONFIG.audio.speed.mult : 1);
          const clampedVelocity = this.playerVelocity.clone().clampLength(0, maxSpeed);
          this.playerVelocity.copy(clampedVelocity);
          const newPosition = this.playerShip.position.clone().add(this.playerVelocity);
          if (!this.checkPlanetCollision(newPosition, !0)) {
            this.playerShip.position.copy(newPosition);
            this.playerShip.position.y = 5
          }
          if (this.playerVelocity.length() > 0.1) {
            this.createTrail()
          }
          if (this.playerVelocity.length() > 0.1) {
            const angle = Math.atan2(this.playerVelocity.x, this.playerVelocity.z);
            this.playerShip.rotation.y = angle
          }
          if ((this.keys.Space && !this.shootPressed) || this.touchControls.firing) {
            this.fireWeapon();
            this.shootPressed = !0
          } else if (!this.keys.Space && !this.touchControls.firing) {
            this.shootPressed = !1;
            if (this.laserBeam) {
              this.scene.remove(this.laserBeam);
              this.laserBeam = null;
              this.audioManager.stopLaser()
            }
          }
          const targetCameraX = this.playerShip.position.x;
          const targetCameraZ = this.playerShip.position.z + 60;
          const cameraPosition = new THREE.Vector3(targetCameraX, 60, targetCameraZ);
          if (!this.checkCameraCollision(cameraPosition)) {
            this.camera.position.copy(cameraPosition)
          } else {
            this.adjustCameraForCollision()
          }
          this.camera.lookAt(this.playerShip.position);
          this.updateCoordinates()
        }
        updateEnemies() {
          this.enemies.forEach(enemy => {
            if (enemy.health <= 0 || enemy.stuck) return;
            const distanceToPlayer = enemy.mesh.position.distanceTo(this.playerShip.position);
            enemy.shootCooldown--;
            if (distanceToPlayer < enemy.attackRange && !enemy.attacking) {
              enemy.attacking = !0;
              enemy.retreating = !1
            }
            if (enemy.attacking) {
              const distanceToPlayer = enemy.mesh.position.distanceTo(this.playerShip.position);
              const avoidanceForce = this.calculateEnemyAvoidance(enemy);
              if (distanceToPlayer > CONFIG.enemy.minDistance * 1.5) {
                const directionToPlayer = new THREE.Vector3().subVectors(this.playerShip.position, enemy.mesh.position).normalize();
                const combinedDirection = directionToPlayer.add(avoidanceForce).normalize();
                const moveDistance = Math.min(enemy.chaseSpeed, distanceToPlayer - CONFIG.enemy.minDistance);
                const movement = combinedDirection.multiplyScalar(moveDistance);
                const newPosition = enemy.mesh.position.clone().add(movement);
                if (!this.checkPlanetCollision(newPosition)) {
                  enemy.mesh.position.copy(newPosition);
                  enemy.mesh.position.y = 5
                }
              } else {
                const tangentAngle = Math.atan2(this.playerShip.position.z - enemy.mesh.position.z, this.playerShip.position.x - enemy.mesh.position.x) + Math.PI / 2;
                const circleDirection = new THREE.Vector3(Math.cos(tangentAngle), 0, Math.sin(tangentAngle));
                const combinedDirection = circleDirection.add(avoidanceForce.multiplyScalar(2)).normalize();
                const movement = combinedDirection.multiplyScalar(enemy.chaseSpeed * 0.7);
                const newPosition = enemy.mesh.position.clone().add(movement);
                if (!this.checkPlanetCollision(newPosition)) {
                  enemy.mesh.position.copy(newPosition);
                  enemy.mesh.position.y = 5
                }
              }
              enemy.mesh.lookAt(this.playerShip.position);
              if (enemy.shootCooldown <= 0 && distanceToPlayer < 30 && distanceToPlayer > CONFIG.enemy.minDistance * 0.8) {
                this.enemyShoot(enemy);
                enemy.shootCooldown = this.getShootCooldown(enemy.weaponType)
              }
              if (distanceToPlayer > enemy.attackRange * 2.5) {
                enemy.attacking = !1;
                enemy.retreating = !0
              }
            } else if (enemy.retreating) {
              if (distanceToPlayer < enemy.attackRange * 1.2) {
                enemy.attacking = !0;
                enemy.retreating = !1;
                return
              }
              const targetPosition = new THREE.Vector3(enemy.planet.center.x + Math.cos(enemy.originalAngle) * enemy.planet.radius, 5, enemy.planet.center.z + Math.sin(enemy.originalAngle) * enemy.planet.radius);
              const distanceToTarget = enemy.mesh.position.distanceTo(targetPosition);
              if (distanceToTarget > 2) {
                const direction = new THREE.Vector3().subVectors(targetPosition, enemy.mesh.position).normalize().multiplyScalar(CONFIG.enemy.retSpeed);
                const newPos = enemy.mesh.position.clone().add(direction);
                newPos.y = 5;
                enemy.mesh.position.copy(newPos);
                const lookAhead = enemy.mesh.position.clone().add(direction);
                enemy.mesh.lookAt(lookAhead)
              } else {
                enemy.retreating = !1;
                enemy.angle = enemy.originalAngle
              }
            } else {
              enemy.angle += enemy.speed;
              this.updateEnemyPosition(enemy);
              const nextAngle = enemy.angle + enemy.speed;
              const nextX = enemy.planet.center.x + Math.cos(nextAngle) * enemy.planet.radius;
              const nextZ = enemy.planet.center.z + Math.sin(nextAngle) * enemy.planet.radius;
              const nextPosition = new THREE.Vector3(nextX, 5, nextZ);
              enemy.mesh.lookAt(nextPosition)
            }
          })
        }
        calculateEnemyAvoidance(currentEnemy) {
          const avoidanceForce = new THREE.Vector3();
          let neighborCount = 0;
          this.enemies.forEach(otherEnemy => {
            if (otherEnemy === currentEnemy || otherEnemy.health <= 0) return;
            const distance = currentEnemy.mesh.position.distanceTo(otherEnemy.mesh.position);
            const avoidanceRadius = 12;
            if (distance < avoidanceRadius && distance > 0) {
              const repelDirection = new THREE.Vector3().subVectors(currentEnemy.mesh.position, otherEnemy.mesh.position);
              const repelStrength = Math.max(0.3, (avoidanceRadius - distance) / avoidanceRadius * 2);
              repelDirection.normalize().multiplyScalar(repelStrength);
              avoidanceForce.add(repelDirection);
              neighborCount++
            }
          });
          const playerDistance = currentEnemy.mesh.position.distanceTo(this.playerShip.position);
          if (playerDistance < CONFIG.enemy.minDistance) {
            const repelFromPlayer = new THREE.Vector3().subVectors(currentEnemy.mesh.position, this.playerShip.position);
            const repelStrength = Math.max(0.5, (CONFIG.enemy.minDistance - playerDistance) / CONFIG.enemy.minDistance * 3);
            repelFromPlayer.normalize().multiplyScalar(repelStrength);
            avoidanceForce.add(repelFromPlayer)
          }
          if (neighborCount > 0) {
            avoidanceForce.divideScalar(Math.max(1, neighborCount * 0.5))
          }
          return avoidanceForce
        }
        enemyShoot(enemy) {
    const weaponTypes = {
        'rapid': () => {
            this.createEnemyBullet(enemy);
            this.audioManager.playEnemyShot(enemy.mesh.position, this.playerShip.position);
        },
        'burst': () => {
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    if (enemy.health > 0) {
                        this.createEnemyBullet(enemy);
                        this.audioManager.playEnemyShot(enemy.mesh.position, this.playerShip.position);
                    }
                }, i * 100);
            }
        },
        'heavy': () => {
            this.createEnemyBullet(enemy);
            this.audioManager.playEnemyShot(enemy.mesh.position, this.playerShip.position);
        }
    };
    const shootFunction = weaponTypes[enemy.weaponType] || weaponTypes.rapid;
    shootFunction();
}
        createEnemyBullet(enemy) {
          const bulletGeom = new THREE.SphereGeometry(0.3, 8, 8);
          const bulletMat = new THREE.MeshBasicMaterial({
            color: 0xff4757,
            emissive: 0xff2030,
            emissiveIntensity: 0.5
          });
          const bullet = new THREE.Mesh(bulletGeom, bulletMat);
          bullet.position.copy(enemy.mesh.position);
          bullet.position.y = 5;
          const direction = new THREE.Vector3().subVectors(this.playerShip.position, enemy.mesh.position).normalize();
          const bulletVelocity = direction.clone().multiplyScalar(CONFIG.bullet.enemySpeed);
          this.enemyBullets.push({
            mesh: bullet,
            velocity: bulletVelocity,
            life: CONFIG.bullet.life
          });
          this.scene.add(bullet)
        }
        getShootCooldown(weaponType) {
          const cooldowns = {
            'rapid': 60,
            'burst': 180,
            'heavy': 150
          };
          return cooldowns[weaponType] || 120
        }
        updateBullets() {
          this.bullets = this.bullets.filter(bullet => {
            // Safety check
            if (!bullet || !bullet.mesh || !bullet.velocity) {
              return false;
            }
            bullet.mesh.position.add(bullet.velocity);
            bullet.life--;
            const damage = this.player.effects.damage.active ? CONFIG.bullet.damage * CONFIG.audio.damage.mult : CONFIG.bullet.damage;
            // Check enemy collisions
            for (let enemy of this.enemies) {
              if (!enemy || !enemy.mesh || !enemy.mesh.position || enemy.health <= 0) continue;
              try {
                if (bullet.mesh.position.distanceTo(enemy.mesh.position) < 3) {
                  const bulletDamage = bullet.isAlly ? (bullet.damage || 25) : 
                        (this.player.effects.damage.active ? CONFIG.bullet.damage * CONFIG.audio.damage.mult : CONFIG.bullet.damage);
    enemy.health -= bulletDamage;
                  enemy.attacking = true;
                  enemy.retreating = false;
                  this.audioManager.playEnemyHit();
                  if (enemy.health <= 0) {
                    this.createExplosion(enemy.mesh.position);
                    this.audioManager.playExplosion();
                    enemy.mesh.visible = false;
                    this.player.score += enemy.score;
                    this.dropArtifact(enemy.mesh.position);
                    this.updateHUD();
                  }
                  try {
                    this.scene.remove(bullet.mesh);
                  } catch (e) {
                    console.warn('Failed to remove bullet from scene:', e);
                  }
                  return false;
                }
              } catch (e) {
                console.warn('Error in bullet-enemy collision:', e);
                continue;
              }
            }
            // Check planet collisions
            for (let planet of this.planets) {
              if (!planet || !planet.center || planet.destroyed) continue;
              try {
                if (bullet.mesh.position.distanceTo(planet.center) < planet.config.radius) {
                  planet.health -= damage;
                  if (planet.health <= 0) {
                    this.destroyPlanet(planet);
                  }
                  try {
                    this.scene.remove(bullet.mesh);
                  } catch (e) {
                    console.warn('Failed to remove bullet from scene:', e);
                  }
                  return false;
                }
              } catch (e) {
                console.warn('Error in bullet-planet collision:', e);
                continue;
              }
            }
            // Check bullet lifetime
            if (bullet.life <= 0) {
              try {
                this.scene.remove(bullet.mesh);
              } catch (e) {
                console.warn('Failed to remove expired bullet:', e);
              }
              return false;
            }
            return true;
          });
        }
        // Fix 2: Replace the updateEnemyBullets() method (around line 1200)
        updateEnemyBullets() {
          this.enemyBullets = this.enemyBullets.filter(bullet => {
            // Safety check
            if (!bullet || !bullet.mesh || !bullet.velocity) {
              return false;
            }
            bullet.mesh.position.add(bullet.velocity);
            bullet.life--;
            // Check player collision only if not landing
            if (this.landingState === 'none' && this.playerShip && this.playerShip.position) {
              try {
                const distance = bullet.mesh.position.distanceTo(this.playerShip.position);
                if (distance < 3) {
                  this.player.health -= CONFIG.bullet.enemyDamage;
                  this.audioManager.playDamage();
                  this.createDamageEffect(this.playerShip.position);
                  this.updateHUD();
                  if (this.player.health <= 0) {
                    this.gameOver();
                  }
                  try {
                    this.scene.remove(bullet.mesh);
                  } catch (e) {
                    console.warn('Failed to remove enemy bullet from scene:', e);
                  }
                  return false;
                }
              } catch (e) {
                console.warn('Error in enemy bullet-player collision:', e);
              }
            }
            // Check bullet lifetime
            if (bullet.life <= 0) {
              try {
                this.scene.remove(bullet.mesh);
              } catch (e) {
                console.warn('Failed to remove expired enemy bullet:', e);
              }
              return false;
            }
            return true;
          });
        }
        updateArtifacts() {
          this.artifacts = this.artifacts.filter(artifact => {
            artifact.life--;
            artifact.mesh.position.y = 1 + Math.sin(Date.now() * 0.005 + artifact.bobOffset) * 0.5;
            artifact.mesh.rotation.y += 0.08;
            artifact.mesh.rotation.x += 0.03;
            const playerPosition = this.playerShip.position.clone();
            playerPosition.y = artifact.mesh.position.y;
            const distance = artifact.mesh.position.distanceTo(playerPosition);
            if (distance < 6) {
              this.applyArtifactEffect(artifact.type);
              this.scene.remove(artifact.mesh);
              return !1
            }
            if (artifact.life <= 0) {
              this.scene.remove(artifact.mesh);
              return !1
            }
            return !0
          })
        }
        updateMines() {
          this.mines = this.mines.filter(mine => {
            mine.life--;
            if (mine.life <= 0 && !mine.exploded) {
              this.scene.remove(mine.mesh);
              return !1
            }
            if (!mine.exploded) {
              const nearbyEnemies = this.enemies.filter(enemy => enemy.health > 0 && mine.mesh.position.distanceTo(enemy.mesh.position) < 8);
              if (nearbyEnemies.length > 0) {
                mine.exploded = !0;
                this.explodeMine(mine);
                this.scene.remove(mine.mesh);
                return !1
              }
            }
            return !mine.exploded
          })
        }
        updateCollisions() {
          if (this.collisionCooldown > 0) {
            this.collisionCooldown--;
            return
          }
          if (this.landingState !== 'none') return;
          this.enemies.forEach(enemy => {
    if (enemy.health > 0 && !enemy.isAlly && 
        enemy.mesh.position.distanceTo(this.playerShip.position) < 4) {
        this.player.health -= 5;
        this.collisionCooldown = 60;
        this.audioManager.playCollision();
        this.updateHUD();
        if (this.player.health <= 0) {
            this.gameOver();
        }
    }
});
        }
        updateBackground() {
          if (this.backgroundManager) {
            this.backgroundManager.update(this.playerShip.position.x, this.playerShip.position.z)
          }
        }
        updateMinimap() {
          if (this.minimapManager) {
            this.minimapManager.update(this.playerShip.position, this.planets, this.enemies)
          }
        }
        updateCoordinates() {
          document.getElementById('posX').textContent = Math.round(this.playerShip.position.x);
          document.getElementById('posZ').textContent = Math.round(this.playerShip.position.z)
        }
        updateEffects() {
          const currentTime = Date.now();
          let effectsText = '';
          if (this.player.effects.speed.active) {
            if (currentTime > this.player.effects.speed.endTime) {
              this.player.effects.speed.active = !1
            } else {
              const remaining = Math.ceil((this.player.effects.speed.endTime - currentTime) / 1000);
              effectsText += `SPEED BOOST: ${remaining}s
                                                                                                                  
              <br>`
            }
          }
          if (this.player.effects.damage.active) {
            if (currentTime > this.player.effects.damage.endTime) {
              this.player.effects.damage.active = !1
            } else {
              const remaining = Math.ceil((this.player.effects.damage.endTime - currentTime) / 1000);
              effectsText += `DAMAGE BOOST: ${remaining}s
                                                                                                                    
                <br>`
            }
          }
          document.getElementById('effects').innerHTML = effectsText
        }
        updateExplosions() {
          this.explosions = this.explosions.filter(explosion => {
            explosion.scale += 0.1;
            explosion.mesh.scale.setScalar(explosion.scale);
            explosion.mesh.material.opacity = Math.max(0, 0.8 - explosion.scale * 0.4);
            if (explosion.scale >= 2) {
              this.scene.remove(explosion.mesh);
              return !1
            }
            return !0
          })
        }
        checkPlanetCollision(newPosition, isPlayer = !1) {
          if (isPlayer && this.landingState === 'taking_off' && this.landingTarget) {
            for (let planet of this.planets) {
              if (planet.destroyed || planet === this.landingTarget) continue;
              const distance = newPosition.distanceTo(planet.center);
              const collisionDistance = planet.config.radius + 3;
              if (distance < collisionDistance) {
                return !0
              }
            }
            return !1
          }
          if (!this.collisionEnabled && isPlayer) {
            return !1
          }
          for (let planet of this.planets) {
            if (planet.destroyed) continue;
            if (isPlayer && this.landingTarget && planet === this.landingTarget) {
              continue
            }
            const distance = newPosition.distanceTo(planet.center);
            const collisionDistance = planet.config.radius + (isPlayer ? 3 : 2);
            if (distance < collisionDistance) {
              if (isPlayer) {
                const bounceDirection = new THREE.Vector3().subVectors(newPosition, planet.center).normalize();
                this.playerVelocity.copy(bounceDirection.multiplyScalar(0.5));
                this.player.health -= 10;
                this.createDamageEffect(this.playerShip.position);
                this.audioManager.playDamage();
                this.updateHUD();
                if (this.player.health <= 0) {
                  this.gameOver()
                }
              }
              return !0
            }
          }
          return !1
        }
        checkCameraCollision(cameraPosition) {
          for (let planet of this.planets) {
            if (planet.destroyed) continue;
            const distance = cameraPosition.distanceTo(planet.center);
            const collisionDistance = planet.config.radius + 15;
            if (distance < collisionDistance) {
              return !0
            }
          }
          return !1
        }
        adjustCameraForCollision() {
          let bestPosition = null;
          let maxDistance = 0;
          const baseDistance = 60;
          for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
            const offsetX = Math.sin(angle) * baseDistance;
            const offsetZ = Math.cos(angle) * baseDistance;
            const testPosition = new THREE.Vector3(this.playerShip.position.x + offsetX, 60, this.playerShip.position.z + offsetZ);
            if (!this.checkCameraCollision(testPosition)) {
              const distanceFromIdeal = testPosition.distanceTo(new THREE.Vector3(this.playerShip.position.x, 60, this.playerShip.position.z + baseDistance));
              if (!bestPosition || distanceFromIdeal < maxDistance) {
                bestPosition = testPosition;
                maxDistance = distanceFromIdeal
              }
            }
          }
          if (bestPosition) {
            this.camera.position.copy(bestPosition)
          } else {
            this.camera.position.set(this.playerShip.position.x, 80, this.playerShip.position.z)
          }
        }
        createArtifact(position, type) {
          const artifactGeom = new THREE.SphereGeometry(1.5, 12, 12);
          const artifactMat = new THREE.MeshBasicMaterial({
            color: CONFIG.audio[type].color,
            transparent: !0,
            opacity: 0.9
          });
          const artifact = new THREE.Mesh(artifactGeom, artifactMat);
          artifact.position.copy(position);
          artifact.position.y = 1;
          const artifactObj = {
            mesh: artifact,
            type: type,
            life: 900,
            bobOffset: Math.random() * Math.PI * 2
          };
          this.artifacts.push(artifactObj);
          this.scene.add(artifact);
          return artifactObj
        }
        dropArtifact(position) {
          const artifactTypes = ['speed', 'damage', 'health'];
          const randomType = artifactTypes[Math.floor(Math.random() * artifactTypes.length)];
          this.createArtifact(position, randomType)
        }
        applyArtifactEffect(type) {
          const artifactConfig = CONFIG.audio[type];
          const currentTime = Date.now();
          if (type === 'health') {
            this.player.health = Math.min(CONFIG.player.health, this.player.health + artifactConfig.amount)
          } else {
            this.player.effects[type].active = !0;
            this.player.effects[type].endTime = currentTime + artifactConfig.duration
          }
          this.audioManager.playWeaponSwitch();
          this.updateHUD()
        }
        createExplosion(position, size = 5) {
          const explosionGeom = new THREE.SphereGeometry(size, 16, 16);
          const explosionMat = new THREE.MeshBasicMaterial({
            color: 0xff4757,
            transparent: !0,
            opacity: 0.8
          });
          const explosion = new THREE.Mesh(explosionGeom, explosionMat);
          explosion.position.copy(position);
          this.scene.add(explosion);
          this.explosions.push({
            mesh: explosion,
            scale: 0
          })
        }
        createDamageEffect(position) {
          const damageGeom = new THREE.SphereGeometry(3, 32, 32);
          const damageMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: !0,
            opacity: 0.6
          });
          const damage = new THREE.Mesh(damageGeom, damageMat);
          damage.position.copy(position);
          this.scene.add(damage);
          this.explosions.push({
            mesh: damage,
            scale: 0
          })
        }
        destroyPlanet(planet) {
    planet.destroyed = true;
    this.createExplosion(planet.center, planet.config.radius);
    this.audioManager.playExplosion(2, planet.center, this.playerShip.position); // Updated call
    this.scene.remove(planet.mesh);
    this.player.score += 500;
    this.updateHUD();
    
    this.enemies = this.enemies.filter(enemy => {
        if (enemy.planet === planet) {
            this.scene.remove(enemy.mesh);
            return false;
        }
        return true;
    });
}
        explodeMine(mine) {
    const explosionGeom = new THREE.SphereGeometry(8, 16, 16);
    const explosionMat = new THREE.MeshBasicMaterial({ color: 0xff4757, transparent: true, opacity: 0.6 });
    const explosion = new THREE.Mesh(explosionGeom, explosionMat);
    explosion.position.copy(mine.mesh.position);
    this.scene.add(explosion);
    this.explosions.push({ mesh: explosion, scale: 0 });
    
    this.audioManager.playExplosion(1.5, mine.mesh.position, this.playerShip.position); // Updated call
    
    this.enemies.forEach(enemy => {
        if (enemy.health > 0 && explosion.position.distanceTo(enemy.mesh.position) < 8) {
            enemy.health -= 50;
            this.audioManager.playEnemyHit();
            if (enemy.health <= 0) {
                this.createExplosion(enemy.mesh.position);
                this.audioManager.playExplosion(1, enemy.mesh.position, this.playerShip.position); // Updated call
                enemy.mesh.visible = false;
                enemy.stuck = true;
                this.player.score += enemy.score;
                this.dropArtifact(enemy.mesh.position);
                this.updateHUD();
            }
        }
    });
}
        updateHUD() {
          document.getElementById('health').textContent = this.player.health;
          document.getElementById('score').textContent = this.player.score
        }
        gameOver() {
          this.gameStarted = !1;
          this.audioManager.stopLaser();
          setTimeout(() => {
            this.showGameOverScreen()
          }, 500)
        }
        showGameOverScreen() {
          const intro = document.getElementById('intro');
          const introContent = intro.innerHTML;
          intro.innerHTML = `
        
                                                                                                                                  
                  <h1>Game Over</h1>
                  <div style="font-size: 2rem; color: #feca57; margin: 20px 0; text-shadow: 0 0 15px rgba(254,202,87,0.8);">
            Final Score: ${this.player.score}
        </div>
                  <p>Your mission has ended. The galaxy remembers your courage.</p>
                  <button id="playAgainBtn">Play Again</button>
                  <button id="backToMenuBtn">Main Menu</button>
    `;
          intro.classList.remove('hidden');
          document.getElementById('playAgainBtn').addEventListener('click', () => {
            this.resetGame();
            intro.innerHTML = introContent;
            intro.classList.add('hidden');
            this.gameStarted = !0
          });
          document.getElementById('backToMenuBtn').addEventListener('click', () => {
            intro.innerHTML = introContent;
            this.resetGame()
          })
        }
        createHealingBeam(ally, target) {
    const healGeom = new THREE.BufferGeometry().setFromPoints([
        ally.mesh.position.clone().add(new THREE.Vector3(0, 0.5, 0)),
        target.position.clone().add(new THREE.Vector3(0, 0.5, 0))
    ]);
    const healMat = new THREE.LineBasicMaterial({
        color: 0x00ff88,
        transparent: true,
        opacity: 0.8
    });
    const healBeam = new THREE.Line(healGeom, healMat);
    this.scene.add(healBeam);
    
    // Remove beam after short time
    setTimeout(() => {
        this.scene.remove(healBeam);
    }, 200);
}
        resetGame() {
          this.player.health = CONFIG.player.health;
          this.player.score = 0;
          this.player.currentWeapon = 1;
          this.player.effects.speed.active = !1;
          this.player.effects.damage.active = !1;
          this.switchWeapon(1);
          this.playerShip.position.set(50, 5, 50);
          this.playerVelocity.set(0, 0, 0);
          this.collisionCooldown = 0;
          this.visitedPlanets.clear();
          this.landingState = 'none';
          this.landingTarget = null;
          this.removeLandingGlow();
          this.restorePlayerDepth();

    this.minimapManager.waypoint = null;
    this.removeWaypointIndicator();
    this.waypointReachedCooldown = 0;
this.allies.forEach(ally => this.scene.remove(ally.mesh));
this.allies = [];
          this.enemies.forEach(enemy => {
            const enemyConfig = EnemyFactory.types[enemy.type];
            enemy.health = enemyConfig.health;
            enemy.attacking = !1;
            enemy.retreating = !1;
            enemy.shootCooldown = 0;
            enemy.stuck = !1;
            enemy.mesh.visible = !0;
            enemy.angle = enemy.originalAngle;
            this.updateEnemyPosition(enemy)
          });
          this.planets.forEach(planet => {
            if (planet.destroyed) {
              planet.destroyed = !1;
              planet.health = planet.maxHealth;
              this.scene.add(planet.mesh)
            } else {
              planet.health = planet.maxHealth
            }
          });
          this.trails.forEach(trail => this.scene.remove(trail.mesh));
          this.trails = [];
          this.collisionEnabled = !0;
          this.bullets.forEach(bullet => this.scene.remove(bullet.mesh));
          this.bullets = [];
          this.enemyBullets.forEach(bullet => this.scene.remove(bullet.mesh));
          this.enemyBullets = [];
          this.artifacts.forEach(artifact => this.scene.remove(artifact.mesh));
          this.artifacts = [];
          this.mines.forEach(mine => this.scene.remove(mine.mesh));
          this.mines = [];
          this.explosions.forEach(explosion => this.scene.remove(explosion.mesh));
          this.explosions = [];
          if (this.laserBeam) {
            this.scene.remove(this.laserBeam);
            this.laserBeam = null
          }
          const dialogueSystem = document.getElementById('dialogueSystem');
          if (dialogueSystem) {
            dialogueSystem.classList.add('hidden')
          }
          const landingPrompts = document.getElementById('landingPrompts');
          if (landingPrompts) {
            landingPrompts.innerHTML = ''
          }
          this.updateHUD()
        }
        setupEventListeners() {
          document.addEventListener('keydown', (e) => {
            this.keys[e.code] = !0;
            if (e.code === 'KeyE') {
              this.startLanding()
            }
            if (e.code === 'KeyF') {
    this.spawnAlly();
}
            if (e.code.startsWith('Digit')) {
              const weaponNumber = parseInt(e.code.charAt(5));
              this.switchWeapon(weaponNumber)
            }
          });
          document.addEventListener('keyup', (e) => {
            this.keys[e.code] = !1
          });
          document.getElementById('startBtn').addEventListener('click', () => {
            this.startGame()
          });
          this.setupMobileControls();
          window.addEventListener('resize', () => {
            const aspectRatio = window.innerWidth / window.innerHeight;
            const distance = 60;
            this.camera.left = -distance * aspectRatio;
            this.camera.right = distance * aspectRatio;
            this.camera.top = distance;
            this.camera.bottom = -distance;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight)
          })
        }
        setupMobileControls() {
          const dpad = document.getElementById('dpad');
          const dpadInner = document.getElementById('dpadInner');
          const fireBtn = document.getElementById('fireBtn');
          const weaponBtn = document.getElementById('weaponBtn');
          let dpadPressed = !1;
          const updateDpad = (clientX, clientY) => {
            const rect = dpad.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const deltaX = clientX - centerX;
            const deltaY = clientY - centerY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = 40;
            if (distance <= maxDistance) {
              dpadInner.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
              this.touchControls.moveX = deltaX / maxDistance;
              this.touchControls.moveY = deltaY / maxDistance
            } else {
              const angle = Math.atan2(deltaY, deltaX);
              const limitedX = Math.cos(angle) * maxDistance;
              const limitedY = Math.sin(angle) * maxDistance;
              dpadInner.style.transform = `translate(${limitedX}px, ${limitedY}px)`;
              this.touchControls.moveX = limitedX / maxDistance;
              this.touchControls.moveY = limitedY / maxDistance
            }
          };
          const resetDpad = () => {
            dpadInner.style.transform = 'translate(0px, 0px)';
            this.touchControls.moveX = 0;
            this.touchControls.moveY = 0;
            dpadPressed = !1
          };
          dpad.addEventListener('touchstart', (e) => {
            e.preventDefault();
            dpadPressed = !0;
            const touch = e.touches[0];
            updateDpad(touch.clientX, touch.clientY)
          });
          dpad.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (dpadPressed) {
              const touch = e.touches[0];
              updateDpad(touch.clientX, touch.clientY)
            }
          });
          dpad.addEventListener('touchend', (e) => {
            e.preventDefault();
            resetDpad()
          });
          fireBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.touchControls.firing = !0
          });
          fireBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.touchControls.firing = !1
          });
          weaponBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.cycleWeapon()
          })
        }
        async startGame() {
          document.getElementById('intro').classList.add('hidden');
          await this.audioManager.start();
          this.gameStarted = !0;
          
          const asteriaPlanet = this.findPlanetByName('Asteria Prime');
if (asteriaPlanet) {
    this.minimapManager.waypoint = {
        x: asteriaPlanet.center.x,
        z: asteriaPlanet.center.z,
        planet: asteriaPlanet,
        type: 'planet'
    };
}
setTimeout(() => {
    this.showNavigationNotification('Asteria Prime');
}, 500);
        }
        animate() {
          requestAnimationFrame(() => this.animate());
          this.update();
          this.renderer.render(this.scene, this.camera)
        }
      }
      const game = new SpaceShooter();
    </script> 
    <style>body{margin:0;padding:0;background:#000;font-family:'Courier New',monospace;overflow:hidden}#gameContainer{position:relative;width:100vw;height:100vh}canvas{display:block}#intro{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(135deg,#0a0a2e,#16213e,#0f3460);display:flex;flex-direction:column;justify-content:center;align-items:center;color:#fff;z-index:1000;transition:opacity 0.5s}#intro h1{font-size:4rem;margin:0;text-shadow:0 0 20px #4facfe;background:linear-gradient(45deg,#4facfe,#00f2fe);-webkit-background-clip:text;-webkit-text-fill-color:#fff0;animation:glow 2s infinite alternate}#intro p{font-size:1.2rem;margin:20px 0;text-align:center;max-width:600px;line-height:1.6}#startBtn{padding:15px 30px;font-size:1.5rem;background:linear-gradient(45deg,#667eea,#764ba2);border:none;color:#fff;cursor:pointer;border-radius:50px;transition:all 0.3s;box-shadow:0 4px 15px rgb(0 0 0 / .3)}#startBtn:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgb(0 0 0 / .4)}#playAgainBtn,#backToMenuBtn{padding:12px 25px;font-size:1.2rem;background:linear-gradient(45deg,#667eea,#764ba2);border:none;color:#fff;cursor:pointer;border-radius:40px;transition:all 0.3s;box-shadow:0 4px 15px rgb(0 0 0 / .3);margin:10px}#playAgainBtn:hover,#backToMenuBtn:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgb(0 0 0 / .4)}#playAgainBtn{background:linear-gradient(45deg,#00ff88,#00d4aa)}#backToMenuBtn{background:linear-gradient(45deg,#ff6b6b,#ff5252)}@keyframes glow{0%{text-shadow:0 0 20px #4facfe}100%{text-shadow:0 0 30px #4facfe,0 0 40px #00f2fe}}#hud{position:absolute;top:20px;left:20px;color:#4facfe;font-size:1rem;z-index:100;text-shadow:0 0 10px rgb(79 172 254 / .8);display:flex;flex-direction:column;gap:8px}#healthHud{color:#0f8;font-weight:700}#scoreHud{color:#feca57;font-weight:700}#weaponHud{color:#ff6b6b;font-weight:700}#coordinates{color:rgb(79 172 254 / .7);font-size:.9rem}#minimap{position:absolute;top:20px;right:20px;width:120px;height:120px;border:2px solid rgb(79 172 254 / .4);border-radius:8px;background:rgb(0 0 0 / .8);backdrop-filter:blur(5px);z-index:100;transition:all 0.3s ease;cursor:pointer}#minimap.expanded{width:300px;height:300px;right:50%;top:50%;transform:translate(50%,-50%);z-index:1001}#minimapCanvas{width:100%;height:100%;border-radius:6px}#minimapToggle{position:absolute;top:-8px;right:-8px;width:20px;height:20px;background:rgb(79 172 254 / .8);color:#fff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:12px;cursor:pointer;border:1px solid rgb(79 172 254 / .6)}#minimapToggle:hover{background:rgb(79 172 254)}.hidden{opacity:0;pointer-events:none}#controls{position:absolute;bottom:20px;right:20px;color:rgb(255 255 255 / .7);font-size:.9rem;text-align:right;z-index:100}#effects{position:absolute;top:160px;left:20px;color:#feca57;font-size:.8rem;z-index:100;text-shadow:0 0 10px rgb(254 202 87 / .8)}#mobileControls{position:absolute;bottom:20px;left:20px;right:20px;display:none;z-index:200}#dpad{position:absolute;bottom:0px;left:20px;width:120px;height:120px}#dpadOuter{width:120px;height:120px;border:3px solid rgb(79 172 254 / .6);border-radius:50%;position:absolute;background:rgb(0 0 0 / .3);backdrop-filter:blur(5px)}#dpadInner{width:40px;height:40px;background:rgb(79 172 254 / .8);border-radius:50%;position:absolute;top:40px;left:40px;transition:all 0.1s ease;box-shadow:0 0 15px rgb(79 172 254 / .6)}#fireBtn{position:absolute;bottom:100px;right:0px;width:80px;height:80px;border:3px solid rgb(255 75 87 / .6);border-radius:50%;background:rgb(255 75 87 / .3);color:#fff;font-size:14px;display:flex;align-items:center;justify-content:center;user-select:none;backdrop-filter:blur(5px);box-shadow:0 0 20px rgb(255 75 87 / .4);font-weight:700}#weaponBtn{position:absolute;bottom:90px;right:0px;width:60px;height:60px;border:3px solid rgb(254 202 87 / .6);border-radius:50%;background:rgb(254 202 87 / .3);color:#fff;font-size:12px;display:flex;align-items:center;justify-content:center;user-select:none;backdrop-filter:blur(5px);box-shadow:0 0 20px rgb(254 202 87 / .4);font-weight:700}#fireBtn:active,#weaponBtn:active{transform:scale(.95)}@media(max-width:768px){#mobileControls{display:block}#controls{display:none}#intro h1{font-size:2.5rem}#intro p{font-size:1rem;padding:0 20px}#hud{font-size:.9rem}#minimap{width:100px;height:100px}#minimap.expanded{width:250px;height:250px}}#hud div{margin:2px 0;padding:2px 0}#effects div{animation:pulse 2s infinite}@keyframes pulse{0%,100%{opacity:1}50%{opacity:.7}}#dpadOuter:active{background:rgb(79 172 254 / .2)}#fireBtn:active{background:rgb(255 75 87 / .5);box-shadow:0 0 30px rgb(255 75 87 / .6)}#weaponBtn:active{background:rgb(254 202 87 / .5);box-shadow:0 0 30px rgb(254 202 87 / .6)}.fade-in{animation:fadeIn 1s ease-in}@keyframes fadeIn{from{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}@media(max-width:480px){#intro h1{font-size:2rem}#dpad{width:100px;height:100px}#dpadOuter{width:100px;height:100px}#dpadInner{width:35px;height:35px;top:32.5px;left:32.5px}#fireBtn{width:70px;height:70px;font-size:12px}#weaponBtn{width:50px;height:50px;font-size:10px}#minimap{width:80px;height:80px}#minimap.expanded{width:200px;height:200px}}*{box-sizing:border-box}canvas{image-rendering:optimizeSpeed;image-rendering:-moz-crisp-edges;image-rendering:-webkit-optimize-contrast;image-rendering:optimize-contrast}#landingPrompts{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:150}@keyframes landingPulse{0%,100%{opacity:1;transform:translateX(-50%)scale(1);box-shadow:0 0 10px rgb(0 255 136 / .6)}50%{opacity:.8;transform:translateX(-50%)scale(1.05);box-shadow:0 0 20px rgb(0 255 136 / .8)}}#dialogueSystem{position:absolute;top:0;left:0;width:100%;height:100%;background:rgb(0 0 0 / .8);display:flex;padding-top:3em;vertical-align:top;justify-content:center;align-items:flex-start;z-index:1000;backdrop-filter:blur(5px)}#dialogueBox{background:linear-gradient(135deg,#0a0a2e,#16213e);border:0 solid #104840;border-radius:15px;padding:0;max-width:90vw;width:500px;text-align:center;box-shadow:0 0 30px #003c71}#planetImage{font-size:4rem;margin-bottom:15px;border-radius:14px 14px 0 0;overflow:hidden;text-shadow:0 0 20px rgb(79 172 254 / .6)}#planetImage img{width:100%;height:auto;display:block;animation:planetZoom 18s ease-in-out infinite}@keyframes planetZoom{0%,100%{transform:scale(1)}50%{transform:scale(1.07)}}#dialogueContent h3{color:#4facfe;margin-top:0;font-size:1.5rem;text-shadow:0 0 10px rgb(79 172 254 / .8)}#dialogueOptions{margin-bottom:1em}#dialogueContent p{color:#fff;margin:20px 0;padding:0 30px;line-height:1.6em;min-height:60px;max-height:12em;text-align:left;overflow-y:scroll}@media(max-width:768px){#dialogueBox{padding:0;width:95vw;max-width:none}#dialogueSystem{padding-top:1em}#planetImage{font-size:3rem}#dialogueContent h3{font-size:1.2rem}#dialogueContent p{font-size:.9rem;min-height:50px}}.dialogue-btn{background:linear-gradient(45deg,#1e32e9,#2196F3);border:none;color:#fff;padding:12px 24px;font-size:1rem;border-radius:25px;cursor:pointer;transition:all 0.3s;margin:10px}.dialogue-btn:hover{transform:translateY(-2px);box-shadow:0 5px 15px rgb(0 0 0 / .3)}#landBtn{position:absolute;bottom:20px;right:100px;width:60px;height:60px;border:3px solid rgb(0 255 136 / .6);border-radius:50%;background:rgb(0 255 136 / .3);color:#fff;font-size:12px;display:none;align-items:center;justify-content:center;user-select:none;backdrop-filter:blur(5px);box-shadow:0 0 20px rgb(0 255 136 / .4);font-weight:700}#landingPrompts div{white-space:nowrap}@media(max-width:768px){#mobileControls #landBtn{display:flex}}</style>
  </body>
</html>