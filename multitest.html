<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Test</title>
    <style>
        body {
            margin: 0;
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #gameCanvas {
            border: 1px solid #333;
            background: #001122;
        }
        
        #ui {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 100;
        }
        
        #events {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 300px;
            height: 400px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #00f2fe;
            padding: 10px;
            overflow-y: auto;
            font-size: 12px;
        }
        
        .event {
            margin: 2px 0;
            padding: 2px;
            border-left: 2px solid #00f2fe;
            padding-left: 5px;
        }
        
        #instructions {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: #aaa;
        }
        
        button {
            background: #00f2fe;
            color: #000;
            border: none;
            padding: 5px 10px;
            margin: 2px;
            cursor: pointer;
            font-family: inherit;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>Player ID: <span id="playerId">Connecting...</span></div>
        <div>Room: <span id="roomId">lobby-test</span></div>
        <div>Connections: <span id="connectionCount">0</span></div>
        <button onclick="multiplayer.manualConnect()">Manual Connect</button>
        <button onclick="clearEvents()">Clear Events</button>
    </div>
    
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div id="events">
        <div style="color: #00f2fe; margin-bottom: 10px;">EVENTS LOG</div>
    </div>
    
    <div id="instructions">
        Use WASD or Arrow Keys to move â€¢ Open multiple tabs to test multiplayer
    </div>

    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script>
        // Simple event logger for testing
        class EventLogger {
            constructor() {
                this.eventsContainer = document.getElementById('events');
            }
            
            logSystem(message) {
                this.addEvent(message, 'system');
            }
            
            logEvent(message, type = 'system') {
                this.addEvent(message, type);
            }
            
            addEvent(message, type) {
                const event = document.createElement('div');
                event.className = 'event';
                event.innerHTML = `<span style="color: #666;">${new Date().toLocaleTimeString()}</span> ${message}`;
                this.eventsContainer.appendChild(event);
                this.eventsContainer.scrollTop = this.eventsContainer.scrollHeight;
                
                // Keep only last 50 events
                while (this.eventsContainer.children.length > 51) { // +1 for header
                    this.eventsContainer.removeChild(this.eventsContainer.children[1]);
                }
            }
        }

        // Simple player class
        class Player {
            constructor(x, y, color = '#00f2fe', isLocal = false) {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.color = color;
                this.isLocal = isLocal;
                this.size = 20;
                this.speed = 5;
                this.id = null;
            }
            
            update() {
                if (!this.isLocal) {
                    // Smooth interpolation for remote players
                    this.x += (this.targetX - this.x) * 0.15;
                    this.y += (this.targetY - this.y) * 0.15;
                }
            }
            
            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                
                // Draw ID
                if (this.id) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '12px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.id.substring(0, 8), this.x, this.y - this.size);
                }
            }
            
            moveTo(x, y) {
                if (this.isLocal) {
                    this.x = Math.max(this.size/2, Math.min(800 - this.size/2, x));
                    this.y = Math.max(this.size/2, Math.min(600 - this.size/2, y));
                } else {
                    this.targetX = x;
                    this.targetY = y;
                }
            }
        }

        // Simplified multiplayer manager based on the provided solution
        class MultiplayerManager {
            constructor() {
                this.peer = null;
                this.connections = new Map();
                this.players = new Map();
                this.roomId = this.getRoomId();
                this.myId = null;
                this.isReady = false;
                this.discoveryInterval = null;
                this.heartbeatInterval = null;
                this.connectionQueue = [];
                this.processingQueue = false;
                this.lastLogTime = 0;
                this.logThrottle = 1000;
                this.lastLogMessage = '';
                
                this.eventLogger = new EventLogger();
                this.setupPeer();
            }

            getRoomId() {
                const urlParams = new URLSearchParams(window.location.search);
                const roomParam = urlParams.get('room');
                return roomParam || 'lobby-test';
            }

            logThrottled(message) {
                const now = Date.now();
                if (message === this.lastLogMessage && now - this.lastLogTime < this.logThrottle) {
                    return;
                }
                this.lastLogMessage = message;
                this.lastLogTime = now;
                this.eventLogger.logSystem(message);
            }

            async setupPeer() {
                if (this.peer && !this.peer.destroyed) {
                    this.peer.destroy();
                }

                const uniqueId = `${this.roomId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

                this.peer = new Peer(uniqueId, {
                    debug: 0,
                    config: {
                        'iceServers': [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            {
                                urls: 'turn:global.relay.metered.ca:80',
                                username: '3193b9b660a19a308918301b',
                                credential: 'G3FEKpAfkkGyFNhn'
                            }
                        ]
                    }
                });

                this.peer.on('open', (id) => {
                    this.myId = id;
                    this.isReady = true;
                    this.logThrottled(`ðŸ”— Connected with ID: ${id.substring(0, 8)}...`);
                    document.getElementById('playerId').textContent = id.substring(0, 8);
                    document.getElementById('roomId').textContent = this.roomId;
                    
                    this.clearStaleRoomData();
                    setTimeout(() => {
                        this.startRoomManagement();
                        this.startHeartbeat();
                    }, 2000);
                });

                this.peer.on('connection', (conn) => {
                    this.logThrottled(`ðŸ“ž Incoming connection from ${conn.peer.substring(0, 8)}`);
                    this.handleConnection(conn);
                });

                this.peer.on('error', (err) => {
                    if (err.type === 'peer-unavailable') {
                        this.logThrottled(`âŒ Peer unavailable - cleaning stale data`);
                        this.clearStaleRoomData();
                        return;
                    }
                    
                    this.logThrottled(`âš ï¸ PeerJS Error: ${err.type || err.message}`);
                    
                    if (err.type === 'network' || err.type === 'server-error') {
                        setTimeout(() => this.setupPeer(), 5000);
                    }
                });
            }

            clearStaleRoomData() {
                const roomKey = `mp_room_${this.roomId}`;
                const presenceKey = `mp_presence_${this.roomId}`;
                localStorage.removeItem(roomKey);
                localStorage.removeItem(presenceKey);
                this.connectionQueue = [];
                this.logThrottled(`ðŸ§¹ Cleared stale room data`);
            }

            startRoomManagement() {
                if (!this.isReady) return;
                
                this.updateRoomPresence();
                this.logThrottled(`ðŸ” Starting player discovery...`);
                
                this.discoveryInterval = setInterval(() => {
                    this.discoverPeers();
                }, 8000);
                
                this.processConnectionQueue();
            }

            updateRoomPresence() {
                const roomKey = `mp_room_${this.roomId}`;
                const presenceKey = `mp_presence_${this.roomId}`;
                const now = Date.now();
                
                const roomData = JSON.parse(localStorage.getItem(roomKey) || '{}');
                const presenceData = JSON.parse(localStorage.getItem(presenceKey) || '{}');
                
                // Clean up old entries
                const cutoffTime = now - 120000;
                Object.keys(presenceData).forEach(id => {
                    if (presenceData[id] < cutoffTime) {
                        delete presenceData[id];
                        delete roomData[id];
                    }
                });
                
                roomData[this.myId] = { id: this.myId, joinedAt: now, lastSeen: now };
                presenceData[this.myId] = now;
                
                localStorage.setItem(roomKey, JSON.stringify(roomData));
                localStorage.setItem(presenceKey, JSON.stringify(presenceData));
            }

            async discoverPeers() {
                if (!this.isReady) return;
                
                this.updateRoomPresence();
                
                const roomKey = `mp_room_${this.roomId}`;
                const roomData = JSON.parse(localStorage.getItem(roomKey) || '{}');
                
                const otherPlayers = Object.keys(roomData).filter(id => 
                    id !== this.myId && !this.connections.has(id)
                );
                
                if (otherPlayers.length > 0) {
                    this.logThrottled(`ðŸ‘¥ Found ${otherPlayers.length} potential players`);
                    otherPlayers.forEach(peerId => {
                        if (!this.connectionQueue.includes(peerId)) {
                            this.connectionQueue.push(peerId);
                        }
                    });
                    this.processConnectionQueue();
                } else {
                    if (Date.now() % 30000 < 8000) {
                        this.logThrottled(`ðŸ” Looking for other players...`);
                    }
                }
            }

            async processConnectionQueue() {
                if (this.processingQueue || this.connectionQueue.length === 0) return;
                
                this.processingQueue = true;
                
                while (this.connectionQueue.length > 0) {
                    const peerId = this.connectionQueue.shift();
                    
                    if (!this.connections.has(peerId) && peerId !== this.myId) {
                        this.logThrottled(`ðŸ”„ Attempting connection to ${peerId.substring(0, 8)}`);
                        
                        try {
                            await this.connectToPeerWithValidation(peerId);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                        } catch (err) {
                            console.warn('Connection failed:', err);
                        }
                    }
                }
                
                this.processingQueue = false;
            }

            async connectToPeerWithValidation(peerId) {
                return new Promise((resolve, reject) => {
                    const conn = this.peer.connect(peerId, {
                        reliable: true,
                        serialization: 'json',
                        metadata: { roomId: this.roomId, timestamp: Date.now() }
                    });

                    const timeout = setTimeout(() => {
                        this.logThrottled(`â° Timeout with ${peerId.substring(0, 8)} - peer unavailable`);
                        conn.close();
                        this.removePeerFromRoom(peerId);
                        reject(new Error('Connection timeout'));
                    }, 12000);

                    conn.on('open', () => {
                        clearTimeout(timeout);
                        this.logThrottled(`âœ… Successfully connected to ${peerId.substring(0, 8)}`);
                        resolve();
                    });

                    conn.on('error', (err) => {
                        clearTimeout(timeout);
                        if (err.type === 'peer-unavailable') {
                            this.logThrottled(`âŒ Peer ${peerId.substring(0, 8)} unavailable - removing`);
                            this.removePeerFromRoom(peerId);
                        }
                        reject(err);
                    });

                    this.handleConnection(conn);
                });
            }

            removePeerFromRoom(peerId) {
                const roomKey = `mp_room_${this.roomId}`;
                const presenceKey = `mp_presence_${this.roomId}`;
                
                const roomData = JSON.parse(localStorage.getItem(roomKey) || '{}');
                const presenceData = JSON.parse(localStorage.getItem(presenceKey) || '{}');
                
                delete roomData[peerId];
                delete presenceData[peerId];
                
                localStorage.setItem(roomKey, JSON.stringify(roomData));
                localStorage.setItem(presenceKey, JSON.stringify(presenceData));
            }

            handleConnection(conn) {
                const peerId = conn.peer;
                
                conn.on('open', () => {
                    this.connections.set(peerId, conn);
                    this.logThrottled(`ðŸŽ‰ ${peerId.substring(0, 8)} connected`);
                    document.getElementById('connectionCount').textContent = this.connections.size;
                    
                    setTimeout(() => {
                        this.sendToPlayer(peerId, {
                            type: 'player_join',
                            player: this.getMyPlayerData()
                        });
                    }, 200);
                });

                conn.on('data', (data) => {
                    this.handleMessage(peerId, data);
                });

                conn.on('close', () => {
                    this.logThrottled(`ðŸ”Œ ${peerId.substring(0, 8)} disconnected`);
                    this.handlePlayerLeave(peerId);
                });

                conn.on('error', (err) => {
                    this.logThrottled(`âš ï¸ Error with ${peerId.substring(0, 8)}: ${err.type}`);
                    this.handlePlayerLeave(peerId);
                });
            }

            handleMessage(fromPeer, data) {
                if (!data || typeof data !== 'object') return;

                switch (data.type) {
                    case 'player_join':
                        this.handlePlayerJoin(fromPeer, data.player);
                        break;
                    case 'player_update':
                        this.handlePlayerUpdate(fromPeer, data.player);
                        break;
                    case 'player_leave':
                        this.handlePlayerLeave(fromPeer);
                        break;
                }
            }

            handlePlayerJoin(peerId, playerData) {
                if (!playerData) return;

                this.logThrottled(`ðŸš€ ${peerId.substring(0, 8)} joined the game`);
                
                // Add remote player to game
                game.addRemotePlayer(peerId, playerData);

                setTimeout(() => {
                    this.sendToPlayer(peerId, {
                        type: 'player_join',
                        player: this.getMyPlayerData()
                    });
                }, 300);
            }

            handlePlayerUpdate(peerId, playerData) {
                if (game.remotePlayers.has(peerId)) {
                    const player = game.remotePlayers.get(peerId);
                    player.moveTo(playerData.x, playerData.y);
                }
            }

            handlePlayerLeave(peerId) {
                this.connections.delete(peerId);
                this.removePeerFromRoom(peerId);
                game.removeRemotePlayer(peerId);
                this.logThrottled(`ðŸ‘‹ ${peerId.substring(0, 8)} left the game`);
                document.getElementById('connectionCount').textContent = this.connections.size;
            }

            getMyPlayerData() {
                return {
                    id: this.myId,
                    x: game.localPlayer.x,
                    y: game.localPlayer.y
                };
            }

            startHeartbeat() {
                this.heartbeatInterval = setInterval(() => {
                    this.updateRoomPresence();
                    
                    if (Date.now() % 15000 < 5000) {
                        if (this.connections.size > 0) {
                            this.logThrottled(`ðŸ“Š ${this.connections.size + 1} players connected`);
                        }
                    }
                }, 5000);
            }

            broadcastPlayerUpdate() {
                const playerData = this.getMyPlayerData();
                this.broadcast({
                    type: 'player_update',
                    player: playerData
                });
            }

            broadcast(message) {
                this.connections.forEach((conn, peerId) => {
                    if (conn.open) {
                        try {
                            conn.send(message);
                        } catch (err) {
                            console.warn('Failed to send to peer:', peerId);
                        }
                    }
                });
            }

            sendToPlayer(peerId, message) {
                const conn = this.connections.get(peerId);
                if (conn && conn.open) {
                    try {
                        conn.send(message);
                        return true;
                    } catch (err) {
                        return false;
                    }
                }
                return false;
            }

            manualConnect() {
                if (!this.myId) {
                    alert('Not connected yet. Wait a moment and try again.');
                    return;
                }

                const peerId = prompt(`Your ID: ${this.myId}\n\nEnter other player's ID:`);
                
                if (peerId && peerId !== this.myId && peerId.length > 5) {
                    this.logThrottled(`ðŸ”§ Manual connection to ${peerId.substring(0, 8)}...`);
                    this.connectionQueue.push(peerId);
                    this.processConnectionQueue();
                }
            }
        }

        // Simple game class
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.localPlayer = new Player(400, 300, '#00f2fe', true);
                this.remotePlayers = new Map();
                this.keys = {};
                
                this.setupInput();
                this.gameLoop();
            }
            
            setupInput() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
            }
            
            update() {
                let moved = false;
                const oldX = this.localPlayer.x;
                const oldY = this.localPlayer.y;
                
                if (this.keys.KeyW || this.keys.ArrowUp) {
                    this.localPlayer.moveTo(this.localPlayer.x, this.localPlayer.y - this.localPlayer.speed);
                    moved = true;
                }
                if (this.keys.KeyS || this.keys.ArrowDown) {
                    this.localPlayer.moveTo(this.localPlayer.x, this.localPlayer.y + this.localPlayer.speed);
                    moved = true;
                }
                if (this.keys.KeyA || this.keys.ArrowLeft) {
                    this.localPlayer.moveTo(this.localPlayer.x - this.localPlayer.speed, this.localPlayer.y);
                    moved = true;
                }
                if (this.keys.KeyD || this.keys.ArrowRight) {
                    this.localPlayer.moveTo(this.localPlayer.x + this.localPlayer.speed, this.localPlayer.y);
                    moved = true;
                }
                
                // Broadcast position if moved
                if (moved && multiplayer && multiplayer.connections.size > 0) {
                    multiplayer.broadcastPlayerUpdate();
                }
                
                // Update remote players
                this.remotePlayers.forEach(player => player.update());
            }
            
            render() {
                this.ctx.fillStyle = '#001122';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw local player
                this.localPlayer.draw(this.ctx);
                
                // Draw remote players
                this.remotePlayers.forEach(player => player.draw(this.ctx));
            }
            
            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
            
            addRemotePlayer(peerId, playerData) {
                const colors = ['#ff4757', '#2ed573', '#feca57', '#ff9ff3', '#54a0ff'];
                const color = colors[this.remotePlayers.size % colors.length];
                
                const player = new Player(playerData.x, playerData.y, color, false);
                player.id = peerId;
                this.remotePlayers.set(peerId, player);
            }
            
            removeRemotePlayer(peerId) {
                this.remotePlayers.delete(peerId);
            }
        }

        // Initialize everything
        const game = new Game();
        const multiplayer = new MultiplayerManager();

        // Helper function for testing
        function clearEvents() {
            const events = document.getElementById('events');
            events.innerHTML = '<div style="color: #00f2fe; margin-bottom: 10px;">EVENTS LOG</div>';
        }
    </script>
</body>
</html>
