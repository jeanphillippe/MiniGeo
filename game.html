<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimized Isometric Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #2c3e50; overflow: hidden; }
        #gameCanvas { display: block; width: 100vw; height: 100vh; touch-action: none; cursor: grab; }
        #gameCanvas:active { cursor: grabbing; }
        
        .ui-container { position: absolute; top: 10px; left: 10px; z-index: 100; }
        .toggle-btn { background: rgba(0,0,0,0.8); color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-bottom: 5px; }
        .toggle-btn:hover { background: rgba(0,0,0,0.9); }
        .toggle-btn.active { background: #4CAF50; }
        
        .panel { color: white; background: rgba(0,0,0,0.8); padding: 12px; border-radius: 6px; font-size: 12px; margin-bottom: 5px; min-width: 200px; display: none; }
        .panel.visible { display: block; }
        .panel button { background: #4CAF50; color: white; border: none; padding: 6px 12px; border-radius: 3px; cursor: pointer; font-size: 11px; margin: 2px; }
        .panel button:hover { background: #45a049; }
        .panel button.active { background: #ff6b6b; }
        .panel button:disabled { background: #666; cursor: not-allowed; }
        
        .edit-indicator { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #ff6b6b; font-size: 16px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); z-index: 99; pointer-events: none; display: none; }
        .edit-indicator.visible { display: block; }
        
        .controls-text { font-size: 10px; color: #ccc; margin-top: 8px; line-height: 1.3; }
        
        @media (max-width: 768px) { 
            .panel { font-size: 10px; padding: 10px; min-width: 180px; } 
            .toggle-btn { font-size: 11px; padding: 6px 10px; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui-container">
        <button id="debugToggle" class="toggle-btn">Debug Info</button>
        <button id="editToggle" class="toggle-btn">Edit Mode</button>
        
        <div id="debugPanel" class="panel">
            <div><strong>Debug Info</strong></div>
            <div>FPS: <span id="fps">60</span></div>
            <div>Camera: <span id="cameraPos">0, 0, 0</span></div>
            <div>Zoom: <span id="zoomLevel">1.0</span></div>
            <div>Status: <span id="status">Initializing...</span></div>
            <div class="controls-text">
                <div><strong>Desktop:</strong> WASD/Arrows=Move | Wheel=Zoom | Drag=Pan</div>
                <div><strong>Mobile:</strong> Drag=Pan | Pinch=Zoom | Tap=Select</div>
            </div>
        </div>
        
        <div id="editPanel" class="panel">
            <div><strong>Tile Editor</strong></div>
            <div style="margin: 8px 0;">
                Selected: <span id="selectedTile">None</span> | Height: <span id="selectedHeight">-</span>
            </div>
            <div>
                <button id="raiseBtn" disabled>Raise (+)</button>
                <button id="lowerBtn" disabled>Lower (-)</button>
                <button id="undoBtn" disabled>Undo</button>
                <button id="clearBtn">Clear</button>
            </div>
            <div class="controls-text">Click tiles to select | Shift+Click=Lower | Ctrl+Click=Reset</div>
        </div>
    </div>
    
    <div id="editIndicator" class="edit-indicator">EDIT MODE ACTIVE</div>

    <script>
        class GameEngine {
            constructor() {
                this.scene = null; this.camera = null; this.renderer = null; this.canvas = null; this.terrain = null;
                this.gridSize = 16; this.tileSize = 2; this.heightLevels = 8;
                this.cameraTarget = new THREE.Vector3(0, 0, 0); this.cameraOffset = new THREE.Vector3(10, 10, 10); this.zoomLevel = 1.0; this.minZoom = 0.3; this.maxZoom = 3.0;
                this.editMode = false; this.selectedTile = null; this.raycaster = new THREE.Raycaster(); this.mouse = new THREE.Vector2(); this.editHistory = []; this.maxHistorySize = 20;
                this.input = { keys: {}, mouse: { x: 0, y: 0, pressed: false }, touch: { active: false, start: null, current: null, pinchDistance: 0 } };
                this.frameCount = 0; this.lastFpsUpdate = 0; this.currentFps = 60; this.isRunning = false; this.cloudSprites = [];
                this.init();
            }

            init() {
                this.setupRenderer(); this.setupCamera(); this.setupScene(); this.setupLighting(); this.setupClouds(); this.setupTerrain(); this.setupInput(); this.setupUI();this.player = new Player(this); this.start(); this.updateDebugInfo();
            }

            setupRenderer() {
                this.canvas = document.getElementById('gameCanvas');
                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true, alpha: false, powerPreference: "high-performance" });
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x4FB3D9, 1); this.renderer.shadowMap.enabled = true; this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            }

            setupCamera() {
                const aspect = window.innerWidth / window.innerHeight, frustumSize = 20;
                this.camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, -100, 1000);
                this.updateCameraPosition();
            }

            setupScene() { this.scene = new THREE.Scene(); this.scene.fog = new THREE.Fog(0x4FB3D9, 30, 100); }

            setupLighting() {
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.4));
                const light = new THREE.DirectionalLight(0xfff6e0, 0.95);
                light.position.set(50, 50, 25); light.castShadow = true;
                light.shadow.mapSize.width = light.shadow.mapSize.height = 2048;
                Object.assign(light.shadow.camera, { near: 0.1, far: 200, left: -50, right: 50, top: 50, bottom: -50 });
                this.scene.add(light);
            }

            setupClouds() {
                const loader = new THREE.TextureLoader();
                loader.load('https://i.imgur.com/mYRt74O.png', texture => {
    for (let i = 0; i < 6; i++) {
        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
            map: texture,
            color: 0xffffff,
            opacity: 0.7,
            transparent: true,
            depthWrite: false
        }));
        sprite.position.set(
            (Math.random() - 0.5) * this.gridSize * this.tileSize,
            8 + Math.random() * 2,
            (Math.random() - 0.5) * this.gridSize * this.tileSize
        );
        sprite.scale.set(8 + Math.random() * 6, 4 + Math.random() * 2, 1);
        sprite.frustumCulled = false;
        // Assign a constant speed to each cloud
        sprite.userData.speed = 0.01 * (0.5 + Math.random() * 0.2);

        this.scene.add(sprite);
        this.cloudSprites.push(sprite);
    }
});

            }

            setupTerrain() { this.terrain = new TerrainSystem(this.gridSize, this.tileSize, this.heightLevels); this.terrain.generateTerrain(); this.scene.add(this.terrain.terrainGroup); }

            setupInput() {
                ['keydown', 'keyup'].forEach(evt => document.addEventListener(evt, e => this.input.keys[e.code] = evt === 'keydown'));
                ['mousedown', 'mousemove', 'mouseup'].forEach(evt => this.canvas.addEventListener(evt, e => this.handleMouse(evt, e)));
                this.canvas.addEventListener('click', e => this.editMode && this.handleTileClick(e));
                this.canvas.addEventListener('wheel', e => { e.preventDefault(); this.zoomCamera(e.deltaY > 0 ? 0.1 : -0.1); });
                ['touchstart', 'touchmove', 'touchend'].forEach(evt => this.canvas.addEventListener(evt, e => { e.preventDefault(); this[`handleTouch${evt.slice(5)}`](e); }));
                window.addEventListener('resize', () => this.handleResize());
            }

            setupUI() {
                document.getElementById('debugToggle').addEventListener('click', () => this.togglePanel('debug'));
                document.getElementById('editToggle').addEventListener('click', () => this.togglePanel('edit'));
                
                const btns = { 
                    raiseBtn: () => this.modifySelected(1), 
                    lowerBtn: () => this.modifySelected(-1), 
                    undoBtn: () => this.undoLastEdit(), 
                    clearBtn: () => confirm('Clear all terrain?') && this.clearTerrain() 
                };
                Object.keys(btns).forEach(id => document.getElementById(id).addEventListener('click', btns[id]));
            }

            togglePanel(type) {
                if (type === 'debug') {
                    const panel = document.getElementById('debugPanel'), btn = document.getElementById('debugToggle');
                    const isVisible = panel.classList.contains('visible');
                    panel.classList.toggle('visible', !isVisible); btn.classList.toggle('active', !isVisible);
                } else if (type === 'edit') {
                    this.editMode = !this.editMode;
                    const panel = document.getElementById('editPanel'), btn = document.getElementById('editToggle'), ind = document.getElementById('editIndicator');
                    panel.classList.toggle('visible', this.editMode); btn.classList.toggle('active', this.editMode); ind.classList.toggle('visible', this.editMode);
                    this.canvas.style.cursor = this.editMode ? 'crosshair' : 'grab';
                    !this.editMode && this.clearSelection();
                }
            }

            handleMouse(evt, e) {
                const m = this.input.mouse;
                if (evt === 'mousedown') { m.pressed = true; m.x = e.clientX; m.y = e.clientY; }
                else if (evt === 'mousemove' && m.pressed && !this.editMode) this.panCamera(e.clientX - m.x, e.clientY - m.y);
                else if (evt === 'mouseup') m.pressed = false;
                if (evt !== 'mouseup') { m.x = e.clientX; m.y = e.clientY; }
            }

            handleTileClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                this.mouse.set(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.terrain.terrainGroup.children);
                if (intersects.length) {
                    const tile = intersects[0].object.userData;
                    this.selectTile(tile.x, tile.z);
                    if (e.shiftKey) this.modifyTileHeight(tile.x, tile.z, -1);
                    else if (e.ctrlKey || e.metaKey) this.setTileHeight(tile.x, tile.z, 0);
                    else this.modifyTileHeight(tile.x, tile.z, 1);
                }
            }

            selectTile(x, z) {
                const tile = this.terrain.getTile(x, z);
                if (tile) { this.selectedTile = { x, z, height: tile.height }; this.updateEditUI(); this.highlightTile(tile.mesh); }
            }

            clearSelection() { this.selectedTile = null; this.updateEditUI(); this.removeHighlight(); }

            highlightTile(mesh) {
                this.removeHighlight();
                const edges = new THREE.EdgesGeometry(mesh.geometry);
                this.tileHighlight = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 3 }));
                this.tileHighlight.position.copy(mesh.position); this.tileHighlight.position.y += 0.01; this.scene.add(this.tileHighlight);
            }

            removeHighlight() {
                if (this.tileHighlight) { this.scene.remove(this.tileHighlight); this.tileHighlight.geometry.dispose(); this.tileHighlight.material.dispose(); this.tileHighlight = null; }
            }

            modifySelected(delta) { this.selectedTile && this.modifyTileHeight(this.selectedTile.x, this.selectedTile.z, delta); }

            modifyTileHeight(x, z, delta) {
                const tile = this.terrain.getTile(x, z);
                if (tile) {
                    const newHeight = Math.max(0, Math.min(this.heightLevels - 1, tile.height + delta));
                    if (newHeight !== tile.height) {
                        this.addToHistory(x, z, tile.height, newHeight); this.terrain.updateTileHeight(x, z, newHeight);
                        if (this.selectedTile?.x === x && this.selectedTile?.z === z) { this.selectedTile.height = newHeight; this.updateEditUI(); this.highlightTile(tile.mesh); }
                    }
                }
            }

            setTileHeight(x, z, height) {
                const tile = this.terrain.getTile(x, z);
                if (tile && tile.height !== height) {
                    this.addToHistory(x, z, tile.height, height); this.terrain.updateTileHeight(x, z, height);
                    if (this.selectedTile?.x === x && this.selectedTile?.z === z) { this.selectedTile.height = height; this.updateEditUI(); this.highlightTile(tile.mesh); }
                }
            }

            addToHistory(x, z, oldHeight, newHeight) {
                this.editHistory.push({ x, z, oldHeight, newHeight });
                if (this.editHistory.length > this.maxHistorySize) this.editHistory.shift();
                document.getElementById('undoBtn').disabled = false;
            }

            undoLastEdit() {
                if (this.editHistory.length) {
                    const action = this.editHistory.pop();
                    this.terrain.updateTileHeight(action.x, action.z, action.oldHeight);
                    if (this.selectedTile?.x === action.x && this.selectedTile?.z === action.z) { this.selectedTile.height = action.oldHeight; this.updateEditUI(); this.highlightTile(this.terrain.getTile(action.x, action.z).mesh); }
                    document.getElementById('undoBtn').disabled = !this.editHistory.length;
                }
            }

            clearTerrain() {
                this.editHistory = [];
                for (let x = 0; x < this.gridSize; x++) for (let z = 0; z < this.gridSize; z++) this.terrain.updateTileHeight(x, z, 2);
                this.clearSelection(); document.getElementById('undoBtn').disabled = true;
            }

            updateEditUI() {
                const elems = ['selectedTile', 'selectedHeight', 'raiseBtn', 'lowerBtn'].map(id => document.getElementById(id));
                if (this.selectedTile) {
                    elems[0].textContent = `${this.selectedTile.x},${this.selectedTile.z}`; elems[1].textContent = this.selectedTile.height;
                    const atMax = this.selectedTile.height >= this.heightLevels - 1, atMin = this.selectedTile.height <= 0;
                    elems[2].disabled = !this.editMode || atMax; elems[3].disabled = !this.editMode || atMin;
                } else {
                    elems[0].textContent = 'None'; elems[1].textContent = '-';
                    elems.slice(2).forEach(btn => btn.disabled = true);
                }
            }

            handleTouchStart(e) {
                const touches = e.touches;
                if (touches.length === 1) {
                    this.input.touch.active = true; this.input.touch.moved = false;
                    this.input.touch.start = this.input.touch.current = { x: touches[0].clientX, y: touches[0].clientY };
                } else if (touches.length === 2) {
                    this.input.touch.pinchDistance = this.getTouchDistance(touches[0], touches[1]); this.input.touch.moved = false;
                }
            }

            handleTouchMove(e) {
                const touches = e.touches;
                if (touches.length === 1 && this.input.touch.active) {
                    const delta = { x: touches[0].clientX - this.input.touch.current.x, y: touches[0].clientY - this.input.touch.current.y };
                    const dist = Math.sqrt(delta.x * delta.x + delta.y * delta.y);
                    if (dist > 5) { this.input.touch.moved = true; !this.editMode && this.panCamera(delta.x, delta.y); }
                    this.input.touch.current = { x: touches[0].clientX, y: touches[0].clientY };
                } else if (touches.length === 2) {
                    const currentDist = this.getTouchDistance(touches[0], touches[1]);
                    this.zoomCamera((this.input.touch.pinchDistance - currentDist) * 0.01);
                    this.input.touch.pinchDistance = currentDist; this.input.touch.moved = true;
                }
            }

            handleTouchEnd(e) {
                const wasTap = this.input.touch.active && !this.input.touch.moved && e.changedTouches.length === 1;
                if (wasTap && this.editMode) {
                    const touch = e.changedTouches[0];
                    this.handleTileClick({ clientX: touch.clientX, clientY: touch.clientY, shiftKey: false, ctrlKey: false, metaKey: false });
                }
                Object.assign(this.input.touch, { active: false, start: null, current: null, moved: false });
            }

            getTouchDistance(t1, t2) { const dx = t1.clientX - t2.clientX, dy = t1.clientY - t2.clientY; return Math.sqrt(dx * dx + dy * dy); }

            panCamera(deltaX, deltaY) {
    const speed = 0.02 * this.zoomLevel;

    // Match isometric movement
    const moveX = new THREE.Vector3(1, 0, -1).normalize();  // right in isometric
    const moveY = new THREE.Vector3(1, 0, 1).normalize();   // down in isometric

    this.cameraTarget.add(moveX.clone().multiplyScalar(-deltaX * speed));
    this.cameraTarget.add(moveY.clone().multiplyScalar(deltaY * speed));

    const maxBounds = this.gridSize * this.tileSize / 2;
    this.cameraTarget.x = Math.max(-maxBounds, Math.min(maxBounds, this.cameraTarget.x));
    this.cameraTarget.z = Math.max(-maxBounds, Math.min(maxBounds, this.cameraTarget.z));
}


            zoomCamera(delta) {
                this.zoomLevel = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoomLevel + delta));
                const aspect = window.innerWidth / window.innerHeight, frustumSize = 20 * this.zoomLevel;
                Object.assign(this.camera, { left: frustumSize * aspect / -2, right: frustumSize * aspect / 2, top: frustumSize / 2, bottom: frustumSize / -2 });
                this.camera.updateProjectionMatrix();
            }

            updateCameraPosition() { this.camera.position.copy(this.cameraTarget.clone().add(this.cameraOffset)); this.camera.lookAt(this.cameraTarget); }

            handleKeyboardInput() {
                const speed = 0.3, keys = this.input.keys;
                const direction = new THREE.Vector3();

if (keys['KeyW'] || keys['ArrowUp']) direction.add(new THREE.Vector3(-1, 0, -1)); // up
if (keys['KeyS'] || keys['ArrowDown']) direction.add(new THREE.Vector3(1, 0, 1));  // down
if (keys['KeyA'] || keys['ArrowLeft']) direction.add(new THREE.Vector3(-1, 0, 1)); // left
if (keys['KeyD'] || keys['ArrowRight']) direction.add(new THREE.Vector3(1, 0, -1)); // right

if (direction.lengthSq() > 0) {
    direction.normalize().multiplyScalar(speed);
    this.cameraTarget.add(direction);
}

                if (keys['KeyQ']) this.zoomCamera(0.02); if (keys['KeyE']) this.zoomCamera(-0.02);
                const maxBounds = this.gridSize * this.tileSize / 2;
                this.cameraTarget.x = Math.max(-maxBounds, Math.min(maxBounds, this.cameraTarget.x));
                this.cameraTarget.z = Math.max(-maxBounds, Math.min(maxBounds, this.cameraTarget.z));
            }

            handleResize() {
                const aspect = window.innerWidth / window.innerHeight, frustumSize = 20 * this.zoomLevel;
                Object.assign(this.camera, { left: frustumSize * aspect / -2, right: frustumSize * aspect / 2, top: frustumSize / 2, bottom: frustumSize / -2 });
                this.camera.updateProjectionMatrix(); this.renderer.setSize(window.innerWidth, window.innerHeight); this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            }

            start() { this.isRunning = true; this.animate(); document.getElementById('status').textContent = 'Running'; }

            animate() { if (!this.isRunning) return; requestAnimationFrame(() => this.animate()); this.update(); this.render(); this.updatePerformanceStats(); }

            update() {
                this.handleKeyboardInput(); this.updateCameraPosition();
                this.cloudSprites.forEach(c => {
    c.position.x += c.userData.speed;
    if (c.position.x > this.gridSize * this.tileSize)
        c.position.x = -this.gridSize * this.tileSize;
});

                if (this.selectedTile && this.tileHighlight) {
                    const tile = this.terrain.getTile(this.selectedTile.x, this.selectedTile.z);
                    if (tile) { this.tileHighlight.position.copy(tile.mesh.position); this.tileHighlight.position.y += 0.01; }
                }
                if (this.player) this.player.update();

            }

            render() { this.renderer.render(this.scene, this.camera); }

            updatePerformanceStats() {
                this.frameCount++;
                const now = performance.now();
                if (now - this.lastFpsUpdate >= 1000) {
                    this.currentFps = Math.round((this.frameCount * 1000) / (now - this.lastFpsUpdate));
                    this.frameCount = 0; this.lastFpsUpdate = now; document.getElementById('fps').textContent = this.currentFps;
                }
            }

            updateDebugInfo() {
                const update = () => {
                    if (!this.isRunning) return;
                    const pos = this.cameraTarget;
                    document.getElementById('cameraPos').textContent = `${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}`;
                    document.getElementById('zoomLevel').textContent = this.zoomLevel.toFixed(1);
                    requestAnimationFrame(update);
                };
                update();
            }
        }
class Player {
    constructor(game) {
        this.game = game;
        this.speed = 0.05;
        this.path = [];
    this._vA = new THREE.Vector3();
    this._vB = new THREE.Vector3();
        this.progress = 0;
        this.model = new THREE.Mesh(
            new THREE.CylinderGeometry(0.3, 0.3, 1, 6),
            new THREE.MeshStandardMaterial({ color: 0xffcc00 })
        );

        this.model.castShadow = true;
        this.game.scene.add(this.model);
        this.pos = { x: 8, z: 8 };
        this.setPosition(this.pos.x, this.pos.z);
        this.initInput();
    }

    setPosition(x, z) {
    const tile = this.game.terrain.getTile(x, z);
    if (!tile) return;
    const meshPos = tile.mesh.position;
    const height = 0.5 + tile.height * 0.5; // tile height from mesh calculation
    this.model.position.set(meshPos.x, height, meshPos.z);
    this.pos = { x, z };
}


    initInput() {
        this.game.canvas.addEventListener('click', e => {
    if (this.game.editMode) return;
    const rect = this.game.canvas.getBoundingClientRect();
    this.game.mouse.set(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
    this.game.raycaster.setFromCamera(this.game.mouse, this.game.camera);
    const hits = this.game.raycaster.intersectObjects(this.game.terrain.terrainGroup.children);
    if (hits.length) {
        const { x, z } = hits[0].object.userData;
        this.findPath(this.pos, { x, z }, (path) => {
            this.path = path;
            this.progress = 0;
        });
    }
});

    }

    update() {
    if (!this.path.length) return;

    const next = this.path[0];
    const currentTile = this.game.terrain.getTile(this.pos.x, this.pos.z);
    const nextTile = this.game.terrain.getTile(next.x, next.z);
    if (!nextTile || !currentTile) { this.path = []; return; }

    if (this.progress === 0) {
        const a = currentTile.mesh.position;
        const b = nextTile.mesh.position;
        const yA = 0.5 + currentTile.height * 0.5;
        const yB = 0.5 + nextTile.height * 0.5;

        this._vA.set(a.x, yA, a.z);
        this._vB.set(b.x, yB, b.z);
    }

    this.progress += this.speed;

    if (this.progress >= 1) {
        this.setPosition(next.x, next.z);
        this.path.shift();
        this.progress = 0;
    } else {
        this.model.position.lerpVectors(this._vA, this._vB, this.progress);
        this.model.position.y += Math.sin(this.progress * Math.PI) * 0.5;  // bobbing animation
    }
}


    findPath(start, end, callback) {
    setTimeout(() => {
        const grid = this.game.terrain.tiles.map(row => row.map(t => t.height < this.game.heightLevels));
        const open = [start], cameFrom = {}, g = { [`${start.x},${start.z}`]: 0 };
        const h = (a, b) => Math.abs(a.x - b.x) + Math.abs(a.z - b.z);
        while (open.length) {
            open.sort((a, b) => (g[`${a.x},${a.z}`] + h(a, end)) - (g[`${b.x},${b.z}`] + h(b, end)));
            const current = open.shift();
            if (current.x === end.x && current.z === end.z) break;
            for (let d of [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]) {
                const nx = current.x + d[0], nz = current.z + d[1];
                const key = `${nx},${nz}`;
                if (!grid[nx]?.[nz]) continue;
                const tile = this.game.terrain.getTile(nx, nz);
                if (!tile) continue;
                const cost = g[`${current.x},${current.z}`] + 1;
                if (!(key in g) || cost < g[key]) {
                    g[key] = cost;
                    cameFrom[key] = current;
                    open.push({ x: nx, z: nz });
                }
            }
        }
        const path = [];
        let curr = end, key = `${curr.x},${curr.z}`;
        while (cameFrom[key]) {
            path.unshift(curr);
            curr = cameFrom[key];
            key = `${curr.x},${curr.z}`;
        }
        callback(path);
    }, 0);
}

}

        class TerrainSystem {
            constructor(gridSize, tileSize, heightLevels) {
                this.gridSize = gridSize; this.tileSize = tileSize; this.heightLevels = heightLevels;
                this.terrainGroup = new THREE.Group(); this.tiles = [];
                this.levelColors = [0x277da1, 0x4fc3f7, 0x43aa8b, 0x90be6d, 0xf9c74f, 0xf9844a, 0xf3722c, 0x577590];
            }

            generateTerrain() {
                for (let x = 0; x < this.gridSize; x++) {
                    this.tiles[x] = [];
                    for (let z = 0; z < this.gridSize; z++) {
                        const height = this.generateHeightForPosition(x, z);
                        const tile = this.createTile(x, z, height);
                        tile.castShadow = tile.receiveShadow = true;
                        this.tiles[x][z] = { mesh: tile, height, x, z };
                        this.terrainGroup.add(tile);
                    }
                }
            }

            generateHeightForPosition(x, z) {
                const centerX = this.gridSize / 2, centerZ = this.gridSize / 2;
                const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(z - centerZ, 2));
                const normalizedDistance = distance / (this.gridSize / 2);
                let height = Math.floor((1 - normalizedDistance) * this.heightLevels) + Math.floor((Math.random() - 0.5) * 3);
                return Math.max(0, Math.min(this.heightLevels - 1, height));
            }

            createTile(x, z, height) {
                const geometry = new THREE.BoxGeometry(this.tileSize * 0.9, 0.5 + height * 0.5, this.tileSize * 0.9);
                const material = new THREE.MeshLambertMaterial({ color: this.levelColors[height] });
                const tile = new THREE.Mesh(geometry, material);
                const worldX = (x - this.gridSize / 2) * this.tileSize, worldZ = (z - this.gridSize / 2) * this.tileSize, worldY = (0.5 + height * 0.5) / 2;
                tile.position.set(worldX, worldY, worldZ); tile.castShadow = tile.receiveShadow = true; tile.userData = { x, z, height };
                return tile;
            }

            getTile(x, z) { return (x >= 0 && x < this.gridSize && z >= 0 && z < this.gridSize) ? this.tiles[x][z] : null; }

            updateTileHeight(x, z, newHeight) {
                const tile = this.getTile(x, z);
                if (tile) {
                    tile.height = Math.max(0, Math.min(this.heightLevels - 1, newHeight));
                    const mesh = tile.mesh;
                    const newGeometry = new THREE.BoxGeometry(this.tileSize * 0.9, 0.5 + tile.height * 0.5, this.tileSize * 0.9);
                    mesh.geometry.dispose(); mesh.geometry = newGeometry; mesh.material.color.setHex(this.levelColors[tile.height]);
                    mesh.position.y = (0.5 + tile.height * 0.5) / 2;
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const game = new GameEngine();
            window.game = game;
        });
    </script>
</body>
</html>
