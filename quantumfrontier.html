<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Frontier</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js" integrity="sha512-xi/RZRIF/S0hJ+yJJYuZ5yk6/8pCiRlEXZzoguSMl+vk2i3m6UjUO/WcZ11blRL/O+rnj94JRGwt/CHbc9+6EA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  </head>
  <body>
    <div id="gameContainer">
      <div id="intro">
        <h1>Quantum Frontier</h1>
        <p>Navigate through hostile space territories.Defend against alien sentries orbiting distant worlds.Use WASD or Arrow Keys to move,SPACE to fire.Keys 1-5 to change weapons.Stay alert-enemies will attack when you get too close!</p>
        <button id="startBtn">Launch Mission</button>
      </div>
      <div id="hud">
        <div id="healthHud">âœš <span id="health">100</span>
        </div>
        <div id="scoreHud">â˜… <span id="score">0</span>
        </div>
        <div id="weaponHud">
          <span id="currentWeapon">1-Blaster</span>
        </div>
        <div id="coordinates">
          <span id="posX">0</span>, <span id="posZ">0</span>
        </div>
      </div>
      <div id="minimap">
        <canvas id="minimapCanvas" width="120" height="120"></canvas>
        <div id="minimapToggle">âŠž</div>
      </div>
      <div id="effects"></div>
      <div id="controls">
        <div>WASD/Arrows-Move</div>
        <div>SPACE-Fire</div>
        <div>1-5-Weapons</div>
      </div>
      <div id="mobileControls">
        <div id="dpad">
          <div id="dpadOuter"></div>
          <div id="dpadInner"></div>
        </div>
        <div id="fireBtn">FIRE</div>
        <div id="weaponBtn">W <br>1 </div>
      </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
    <script>
      const CONFIG = {
        player: {
          acc: 0.1,
          maxSpeed: 0.8,
          friction: 0.92,
          health: 1000
        },
        space: {
          starCount: 1000,
          rotSpeed: 0.0001,
          size: 600
        },
        enemy: {
          orbitMod: 8,
          baseSpeed: 0.015,
          speedVar: 0.005,
          attackRange: 40,
          health: 30,
          chaseSpeed: 0.3,
          retSpeed: 0.3,
          shootCooldown: 120,
          minDistance: 4
        },
        bullet: {
          speed: 2,
          life: 80,
          damage: 10,
          enemySpeed: 1.5,
          enemyDamage: 15
        },
        weapons: {
          laser: {
            damage: 20,
            width: 10,
            maxDist: 100
          }
        },
        audio: {
          speed: {
            color: 0x00ff00,
            effect: 'speed',
            mult: 1.5,
            duration: 30000
          },
          damage: {
            color: 0xff0000,
            effect: 'damage',
            mult: 2,
            duration: 30000
          },
          health: {
            color: 0x0088ff,
            effect: 'health',
            amount: 200,
            duration: 0
          }
        }
      };
      class ShipFactory {
        static templates = {
          player: {
            type: 'tie',
            scale: 0.9,
            cockpit: 'octahedron',
            cockpitScale: 1.5,
            panelCount: 2,
            panelShape: 'diamond',
            panelSize: 4,
            panelDist: 2.2,
            panelThick: 0.1,
            panelY: 0.2,
            panelZ: 0.1,
            panelRotX: -50,
            panelRotY: 0,
            panelAngle: 0,
            hasStruts: !0,
            strutType: 'hexagonal',
            strutThick: 0.19,
            strutCount: 1,
            strutAngle: -90,
            primaryColor: 0x3742fa,
            secondaryColor: 0x2f3542,
            accentColor: 0x70a1ff,
            cockpitColor: 0xff4757
          },
          fighter: {
            type: 'classic',
            scale: 1,
            bodyWidth: 1.5,
            bodyHeight: 0.2,
            bodyLength: 3,
            hasWings: !0,
            wingSpan: 3,
            wingThick: 0.15,
            wingPos: 0,
            wingRotY: 0,
            wingDihedral: 0,
            engineCount: 2,
            engineSize: 0.25,
            enginePosZ: -1.5,
            engineSpacing: 1.5,
            hasCockpit: !0,
            cockpit: 'sphere',
            cockpitScale: 0.3,
            cockpitY: 0.2,
            cockpitZ: 1,
            primaryColor: 0xff4757,
            secondaryColor: 0xff3838,
            accentColor: 0xff6b6b,
            cockpitColor: 0x2f3542
          },
          interceptor: {
            type: 'tie',
            scale: 1.33,
            cockpit: 'sphere',
            cockpitScale: 1.2,
            panelCount: 2,
            panelShape: 'hexagon',
            panelSize: 2,
            panelDist: 2.5,
            panelThick: 0.1,
            panelY: 0,
            panelZ: 0,
            panelRotX: 5,
            panelRotY: -90,
            panelAngle: 90,
            hasStruts: !0,
            strutType: 'cylinder',
            strutThick: 0.11,
            strutCount: 1,
            strutAngle: 90,
            primaryColor: 0x9b59b6,
            secondaryColor: 0x8e44ad,
            accentColor: 0xd63031,
            cockpitColor: 0x2d3436
          },
          heavy: {
            type: 'classic',
            scale: 1.2,
            bodyWidth: 2.5,
            bodyHeight: 0.4,
            bodyLength: 5,
            hasWings: !0,
            wingSpan: 5,
            wingThick: 0.3,
            wingPos: -1.5,
            wingRotY: 0,
            wingDihedral: 0,
            engineCount: 4,
            engineSize: 0.4,
            enginePosZ: -2.5,
            engineSpacing: 1.5,
            hasCockpit: !0,
            cockpit: 'sphere',
            cockpitScale: 0.5,
            cockpitY: 0.4,
            cockpitZ: 1.5,
            primaryColor: 0x2ed573,
            secondaryColor: 0x1e90ff,
            accentColor: 0x7bed9f,
            cockpitColor: 0xff5252
          },
          scout: {
            type: 'classic',
            scale: 1.6,
            bodyWidth: 1.2,
            bodyHeight: 0.6,
            bodyLength: 4.6,
            hasWings: !0,
            wingSpan: 5.6,
            wingThick: 0.15,
            wingPos: -1.5,
            wingRotY: 0,
            wingDihedral: 0,
            engineCount: 2,
            engineSize: 0.4,
            enginePosZ: -2,
            engineSpacing: 1.6,
            hasCockpit: !0,
            cockpit: 'sphere',
            cockpitScale: 0.5,
            cockpitY: 0.3,
            cockpitZ: -0.5,
            primaryColor: 0xfeca57,
            secondaryColor: 0x2ed9ff,
            accentColor: 0xfeca57,
            cockpitColor: 0x616161
          },
          purplediamond: {
            type: 'tie',
            scale: 1.8,
            cockpit: 'octahedron',
            cockpitScale: 2.1,
            panelCount: 2,
            panelShape: 'triangle',
            panelSize: 1.4,
            panelDist: 2,
            panelThick: 0.5,
            panelY: 0,
            panelZ: 0.1,
            panelRotX: 35,
            panelRotY: 5,
            panelAngle: 0,
            hasStruts: !1,
            strutType: 'cylinder',
            strutThick: 0.19,
            strutCount: 3,
            strutAngle: -10,
            primaryColor: 0x5f27cd,
            secondaryColor: 0xfeca57,
            accentColor: 0x96ceb4,
            cockpitColor: 0x5f27cd
          },
          doradito: {
            type: 'tie',
            scale: 0.5,
            cockpit: 'dodecahedron',
            cockpitScale: 2.1,
            panelCount: 2,
            panelShape: 'diamond',
            panelSize: 4,
            panelDist: 3.3,
            panelThick: 0.4,
            panelY: 0.2,
            panelZ: -2,
            panelRotX: -90,
            panelRotY: 90,
            panelAngle: 0,
            hasStruts: !0,
            strutType: 'box',
            strutThick: 0.29,
            strutCount: 2,
            strutAngle: -40,
            primaryColor: 0xff9f43,
            secondaryColor: 0xff6b6b,
            accentColor: 0xfeca57,
            cockpitColor: 0xfeca57
          }
        };
        static geometries = {
          hexagon: (sz) => new THREE.CylinderGeometry(sz, sz, 0.1, 6),
          square: (sz) => new THREE.BoxGeometry(sz, sz, 0.1),
          diamond: (sz) => {
            const g = new THREE.OctahedronGeometry(sz / 1.4);
            g.scale(1, 1, 0.1);
            return g
          },
          circle: (sz) => new THREE.CylinderGeometry(sz / 2, sz / 2, 0.1, 16),
          triangle: (sz) => {
            const g = new THREE.ConeGeometry(sz, 0.1, 3);
            g.rotateX(Math.PI / 2);
            return g
          },
          star: (sz) => {
            const shape = new THREE.Shape();
            const outerRadius = sz;
            const innerRadius = sz * 0.5;
            const spikes = 5;
            for (let i = 0; i < spikes * 2; i++) {
              const angle = (i / (spikes * 2)) * Math.PI * 2;
              const radius = i % 2 === 0 ? outerRadius : innerRadius;
              const x = Math.cos(angle) * radius;
              const y = Math.sin(angle) * radius;
              if (i === 0) shape.moveTo(x, y);
              else shape.lineTo(x, y)
            }
            return new THREE.ExtrudeGeometry(shape, {
              depth: 0.1,
              bevelEnabled: !1
            })
          }
        };
        static create(templateName, customProps = {}) {
          const template = {
            ...this.templates[templateName],
            ...customProps
          };
          if (!template) {
            console.warn(`Ship template '${templateName}' not found`);
            return this.create('fighter')
          }
          return template.type === 'tie' ? this.createTieShip(template) : this.createClassicShip(template)
        }
        static createTieShip(cfg) {
          const ship = new THREE.Group();
          const sc = cfg.scale || 1.8;
          let cockpitGeom;
          switch (cfg.cockpit || 'sphere') {
            case 'sphere':
              cockpitGeom = new THREE.SphereGeometry((cfg.cockpitScale || 1.2) * sc, 12, 12);
              break;
            case 'box':
              cockpitGeom = new THREE.BoxGeometry((cfg.cockpitScale || 1.2) * sc, (cfg.cockpitScale || 1.2) * sc, (cfg.cockpitScale || 1.2) * sc);
              break;
            case 'octahedron':
              cockpitGeom = new THREE.OctahedronGeometry((cfg.cockpitScale || 1.2) * sc);
              break;
            case 'cylinder':
              cockpitGeom = new THREE.CylinderGeometry((cfg.cockpitScale || 1.2) * sc, (cfg.cockpitScale || 1.2) * sc, (cfg.cockpitScale || 1.2) * sc, 8);
              break;
            case 'dodecahedron':
              cockpitGeom = new THREE.DodecahedronGeometry((cfg.cockpitScale || 1.2) * sc);
              break;
            default:
              cockpitGeom = new THREE.SphereGeometry((cfg.cockpitScale || 1.2) * sc, 12, 12)
          }
          const cockpitMat = new THREE.MeshLambertMaterial({
            color: cfg.cockpitColor || 0xff5252
          });
          const cockpit = new THREE.Mesh(cockpitGeom, cockpitMat);
          ship.add(cockpit);
          for (let i = 0; i < (cfg.panelCount || 2); i++) {
            const panelGeom = this.geometries[cfg.panelShape || 'hexagon']((cfg.panelSize || 2) * sc);
            panelGeom.scale(1, 1, (cfg.panelThick || 0.1) * sc * 10);
            const panelMat = new THREE.MeshLambertMaterial({
              color: cfg.primaryColor || 0x2ed573
            });
            const panel = new THREE.Mesh(panelGeom, panelMat);
            const angle = (i * Math.PI * 2) / (cfg.panelCount || 2);
            const x = Math.cos(angle) * (cfg.panelDist || 2.5) * sc;
            const z = Math.sin(angle) * (cfg.panelDist || 2.5) * sc;
            panel.position.set(x, (cfg.panelY || 0) * sc, z + (cfg.panelZ || 0) * sc);
            panel.rotation.x = ((cfg.panelRotX || 0) * Math.PI) / 180;
            panel.rotation.y = angle + Math.PI / 2 + ((cfg.panelRotY || 0) * Math.PI) / 180;
            panel.rotation.z = ((cfg.panelAngle || 0) * Math.PI) / 180;
            ship.add(panel);
            if (cfg.hasStruts !== !1) {
              for (let s = 0; s < (cfg.strutCount || 1); s++) {
                let strutGeom;
                const strutLength = (cfg.panelDist || 2.5) * sc * 0.8;
                switch (cfg.strutType || 'cylinder') {
                  case 'cylinder':
                    strutGeom = new THREE.CylinderGeometry((cfg.strutThick || 0.1) * sc, (cfg.strutThick || 0.1) * sc, strutLength, 8);
                    break;
                  case 'box':
                    strutGeom = new THREE.BoxGeometry((cfg.strutThick || 0.1) * sc * 2, strutLength, (cfg.strutThick || 0.1) * sc * 2);
                    break;
                  case 'hexagonal':
                    strutGeom = new THREE.CylinderGeometry((cfg.strutThick || 0.1) * sc, (cfg.strutThick || 0.1) * sc, strutLength, 6);
                    break;
                  default:
                    strutGeom = new THREE.CylinderGeometry((cfg.strutThick || 0.1) * sc, (cfg.strutThick || 0.1) * sc, strutLength, 8)
                }
                const strutMat = new THREE.MeshLambertMaterial({
                  color: cfg.secondaryColor || 0x1e90ff
                });
                const strut = new THREE.Mesh(strutGeom, strutMat);
                const strutOffset = (cfg.strutCount || 1) > 1 ? (s - ((cfg.strutCount || 1) - 1) / 2) * 0.3 * sc : 0;
                const strutX = x / 2;
                const strutZ = (z + (cfg.panelZ || 0) * sc) / 2 + strutOffset;
                strut.position.set(strutX, (cfg.panelY || 0) * sc / 2, strutZ);
                strut.rotation.z = -angle + ((cfg.strutAngle || 0) * Math.PI) / 180;
                if ((cfg.strutType || 'cylinder') === 'box') {
                  strut.rotation.y = angle
                }
                ship.add(strut)
              }
            }
          }
          return ship
        }
        static createClassicShip(cfg) {
          const ship = new THREE.Group();
          const sc = cfg.scale || 1.8;
          const bodyGeom = new THREE.BoxGeometry((cfg.bodyWidth || 2) * sc, (cfg.bodyHeight || 0.3) * sc, (cfg.bodyLength || 4) * sc);
          const bodyMat = new THREE.MeshLambertMaterial({
            color: cfg.primaryColor || 0x2ed573
          });
          const body = new THREE.Mesh(bodyGeom, bodyMat);
          ship.add(body);
          if (cfg.hasWings !== !1) {
            const wingGeom = new THREE.BoxGeometry((cfg.wingSpan || 4) * sc, (cfg.wingThick || 0.2) * sc, 1 * sc);
            const wingMat = new THREE.MeshLambertMaterial({
              color: cfg.secondaryColor || 0x1e90ff
            });
            const wing = new THREE.Mesh(wingGeom, wingMat);
            wing.position.set(0, -0.1 * sc, (cfg.wingPos || -1) * sc);
            wing.rotation.z = ((cfg.wingRotY || 0) * Math.PI) / 180;
            wing.rotation.x = ((cfg.wingDihedral || 0) * Math.PI) / 180;
            ship.add(wing)
          }
          const engineCount = cfg.engineCount || 2;
          const engineSpacing = cfg.engineSpacing || 1.5;
          const enginePositions = [];
          if (engineCount === 1) {
            enginePositions.push([0, 0])
          } else if (engineCount === 2) {
            enginePositions.push([-(engineSpacing * sc), 0], [engineSpacing * sc, 0])
          } else if (engineCount === 3) {
            enginePositions.push([0, 0], [-(engineSpacing * sc), 0], [engineSpacing * sc, 0])
          } else if (engineCount === 4) {
            enginePositions.push([-(engineSpacing * sc), 0], [engineSpacing * sc, 0], [-(engineSpacing * sc), 0.3 * sc], [engineSpacing * sc, 0.3 * sc])
          } else if (engineCount === 6) {
            enginePositions.push([-(engineSpacing * sc), 0], [engineSpacing * sc, 0], [-(engineSpacing * sc) * 0.7, 0.3 * sc], [engineSpacing * sc * 0.7, 0.3 * sc], [-(engineSpacing * sc) * 0.7, -0.3 * sc], [engineSpacing * sc * 0.7, -0.3 * sc])
          }
          for (let i = 0; i < enginePositions.length; i++) {
            const engineGeom = new THREE.SphereGeometry((cfg.engineSize || 0.3) * sc, 8, 8);
            const engineMat = new THREE.MeshBasicMaterial({
              color: cfg.accentColor || 0x7bed9f,
              transparent: !0,
              opacity: 0.8
            });
            const engine = new THREE.Mesh(engineGeom, engineMat);
            engine.position.set(enginePositions[i][0], enginePositions[i][1], (cfg.enginePosZ || -2) * sc);
            ship.add(engine)
          }
          if (cfg.hasCockpit !== !1) {
            let cockpitGeom;
            switch (cfg.cockpit || 'sphere') {
              case 'sphere':
                cockpitGeom = new THREE.SphereGeometry((cfg.cockpitScale || 0.4) * sc, 8, 8);
                break;
              case 'box':
                cockpitGeom = new THREE.BoxGeometry((cfg.cockpitScale || 0.4) * sc, (cfg.cockpitScale || 0.4) * sc, (cfg.cockpitScale || 0.4) * sc);
                break;
              case 'cylinder':
                cockpitGeom = new THREE.CylinderGeometry((cfg.cockpitScale || 0.4) * sc, (cfg.cockpitScale || 0.4) * sc, (cfg.cockpitScale || 0.4) * sc, 8);
                break;
              case 'cone':
                cockpitGeom = new THREE.ConeGeometry((cfg.cockpitScale || 0.4) * sc, (cfg.cockpitScale || 0.4) * sc * 1.5, 8);
                break;
              default:
                cockpitGeom = new THREE.SphereGeometry((cfg.cockpitScale || 0.4) * sc, 8, 8)
            }
            const cockpitMat = new THREE.MeshLambertMaterial({
              color: cfg.cockpitColor || 0xff5252
            });
            const cockpit = new THREE.Mesh(cockpitGeom, cockpitMat);
            cockpit.position.set(0, (cfg.cockpitY || 0.3) * sc, (cfg.cockpitZ || 0.5) * sc);
            ship.add(cockpit)
          }
          return ship
        }
      }
      class EnemyFactory {
        static types = {
          'f': {
            shipType: 'fighter',
            health: 30,
            chaseSpeed: 0.4,
            weaponType: 'rapid',
            attackRange: 40,
            score: 100
          },
          'i': {
            shipType: 'interceptor',
            health: 50,
            chaseSpeed: 0.5,
            weaponType: 'burst',
            attackRange: 40,
            score: 150
          },
          's': {
            shipType: 'scout',
            health: 50,
            chaseSpeed: 0.6,
            weaponType: 'burst',
            attackRange: 40,
            score: 150
          },
          'd': {
            shipType: 'doradito',
            health: 50,
            chaseSpeed: 0.6,
            weaponType: 'burst',
            attackRange: 40,
            score: 150
          },
          'p': {
            shipType: 'purplediamond',
            health: 50,
            chaseSpeed: 0.6,
            weaponType: 'burst',
            attackRange: 40,
            score: 150
          },
          'h': {
            shipType: 'heavy',
            health: 100,
            chaseSpeed: 0.3,
            weaponType: 'heavy',
            attackRange: 45,
            score: 200
          }
        };
        static create(type, planet, index, totalCount) {
          const config = this.types[type];
          if (!config) {
            console.warn(`Enemy type '${type}' not found`);
            return null
          }
          const ship = ShipFactory.create(config.shipType);
          const angle = (index * Math.PI * 2) / totalCount;
          return {
            mesh: ship,
            planet: planet,
            angle: angle,
            originalAngle: angle,
            speed: CONFIG.enemy.baseSpeed + Math.random() * CONFIG.enemy.speedVar,
            attackRange: config.attackRange,
            attacking: !1,
            retreating: !1,
            health: config.health,
            maxHealth: config.health,
            type: type,
            chaseSpeed: config.chaseSpeed,
            shootCooldown: 0,
            weaponType: config.weaponType,
            score: config.score,
            stuck: !1
          }
        }
      }
      class PlanetFactory {
        static configs = [{
          radius: 18,
          color: 0xff6b6b,
          distance: 100,
          enemyCount: 9,
          enemyType: 'f',
           style: 'sharp',          // ðŸ”§ Angular mining/industrial surface
          irregularity: 0,   
          health: 200,
          orbitCenter: {
            x: 0,
            z: 0
          },
          orbitSpeed: 0.005,
          startAngle: 0,
          dialogue: {
            name: 'Asteria Prime',
            image: './quantumfrontier/assets/images/planets.jpeg',
             setStoryWaypoint:'Helion IV',
            baseText: 'Asteria Prime fue una vez el mayor exportador de minerales raros del sector, con flotas de cargueros despegando diariamente hacia los mundos centrales. Ahora solo quedan torres de perforaciÃ³n oxidadas y pueblos fantasma barridos por tormentas de polvo./n Entre los datos fragmentados de las Ãºltimas semanas antes del abandono, algo no encaja. Transferencias nocturnas, cÃ³digos de embarque alterados, y un patrÃ³n que solo alguien con tu experiencia podrÃ­a reconocer: contrabando a gran escala./nEl rastro apunta hacia los caÃ±ones rocosos de Helion IV, donde los mercenarios no hacen preguntas.',
            flagTexts: {
              visited_proxima: 'Energy readings from Proxima Centauri b indicate this planet was part of an interconnected network.',
              visited_trappist: 'The quantum signatures resonate with TRAPPIST-1e readings - confirming the ancient network theory.'
            }
          }
        }, {
          radius: 25,
          color: 0xff0000,
          distance: 180,
          enemyCount: 6,
          enemyType: 'd',
          health: 300,
          orbitCenter: {
            x: 0,
            z: 0
          },
          orbitSpeed: 0.003,
          startAngle: Math.PI / 4,
          dialogue: {
            name: 'Pyrrhos',
             setStoryWaypoint:'Helion IV',
            image: './quantumfrontier/assets/images/planets44.jpeg',
            baseText: 'Pyrrhos es un infierno de lava y roca fundida donde los rÃ­os de magma serpentean entre picos de basalto negro. El calor es tan intenso que incluso los drones mÃ¡s resistentes fallan despuÃ©s de pocas horas de exposiciÃ³n. AquÃ­, la supervivencia se mide en minutos./n Enterrada en las profundidades rocosas, una forja milenaria late con el resplandor de cristales semi-formados. Los grabados en las paredes hablan de una civilizaciÃ³n que dominaba energÃ­as capaces de abrir puertas entre mundos. Pero tambiÃ©n advierten sobre el precio de tal poder./n Las inscripciones apuntan hacia "los guardianes del mundo verde" en Viridara, donde el conocimiento ancestral aguarda entre las ruinas envueltas en vegetaciÃ³n.',
            flagTexts: {
              visited_kepler: 'The crystalline formations here match those found on Kepler-442b - part of the same stellar engineering project.',
              visited_trappist: 'Cross-referencing with TRAPPIST-1e data reveals this is a mining outpost for the ancient network.'
            }
          }
        }, {
          radius: 25,
          color: 0x00ff88,
          distance: 220,
          enemyCount: 6,
          irregularity: 0.4,   
          enemyType: 'p',
          health: 300,
          orbitCenter: {
            x: 50,
            z: 50
          },
          orbitSpeed: 0.002,
          startAngle: Math.PI / 2,
          dialogue: {
            name: 'Helion IV',
            image: 'quantumfrontier/assets/images/planets3.jpeg',
            baseText: 'Los caÃ±ones de arenisca roja de Helion IV ocultan una de las fortalezas mercenarias mÃ¡s temidas del sector exterior. Durante dÃ©cadas, estas paredes rocosas han protegido operaciones que los mundos centrales prefieren ignorar: trÃ¡fico de armas, informaciÃ³n clasificada, y cargamentos que oficialmente nunca existieron./n Las patrullas aÃ©reas que surcan los desfiladeros son solo la primera advertencia. AquÃ­, la lealtad se compra con crÃ©ditos y las preguntas equivocadas pueden costarte mÃ¡s que tu nave. Pero los registros de Asteria Prime no mienten: algo importante pasÃ³ por esta fortaleza./n Un contacto en las cantinas subterrÃ¡neas menciona algo perturbador: el FSA intentÃ³ un asalto reciente que terminÃ³ en desastre. Los mercenarios hablan de "fragmentos cristalinos" y una guerra que apenas estÃ¡ comenzando.',
            flagTexts: {
              visited_kepler: 'The quantum signatures here resonate with similar readings from Kepler-442b. This confirms the ancient network theory.',
              visited_proxima: 'Data correlation with Proxima Centauri b suggests this was the central hub of an ancient civilization.'
            }
          }
        }];

        static createPlanetTexture(color, radius, type) {
          const canvas = document.createElement('canvas');
          canvas.width = 512;
          canvas.height = 512;
          const ctx = canvas.getContext('2d');
          const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
          if (type === 'gas') {
            gradient.addColorStop(0, `hsl(${(color >> 16) & 255}, 70%, 60%)`);
            gradient.addColorStop(0.3, `hsl(${((color >> 8) & 255) + 20}, 80%, 45%)`);
            gradient.addColorStop(0.7, `hsl(${(color & 255) + 40}, 60%, 35%)`);
            gradient.addColorStop(1, `hsl(${(color >> 16) & 255}, 50%, 25%)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            for (let i = 0; i < 8; i++) {
              ctx.strokeStyle = `hsla(${((color >> 8) & 255) + i * 10}, 60%, ${40 + i * 3}%, 0.6)`;
              ctx.lineWidth = 2 + Math.random() * 3;
              ctx.beginPath();
              ctx.moveTo(0, 100 + i * 40 + Math.sin(i) * 20);
              for (let x = 0; x < 512; x += 10) {
                ctx.lineTo(x, 100 + i * 40 + Math.sin(x * 0.02 + i) * 15 + Math.cos(x * 0.01) * 10)
              }
              ctx.stroke()
            }
          } else if (type === 'ice') {
            const iceGrad = ctx.createLinearGradient(0, 0, 512, 512);
            iceGrad.addColorStop(0, '#b3e5fc');
            iceGrad.addColorStop(0.5, '#81d4fa');
            iceGrad.addColorStop(1, '#4fc3f7');
            ctx.fillStyle = iceGrad;
            ctx.fillRect(0, 0, 512, 512);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            for (let i = 0; i < 200; i++) {
              const x = Math.random() * 512;
              const y = Math.random() * 512;
              const size = Math.random() * 3 + 1;
              ctx.fillRect(x, y, size, size)
            }
            for (let i = 0; i < 50; i++) {
              ctx.strokeStyle = 'rgba(200, 230, 255, 0.6)';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.arc(Math.random() * 512, Math.random() * 512, Math.random() * 20 + 5, 0, Math.PI * 2);
              ctx.stroke()
            }
          } else {
            const baseHue = (color >> 16) & 255;
            ctx.fillStyle = `hsl(${baseHue}, 40%, 35%)`;
            ctx.fillRect(0, 0, 512, 512);
            for (let i = 0; i < 100; i++) {
              const x = Math.random() * 512;
              const y = Math.random() * 512;
              const size = Math.random() * 15 + 5;
              ctx.fillStyle = `hsla(${baseHue + Math.random() * 30 - 15}, 50%, ${25 + Math.random() * 20}%, 0.7)`;
              ctx.beginPath();
              ctx.arc(x, y, size, 0, Math.PI * 2);
              ctx.fill()
            }
            for (let i = 0; i < 50; i++) {
              const x = Math.random() * 512;
              const y = Math.random() * 512;
              const size = Math.random() * 8 + 3;
              ctx.fillStyle = `hsla(${baseHue}, 30%, 20%, 0.8)`;
              ctx.beginPath();
              ctx.arc(x, y, size, 0, Math.PI * 2);
              ctx.fill()
            }
          }
          return new THREE.CanvasTexture(canvas)
        }
static createIrregularPlanet(radius, irregularity = 0, style = 'highdetail') {
  // Configurar subdivisiones segÃºn el estilo
   
  let subdivisions;
  switch(style) {
    case 'lowpoly':     subdivisions = [8, 6];   break;  // ðŸ”§ Muy angular
    case 'sharp':       subdivisions = [16, 12]; break;  // ðŸ”§ Angular pero con mÃ¡s detalle
    case 'medium':      subdivisions = [32, 24]; break;  // ðŸ”§ Balance
    case 'smooth':      subdivisions = [64, 64]; break;  // ðŸ”§ Suave (original)
    case 'highdetail':  subdivisions = [128, 96]; break; // ðŸ”§ Muy detallado
    default:            subdivisions = [32, 24];
  }
  
  const geometry = new THREE.SphereGeometry(radius, subdivisions[0], subdivisions[1]);
  const positions = geometry.attributes.position.array;
  const noise = new PerlinNoise(Math.random());
  
  for (let i = 0; i < positions.length; i += 3) {
    const x = positions[i];
    const y = positions[i + 1];
    const z = positions[i + 2];
    const distance = Math.sqrt(x*x + y*y + z*z);
    
    const nx = x / radius;
    const ny = y / radius;
    const nz = z / radius;
    
    // Aplicar ruido segÃºn el estilo
    let heightVariation = 0;
    
    if (style === 'lowpoly') {
      // ðŸ”§ ESTILO LOW POLY - Pocos detalles, cambios dramÃ¡ticos
      heightVariation += noise.noise(nx * 2, ny * 2, nz * 2) * 0.8;
      heightVariation += noise.noise(nx * 4, ny * 4, nz * 4) * 0.4;
      
      // Cuantizar para crear "steps" mÃ¡s marcados
      heightVariation = Math.floor(heightVariation * 4) / 4;
      
    } else if (style === 'sharp') {
      // ðŸ”§ ESTILO SHARP - Detalles medios con bordes definidos
      heightVariation += noise.noise(nx * 3, ny * 3, nz * 3) * 0.7;
      heightVariation += noise.noise(nx * 6, ny * 6, nz * 6) * 0.3;
      heightVariation += noise.noise(nx * 12, ny * 12, nz * 12) * 0.1;
      
      // Aplicar funciÃ³n que acentÃºa los contrastes
      heightVariation = Math.sign(heightVariation) * Math.pow(Math.abs(heightVariation), 0.7);
      
    } else if (style === 'terraced') {
      // ðŸ”§ ESTILO TERRAZAS - Como mesas/escalones
      heightVariation += noise.noise(nx * 4, ny * 4, nz * 4) * 0.6;
      heightVariation += noise.noise(nx * 8, ny * 8, nz * 8) * 0.3;
      
      // Crear terrazas/escalones
      const steps = 6;
      heightVariation = Math.floor(heightVariation * steps) / steps;
      
    } else {
      // ðŸ”§ ESTILO SMOOTH (original)
      heightVariation += noise.noise(nx * 4, ny * 4, nz * 4) * 0.6;
      heightVariation += noise.noise(nx * 8, ny * 8, nz * 8) * 0.3;
      heightVariation += noise.noise(nx * 16, ny * 16, nz * 16) * 0.1;
    }
    
    const newDistance = radius + (heightVariation * irregularity * radius);
    const factor = newDistance / distance;
    
    positions[i] = x * factor;
    positions[i + 1] = y * factor;
    positions[i + 2] = z * factor;
  }
  
  geometry.attributes.position.needsUpdate = true;
  
  // ðŸ”§ CONTROL DE SUAVIZADO
  if (style === 'lowpoly' || style === 'sharp' || style === 'terraced') {
    // NO computar normales suaves = mantener bordes sharp
    geometry.computeFaceNormals();
  } else {
    // Computar normales suaves para apariencia "blobby"
    geometry.computeVertexNormals();
  }
  
  return geometry;
}
 static create(index,config=null){
    const cfg=config||this.configs[index%this.configs.length];
    const planetTypes=['rocky','ice','rocky','rocky','gas'];
    const initialAngle=cfg.startAngle||((Math.PI*2/this.configs.length)*index);
    let planetGeom;
    const irregularity=cfg.irregularity!==undefined?cfg.irregularity:0.3;
    if(irregularity===0){
        planetGeom=new THREE.SphereGeometry(cfg.radius,32,24)
    }else{
        planetGeom=this.createIrregularPlanet(cfg.radius,irregularity,cfg.style||'medium')
    }
    
    // Don't use complex textures for highly emissive objects (like suns)
    const isHighlyEmissive = cfg.emissiveIntensity && cfg.emissiveIntensity > 0.5;
    const texture = isHighlyEmissive ? null : this.createPlanetTexture(cfg.color,cfg.radius,planetTypes[index%planetTypes.length]);
    const materialProps = texture ? {map:texture,color:cfg.color} : {color:cfg.color};
    
    if(cfg.emissive!==undefined){
        materialProps.emissive=new THREE.Color(cfg.emissive);
        materialProps.emissiveIntensity=cfg.emissiveIntensity||0.3
    }
    
    let planetMat;
    if(cfg.emissiveIntensity&&cfg.emissiveIntensity>0.5){
        // Fix: MeshBasicMaterial doesn't support emissiveIntensity, so we multiply the color
        const emissiveColor = materialProps.emissive || new THREE.Color(cfg.color);
        const intensity = cfg.emissiveIntensity || 1.0;
        emissiveColor.multiplyScalar(intensity);
        
        const basicMaterialProps = {
            color:cfg.color,
            emissive:emissiveColor
        };
        if(texture) basicMaterialProps.map = texture;
        
        planetMat=new THREE.MeshBasicMaterial(basicMaterialProps)
    }else{
        const lambertMaterialProps = {color: cfg.color};
        if(texture) lambertMaterialProps.map = texture;
        if(materialProps.emissive) lambertMaterialProps.emissive = materialProps.emissive;
        if(materialProps.emissiveIntensity) lambertMaterialProps.emissiveIntensity = materialProps.emissiveIntensity;
        
        planetMat=new THREE.MeshLambertMaterial(lambertMaterialProps)
    }
    
    const planet=new THREE.Mesh(planetGeom,planetMat);
    const x=(cfg.orbitCenter?.x||0)+Math.cos(initialAngle)*cfg.distance;
    const z=(cfg.orbitCenter?.z||0)+Math.sin(initialAngle)*cfg.distance;
    planet.position.set(x,0,z);
    planet.rotation.y=Math.random()*Math.PI*2;
    const orbitRadius=cfg.radius+CONFIG.enemy.orbitMod;
    
    return{
        mesh:planet,
        radius:orbitRadius,
        center:planet.position.clone(),
        config:cfg,
        health:cfg.health,
        maxHealth:cfg.health,
        destroyed:!1,
        orbitCenter:{x:cfg.orbitCenter?.x||0,z:cfg.orbitCenter?.z||0},
        orbitDistance:cfg.distance,
        orbitSpeed:cfg.orbitSpeed||0.001,
        currentAngle:initialAngle
    }
}

      }
      class PerlinNoise {
        constructor(seed = Math.random()) {
          this.seed = seed;
          this.p = [];
          for (let i = 0; i < 512; i++) {
            this.p[i] = Math.floor(Math.random() * 256)
          }
          for (let i = 0; i < 256; i++) {
            this.p[256 + i] = this.p[i]
          }
        }
        fade(t) {
          return t * t * t * (t * (t * 6 - 15) + 10)
        }
        lerp(t, a, b) {
          return a + t * (b - a)
        }
        grad(hash, x, y, z) {
          const h = hash & 15;
          const u = h < 8 ? x : y;
          const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
          return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v)
        }
        noise(x, y, z) {
          const X = Math.floor(x) & 255;
          const Y = Math.floor(y) & 255;
          const Z = Math.floor(z) & 255;
          x -= Math.floor(x);
          y -= Math.floor(y);
          z -= Math.floor(z);
          const u = this.fade(x);
          const v = this.fade(y);
          const w = this.fade(z);
          const A = this.p[X] + Y;
          const AA = this.p[A] + Z;
          const AB = this.p[A + 1] + Z;
          const B = this.p[X + 1] + Y;
          const BA = this.p[B] + Z;
          const BB = this.p[B + 1] + Z;
          return this.lerp(w, this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y, z), this.grad(this.p[BA], x - 1, y, z)), this.lerp(u, this.grad(this.p[AB], x, y - 1, z), this.grad(this.p[BB], x - 1, y - 1, z))), this.lerp(v, this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1), this.grad(this.p[BA + 1], x - 1, y, z - 1)), this.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1), this.grad(this.p[BB + 1], x - 1, y - 1, z - 1))))
        }
        turbulence2d(x, y, octaves, persistence) {
          let value = 0;
          let amplitude = 1;
          let frequency = 1;
          let maxValue = 0;
          for (let i = 0; i < octaves; i++) {
            value += Math.abs(this.noise(x * frequency, y * frequency, 0)) * amplitude;
            maxValue += amplitude;
            amplitude *= persistence;
            frequency *= 2
          }
          return value / maxValue
        }
      }
      class Gradient {
        constructor() {
          this.points = []
        }
        add(point) {
          this.points.push(point);
          this.points.sort((a, b) => a[0] - b[0])
        }
        get(t) {
          if (this.points.length === 0) return [0, 0, 0];
          if (t <= this.points[0][0]) return [this.points[0][1], this.points[0][2], this.points[0][3]];
          if (t >= this.points[this.points.length - 1][0]) {
            const last = this.points[this.points.length - 1];
            return [last[1], last[2], last[3]]
          }
          for (let i = 0; i < this.points.length - 1; i++) {
            const p1 = this.points[i];
            const p2 = this.points[i + 1];
            if (t >= p1[0] && t <= p2[0]) {
              const factor = (t - p1[0]) / (p2[0] - p1[0]);
              return [Math.floor(p1[1] + (p2[1] - p1[1]) * factor), Math.floor(p1[2] + (p2[2] - p1[2]) * factor), Math.floor(p1[3] + (p2[3] - p1[3]) * factor)]
            }
          }
          return [0, 0, 0]
        }
      }
      class DeepSpaceGenerator {
        constructor() {
          this.createTexture()
        }
        createTexture() {
          const canvas = document.createElement('canvas');
          canvas.width = canvas.height = 1024;
          const ctx = canvas.getContext('2d');
          const imageData = ctx.getImageData(0, 0, 1024, 1024);
          const noise1 = new PerlinNoise(Math.random());
          const noise2 = new PerlinNoise(Math.random());
          const noise3 = new PerlinNoise(Math.random());
          const gradient = new Gradient();
          const colorThemes = [
            [
              [5, 5, 15],
              [15, 25, 45],
              [25, 15, 60],
              [10, 5, 25]
            ],
            [
              [15, 5, 5],
              [45, 15, 25],
              [60, 25, 15],
              [25, 10, 5]
            ],
            [
              [5, 15, 10],
              [15, 45, 35],
              [25, 60, 45],
              [10, 25, 15]
            ],
            [
              [15, 5, 15],
              [35, 15, 45],
              [50, 25, 60],
              [20, 10, 25]
            ]
          ];
          const theme = colorThemes[Math.floor(Math.random() * colorThemes.length)];
          gradient.add([0, theme[0][0], theme[0][1], theme[0][2]]);
          gradient.add([0.3, theme[1][0], theme[1][1], theme[1][2]]);
          gradient.add([0.6, theme[2][0], theme[2][1], theme[2][2]]);
          gradient.add([1, theme[3][0], theme[3][1], theme[3][2]]);
          const data = imageData.data;
          for (let y = 0; y < 1024; y++) {
            for (let x = 0; x < 1024; x++) {
              const nx = x / 1024 * 8;
              const ny = y / 1024 * 8;
              let noiseValue = noise1.turbulence2d(nx, ny, 8, 0.6);
              noiseValue += noise2.turbulence2d(nx * 2, ny * 2, 4, 0.3) * 0.5;
              noiseValue += noise3.noise(nx * 4, ny * 4, 0) * 0.3;
              noiseValue = Math.pow(Math.max(0, Math.min(1, noiseValue)), 2);
              const color = gradient.get(noiseValue);
              const index = (y * 1024 + x) * 4;
              data[index] = color[0];
              data[index + 1] = color[1];
              data[index + 2] = color[2];
              data[index + 3] = 255
            }
          }
          ctx.putImageData(imageData, 0, 0);
          const texture = new THREE.CanvasTexture(canvas);
          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(1, 1);
          texture.needsUpdate = !0;
          const geometry = new THREE.PlaneGeometry(3000, 3000);
          const material = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: !1,
            opacity: 1
          });
          this.mesh = new THREE.Mesh(geometry, material);
          this.mesh.position.z = -800;
          this.texture = texture
        }
        update(playerX, playerZ) {
          this.mesh.position.x = playerX * 0.2;
          this.mesh.position.y = playerZ * 0.2;
          this.texture.offset.x += 0.000005;
          this.texture.offset.y += 0.000005;
          this.texture.offset.x += playerX * 0.0000009;
          this.texture.offset.y += playerZ * 0.0000009
        }
      }
      class NebulaGenerator {
        constructor() {
          this.group = new THREE.Group();
          this.createNebulas()
        }
        createNebulas() {
          const nebulaColors = [
  [[0,0,0],[30,60,120],[60,150,255],[120,200,255]],     // Brighter blue
  [[0,0,0],[120,30,60],[255,80,150],[255,150,200]],     // Brighter pink
  [[0,0,0],[30,80,60],[100,255,150],[150,255,200]],     // Brighter green
  [[0,0,0],[80,30,120],[180,100,255],[220,150,255]],    // Brighter purple
  [[0,0,0],[120,60,30],[255,150,100],[255,200,150]]     // Brighter orange
];

          for (let layer = 0; layer < 1; layer++) {
            const nebulaTexture = this.createNebulaTexture(layer, nebulaColors[layer]);
            const size = 800 + layer * 200;
            const geometry = new THREE.PlaneGeometry(size, size);
            const material = new THREE.MeshBasicMaterial({
              map: nebulaTexture,
              transparent: !0,
              opacity: 0.33 - layer * 0.03,
              blending: THREE.AdditiveBlending
            });
            const nebula = new THREE.Mesh(geometry, material);
  //          nebula.position.set((Math.random() - 0.5) * 1000, (Math.random() - 0.5) * 1000, -300 - layer * 150);
            // Change Z position:
nebula.position.set(
  (Math.random() - 0.5) * 1000,
  (Math.random() - 0.5) * 1000,
  -100 - layer * 50    // Closer to camera
);
            nebula.rotation.z = Math.random() * Math.PI * 2;
            this.group.add(nebula)
          }
        }
        createNebulaTexture(layer, colorScheme) {
          const canvas = document.createElement('canvas');
          canvas.width = canvas.height = 512;
          const ctx = canvas.getContext('2d');
          const imageData = ctx.getImageData(0, 0, 512, 512);
          const noise = new PerlinNoise(Math.random());
          const gradient = new Gradient();
          gradient.add([0, colorScheme[0][0], colorScheme[0][1], colorScheme[0][2]]);
          gradient.add([0.2, colorScheme[1][0], colorScheme[1][1], colorScheme[1][2]]);
          gradient.add([0.6, colorScheme[2][0], colorScheme[2][1], colorScheme[2][2]]);
          gradient.add([1, colorScheme[3][0], colorScheme[3][1], colorScheme[3][2]]);
          const data = imageData.data;
          for (let y = 0; y < 512; y++) {
            for (let x = 0; x < 512; x++) {
              const nx = (x - 256) / 512 * 8;
              const ny = (y - 256) / 512 * 8;
              const distance = Math.sqrt(nx * nx + ny * ny);
              const angle = Math.atan2(ny, nx);
              const spiral = Math.sin(angle * 3 + distance * 2) * 0.3;
              const radialFalloff = Math.max(0, (1 - distance / 4) + spiral * 0.2);
              let noiseValue = noise.turbulence2d(x / 80, y / 80, 6, 0.6);
              noiseValue += noise.turbulence2d(x / 40, y / 40, 4, 0.4) * 0.7;
              noiseValue += noise.noise(x / 20, y / 20, layer * 5) * 0.5;
              const flow = Math.sin(x / 30 + y / 20) * Math.cos(y / 25) * 0.3;
              noiseValue += flow;
              let intensity = noiseValue * radialFalloff;
              intensity = Math.pow(Math.max(0, Math.min(1, intensity)), 1.8);
              const color = gradient.get(intensity);
              const index = (y * 512 + x) * 4;
              data[index] = color[0];
              data[index + 1] = color[1];
              data[index + 2] = color[2];
              data[index + 3] = Math.floor(intensity * 200 * radialFalloff)
            }
          }
          ctx.putImageData(imageData, 0, 0);
          const texture = new THREE.CanvasTexture(canvas);
          texture.needsUpdate = !0;
          return texture
        }
        update(playerX, playerZ) {
          this.group.children.forEach((nebula, index) => {
            const parallax = 0.005 + index * 0.02;
            const targetX = playerX * parallax + (index - 2) * 200;
            const targetY = playerZ * parallax + (index - 2) * 150;
            nebula.position.x += (targetX - nebula.position.x) * 0.01;
            nebula.position.y += (targetY - nebula.position.y) * 0.01;
            nebula.rotation.z += 0.0001 * (index + 1)
          })
        }
      }
      class BackgroundManager {
        constructor(scene) {
          this.scene = scene;
          this.createStarField();
          this.createDeepSpace();
          this.createNebulas()
        }
        createStarField() {
          const starGeom = new THREE.BufferGeometry();
          const starCount = CONFIG.space.starCount;
          const positions = new Float32Array(starCount * 3);
          const colors = new Float32Array(starCount * 3);
          const sizes = new Float32Array(starCount);
          for (let i = 0; i < starCount; i++) {
            const i3 = i * 3;
            positions[i3] = (Math.random() - 0.5) * CONFIG.space.size;
            positions[i3 + 1] = (Math.random() - 0.5) * CONFIG.space.size;
            positions[i3 + 2] = (Math.random() - 0.5) * CONFIG.space.size;
            const starType = Math.random();
            if (starType < 0.7) {
              colors[i3] = colors[i3 + 1] = colors[i3 + 2] = 1.0
            } else if (starType < 0.85) {
              colors[i3] = 0.7;
              colors[i3 + 1] = 0.8;
              colors[i3 + 2] = 1.0
            } else if (starType < 0.95) {
              colors[i3] = 1.0;
              colors[i3 + 1] = 1.0;
              colors[i3 + 2] = 0.7
            } else {
              colors[i3] = 1.0;
              colors[i3 + 1] = 0.7;
              colors[i3 + 2] = 0.7
            }
            sizes[i] = Math.random() * 2 + 0.5
          }
          starGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          starGeom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
          starGeom.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
          const starMat = new THREE.PointsMaterial({
            size: 1.0,
            vertexColors: !0,
            transparent: !0,
            opacity: 0.8,
            sizeAttenuation: !0
          });
          this.stars = new THREE.Points(starGeom, starMat);
          this.scene.add(this.stars)
        }
        createDeepSpace() {
          this.deepSpaceGenerator = new DeepSpaceGenerator();
          this.scene.add(this.deepSpaceGenerator.mesh)
        }
        createNebulas() {
          this.nebulaGenerator = new NebulaGenerator();
          this.scene.add(this.nebulaGenerator.group)
        }
        update(playerX, playerZ) {
          this.stars.rotation.y += CONFIG.space.rotSpeed;
          if (this.deepSpaceGenerator) {
            this.deepSpaceGenerator.update(playerX, playerZ)
          }
          if (this.nebulaGenerator) {
            this.nebulaGenerator.update(playerX, playerZ)
          }
        }
      }
      class MinimapManager {
        constructor() {
          this.canvas = document.getElementById('minimapCanvas');
          this.ctx = this.canvas.getContext('2d');
          this.expanded = !1;
            this.waypoint = null;
          this.setupEvents()
        }
setupEvents(){
    document.getElementById('minimapToggle').addEventListener('click',()=>{
        this.toggleExpanded()
    });
    
    // Improved click handling for desktop
    this.canvas.addEventListener('click',(e)=>{
        if(this.expanded){
            e.preventDefault();
            e.stopPropagation();
            this.setWaypoint(e);
        }
    });
    
    // Fixed touch handling for mobile
    this.canvas.addEventListener('touchstart',(e)=>{
        if(this.expanded){
            e.preventDefault();
            e.stopPropagation();
        }
    });
    
    this.canvas.addEventListener('touchend',(e)=>{
        if(this.expanded){
            e.preventDefault();
            e.stopPropagation();
            
            // Get the first touch that ended
            const touch = e.changedTouches[0];
            if(touch) {
                // Create a proper event-like object
                const touchEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };
                this.setWaypoint(touchEvent);
            }
        }
    });
    
    this.canvas.addEventListener('touchmove',(e)=>{
        if(this.expanded){
            e.preventDefault();
        }
    });
}

        updateWaypoint() {
    if (this.waypoint && this.waypoint.type === 'planet' && this.waypoint.planet) {
        // Update waypoint position to follow the planet
        this.waypoint.x = this.waypoint.planet.center.x;
        this.waypoint.z = this.waypoint.planet.center.z;
    }
}
setWaypoint(event){
    const rect=this.canvas.getBoundingClientRect();
    
    // Get actual canvas size (not just CSS size)
    const canvasWidth = this.canvas.width;
    const canvasHeight = this.canvas.height;
    
    // Calculate click position relative to canvas, accounting for any scaling
    const scaleX = canvasWidth / rect.width;
    const scaleY = canvasHeight / rect.height;
    
    const clickX = (event.clientX - rect.left) * scaleX;
    const clickY = (event.clientY - rect.top) * scaleY;
    
    const size = this.expanded ? 300 : 120;
    const scale = this.expanded ? 0.8 : 0.3;
    const centerX = size / 2;
    const centerY = size / 2;
    
    // Convert canvas coordinates to world coordinates
    const worldX = (clickX - centerX) / scale + game.playerShip.position.x;
    const worldZ = (clickY - centerY) / scale + game.playerShip.position.z;
    
    let targetPlanet = null;
    let minDistance = Infinity;
    
    // Check for planet clicks with better precision
    game.planets.forEach(planet => {
        if(planet.destroyed) return;
        
        const distance = Math.sqrt(Math.pow(worldX - planet.center.x, 2) + Math.pow(worldZ - planet.center.z, 2));
        const clickRadius = Math.max(planet.config.radius + 10, 20); // Increased minimum click radius for mobile
        
        if(distance < clickRadius && distance < minDistance){
            minDistance = distance;
            targetPlanet = planet;
        }
    });
    
    if(targetPlanet){
        this.waypoint = {
            x: targetPlanet.center.x,
            z: targetPlanet.center.z,
            planet: targetPlanet,
            type: 'planet'
        };
    } else {
        this.waypoint = {
            x: worldX,
            z: worldZ,
            type: 'static'
        };
    }
    
    this.showWaypointSetFeedback(event.clientX, event.clientY);
}
        toggleExpanded() {
          this.expanded = !this.expanded;
          const minimap = document.getElementById('minimap');
          const toggle = document.getElementById('minimapToggle');
          if (this.expanded) {
            minimap.classList.add('expanded');
            toggle.textContent = 'âŠŸ';
            this.canvas.width = this.canvas.height = 300
          } else {
            minimap.classList.remove('expanded');
            toggle.textContent = 'âŠž';
            this.canvas.width = this.canvas.height = 120
          }
        }
update(playerPos,planets,enemies){
    const ctx=this.ctx;
    const size=this.expanded?300:120;
    const scale=this.expanded?0.8:0.3;
    const centerX=size/2;
    const centerY=size/2;
    
    ctx.clearRect(0,0,size,size);
    ctx.fillStyle='rgba(0, 0, 20, 0.9)';
    ctx.fillRect(0,0,size,size);
    ctx.strokeStyle='rgba(79, 172, 254, 0.3)';
    ctx.lineWidth=1;
    ctx.strokeRect(1,1,size-2,size-2);
    
    // Draw orbits when expanded - show all planet orbits
    if(this.expanded){
        planets.forEach(planet=>{
            if(planet.destroyed) return;
            
            // Use the correct orbit properties from the planet object
            const orbitCenterX = (planet.orbitCenter.x - playerPos.x) * scale + centerX;
            const orbitCenterY = (planet.orbitCenter.z - playerPos.z) * scale + centerY;
            const orbitRadius = planet.orbitDistance * scale;
            
            // Show orbit if it has a meaningful radius (skip the sun at center)
            if(orbitRadius > 1) {
                ctx.strokeStyle = 'rgba(150, 150, 150, 0.4)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.arc(orbitCenterX, orbitCenterY, orbitRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        });
    }
    
    // Draw planets - show all planets when expanded, with broader view when collapsed
    planets.forEach(planet=>{
        if(planet.destroyed) return;
        
        const relX = (planet.center.x - playerPos.x) * scale + centerX;
        const relY = (planet.center.z - playerPos.z) * scale + centerY;
        
        // Expanded minimap shows all planets, collapsed shows nearby ones
        const boundary = this.expanded ? size * 2 : 10; // Much larger boundary for expanded view
        
        if(relX >= -boundary && relX <= size + boundary && relY >= -boundary && relY <= size + boundary){
            const radius = Math.max(2, planet.config.radius * scale * 0.3);
            ctx.fillStyle = `#${planet.config.color.toString(16).padStart(6, '0')}`;
            ctx.beginPath();
            ctx.arc(relX, relY, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            if(this.expanded && planet.config.dialogue){
                ctx.fillStyle = '#ffffff';
                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(planet.config.dialogue.name, relX, relY - radius - 5);
            }
        }
    });
    
    // Draw enemies
    enemies.forEach(enemy=>{
        if(enemy.health<=0)return;
        const relX=(enemy.mesh.position.x-playerPos.x)*scale+centerX;
        const relY=(enemy.mesh.position.z-playerPos.z)*scale+centerY;
        
        if(relX>=-5&&relX<=size+5&&relY>=-5&&relY<=size+5){
            ctx.fillStyle=enemy.attacking?'#ff4757':'#ff9f43';
            ctx.beginPath();
            ctx.arc(relX,relY,2,0,Math.PI*2);
            ctx.fill();
        }
    });
    
    // Draw waypoint
    if(this.waypoint){
        const waypointX=(this.waypoint.x-playerPos.x)*scale+centerX;
        const waypointY=(this.waypoint.z-playerPos.z)*scale+centerY;
        
        if(waypointX>=-10&&waypointX<=size+10&&waypointY>=-10&&waypointY<=size+10){
            ctx.fillStyle='#feca57';
            ctx.strokeStyle='#ffffff';
            ctx.lineWidth=2;
            ctx.beginPath();
            ctx.arc(waypointX,waypointY,4,0,Math.PI*2);
            ctx.fill();
            ctx.stroke();
            
            ctx.strokeStyle='#000000';
            ctx.lineWidth=1;
            ctx.beginPath();
            ctx.moveTo(waypointX-2,waypointY-2);
            ctx.lineTo(waypointX+2,waypointY+2);
            ctx.moveTo(waypointX+2,waypointY-2);
            ctx.lineTo(waypointX-2,waypointY+2);
            ctx.stroke();
        }
        
        // Draw waypoint compass arrow
        const dx=this.waypoint.x-playerPos.x;
        const dz=this.waypoint.z-playerPos.z;
        const distance=Math.sqrt(dx*dx+dz*dz);
        
        if(distance>5){
            const angle=Math.atan2(dx,dz);
            const compassRadius=size*0.35;
            const arrowX=centerX+Math.sin(angle)*compassRadius;
            const arrowY=centerY+Math.cos(angle)*compassRadius;
            
            ctx.strokeStyle='#feca57';
            ctx.fillStyle='#feca57';
            ctx.lineWidth=2;
            const arrowSize=6;
            ctx.beginPath();
            ctx.moveTo(arrowX,arrowY);
            ctx.lineTo(arrowX-arrowSize*Math.sin(angle+0.5),arrowY-arrowSize*Math.cos(angle+0.5));
            ctx.lineTo(arrowX-arrowSize*Math.sin(angle-0.5),arrowY-arrowSize*Math.cos(angle-0.5));
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
    }
    
    // Draw player
    ctx.fillStyle='#00f2fe';
    ctx.strokeStyle='#ffffff';
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.arc(centerX,centerY,4,0,Math.PI*2);
    ctx.fill();
    ctx.stroke();
    
    // Draw player direction indicator
    const angle=Math.atan2(0,1);
    const arrowLength=8;
    const arrowX=centerX+Math.cos(angle)*arrowLength;
    const arrowY=centerY+Math.sin(angle)*arrowLength;
    ctx.strokeStyle='#00f2fe';
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(centerX,centerY);
    ctx.lineTo(arrowX,arrowY);
    ctx.stroke();
}
clearWaypoint() {
    this.waypoint = null;
}
      }

class AudioManager {
    constructor() {
        this.initialized = false;
        this.lastCollisionTime = 0;
        this.lastBlasterTime = 0;
        this.lastEnemyShotTime = 0;
        this.mineHum = false;
        this.engineRunning = false;
        this.backgroundMusic = null;
        this.sfxSprite = null;
        this.engineSound = null;
        
        // Track playing sounds to prevent spam
        this.activeSounds = new Map();
        this.maxConcurrentSounds = {
            blaster: 3,
            enemyShot: 4,
            explosion: 2,
            collision: 1
        };
        
        this.setup();
    }

    setup() {
        try {
            const spriteMap = {
                blaster: [0, 132],
                enemyShot: [392, 628],
                scatter: [630, 1372],
                shotgun: [242, 553],
                laser: [4252, 4425],
                explosion: [1996, 2527],
                damage: [3092, 3542],
                collision: [6144, 6530],
                enemyHit: [2538, 3034],
                weaponSwitch: [5278, 5573],
                powerUp: [5278, 5573],
                //powerUp: [4517, 5261],
                mine: [5278, 5573],
                landing: [5607, 7007],
                takeoff: [7112, 8414]
            };

            this.sfxSprite = new Howl({
                src: ['sfx-sprite.mp3'],
                sprite: spriteMap,
                volume: 0.7,
                preload: true,
                onloaderror: (id, error) => {
                    console.warn('Failed to load SFX sprite:', error);
                }
            });

            // Remove background music for now as requested
            this.backgroundMusic = null;
            this.engineSound = null;
            
            this.laserActive = false;
            this.laserSoundId = null;
        } catch (error) {
            console.warn('Audio setup failed:', error);
        }
    }

    // Add spatial audio support
    calculateSpatialVolume(sourcePosition, listenerPosition, baseVolume = 1.0, maxDistance = 100) {
        if (!sourcePosition || !listenerPosition) return baseVolume;
        
        const distance = sourcePosition.distanceTo(listenerPosition);
        if (distance >= maxDistance) return 0;
        
        // Linear falloff - closer = louder
        const spatialVolume = Math.max(0, 1 - (distance / maxDistance));
        return baseVolume * spatialVolume;
    }

    // Improved sound management to prevent spam
    canPlaySound(soundType) {
        const maxConcurrent = this.maxConcurrentSounds[soundType] || 1;
        const activeSoundsOfType = this.activeSounds.get(soundType) || [];
        
        // Clean up finished sounds
        const stillPlaying = activeSoundsOfType.filter(soundId => this.sfxSprite.playing(soundId));
        this.activeSounds.set(soundType, stillPlaying);
        
        return stillPlaying.length < maxConcurrent;
    }

    trackSound(soundType, soundId) {
        if (!this.activeSounds.has(soundType)) {
            this.activeSounds.set(soundType, []);
        }
        this.activeSounds.get(soundType).push(soundId);
    }

    playBlaster(sourcePos = null, listenerPos = null) {
        if (!this.initialized || !this.sfxSprite) return;
        
        // Prevent spam
        const currentTime = Date.now();
        if (currentTime - this.lastBlasterTime < 50) return;
        this.lastBlasterTime = currentTime;
        
        if (!this.canPlaySound('blaster')) return;
        
        try {
            const soundId = this.sfxSprite.play('blaster');
            this.trackSound('blaster', soundId);
            
            // Apply spatial audio if positions provided
            if (sourcePos && listenerPos) {
                const volume = this.calculateSpatialVolume(sourcePos, listenerPos, 0.7, 80);
                this.sfxSprite.volume(volume, soundId);
            }
        } catch (e) {}
    }

    playEnemyShot(sourcePos = null, listenerPos = null) {
        if (!this.initialized || !this.sfxSprite) return;
        
        // Prevent spam
        const currentTime = Date.now();
        if (currentTime - this.lastEnemyShotTime < 30) return;
        this.lastEnemyShotTime = currentTime;
        
        if (!this.canPlaySound('enemyShot')) return;
        
        try {
            const soundId = this.sfxSprite.play('enemyShot');
            this.trackSound('enemyShot', soundId);
            
            // Apply spatial audio
            if (sourcePos && listenerPos) {
                const volume = this.calculateSpatialVolume(sourcePos, listenerPos, 0.6, 100);
                this.sfxSprite.volume(volume, soundId);
            }
        } catch (e) {}
    }

    playExplosion(size = 1, sourcePos = null, listenerPos = null) {
        if (!this.initialized || !this.sfxSprite) return;
        
        if (!this.canPlaySound('explosion')) return;
        
        try {
            const soundId = this.sfxSprite.play('explosion');
            this.trackSound('explosion', soundId);
            
            let volume = Math.min(size * 0.7, 1.0);
            
            // Apply spatial audio
            if (sourcePos && listenerPos) {
                volume = this.calculateSpatialVolume(sourcePos, listenerPos, volume, 150);
            }
            
            this.sfxSprite.volume(volume, soundId);
        } catch (e) {}
    }

    playCollision() {
        if (!this.initialized || !this.sfxSprite) return;
        const currentTime = Date.now();
        if (currentTime - this.lastCollisionTime < 300) return; // Increased cooldown
        this.lastCollisionTime = currentTime;
        
        try {
            this.sfxSprite.play('collision');
        } catch (e) {}
    }

    playDamage() {
        if (!this.initialized || !this.sfxSprite) return;
        const currentTime = Date.now();
        if (currentTime - this.lastCollisionTime < 200) return; // Increased cooldown
        this.lastCollisionTime = currentTime;
        
        try {
            this.sfxSprite.play('damage');
        } catch (e) {}
    }

    // Simplified laser audio
    playLaser() {
        if (!this.initialized || !this.sfxSprite || this.laserActive) return;
        
        try {
            this.laserActive = true;
            this.laserSoundId = this.sfxSprite.play('laser');
            this.sfxSprite.loop(true, this.laserSoundId);
            this.sfxSprite.volume(0.5, this.laserSoundId); // Lower volume for laser
        } catch (e) {
            this.laserActive = false;
        }
    }

    stopLaser() {
        if (!this.initialized || !this.sfxSprite || !this.laserActive) return;
        
        try {
            if (this.laserSoundId) {
                this.sfxSprite.stop(this.laserSoundId);
            }
            this.laserActive = false;
            this.laserSoundId = null;
        } catch (e) {
            this.laserActive = false;
        }
    }

    // Keep all other methods unchanged
    start() {
        if (!this.initialized) {
            try {
                this.initialized = true;
            } catch (error) {
                console.warn('Audio start failed:', error);
            }
        }
    }

    dispose() {
        try {
            if (this.sfxSprite) {
                this.sfxSprite.stop();
                this.sfxSprite.unload();
            }
            if (this.backgroundMusic) {
                this.backgroundMusic.stop();
                this.backgroundMusic.unload();
            }
            if (this.engineSound) {
                this.engineSound.stop();
                this.engineSound.unload();
            }
            this.laserActive = false;
            this.engineRunning = false;
        } catch (error) {
            console.warn('Audio disposal error:', error);
        }
    }

    // Keep other methods as they are, just add spatial audio support where needed
    playScatter() { if (this.initialized && this.sfxSprite) try { this.sfxSprite.play('scatter'); } catch (e) {} }
    playShotgun() { if (this.initialized && this.sfxSprite) try { this.sfxSprite.play('shotgun'); } catch (e) {} }
    playEnemyHit() { if (this.initialized && this.sfxSprite) try { this.sfxSprite.play('enemyHit'); } catch (e) {} }
    playWeaponSwitch() { if (this.initialized && this.sfxSprite) try { this.sfxSprite.play('weaponSwitch'); } catch (e) {} }
    playPowerUp() { if (this.initialized && this.sfxSprite) try { this.sfxSprite.play('powerUp'); } catch (e) {} }
    playMine() { if (this.initialized && this.sfxSprite) try { this.sfxSprite.play('mine'); } catch (e) {} }
    playLanding() { if (this.initialized && this.sfxSprite) try { this.sfxSprite.play('landing'); } catch (e) {} }
    playTakeoff() { if (this.initialized && this.sfxSprite) try { this.sfxSprite.play('takeoff'); } catch (e) {} }

    // Stub methods for removed features
    startBackgroundMusic() {}
    stopBackgroundMusic() {}
    pauseBackgroundMusic() {}
    resumeBackgroundMusic() {}
    startEngine() {}
    stopEngine() {}
    setMasterVolume(volume) { try { Howler.volume(Math.max(0, Math.min(1, volume))); } catch (e) {} }
    setSFXVolume(volume) { if (this.sfxSprite) try { this.sfxSprite.volume(Math.max(0, Math.min(1, volume))); } catch (e) {} }
    setMusicVolume(volume) {}
    setEngineVolume(volume) {}
    mute() { try { Howler.mute(true); } catch (e) {} }
    unmute() { try { Howler.mute(false); } catch (e) {} }
}
      class SpaceShooter {
        constructor() {
          this.initializeRenderer();
          this.initializeGameState();
          this.initializeScene();
          this.setupEventListeners();
          this.animate()
        }

        
// 2. Add helper method to find planet by name (add to SpaceShooter class)
findPlanetByName(planetName){
    return this.planets.find(planet => 
        planet.config.dialogue && 
        planet.config.dialogue.name === planetName
    );
}

// 3. Add method to show navigation notification (add to SpaceShooter class)
showNavigationNotification(targetName){
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 30px;
        left: 50%;
        transform: translateX(-50%);
        color: #00ff88;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        font-weight: bold;
        text-shadow: 0 0 15px rgba(0, 255, 136, 0.9);
        background: rgba(0, 0, 0, 0.8);
        padding: 15px 25px;
        border-radius: 10px;
        border: 2px solid rgba(0, 255, 136, 0.6);
        z-index: 1000;
        animation: waypointFadeTop 3s ease-out forwards;
        pointer-events: none;
        backdrop-filter: blur(5px);
    `;
    notification.textContent = `Navigate to: ${targetName}`;
    document.body.appendChild(notification);
    
    setTimeout(() => {
        if (document.body.contains(notification)) {
            document.body.removeChild(notification);
        }
    }, 33000);
}

        updatePlanets() {
          this.planets.forEach(planet => {
            if (planet.destroyed) return;
            planet.currentAngle += planet.orbitSpeed;
            const newX = planet.orbitCenter.x + Math.cos(planet.currentAngle) * planet.orbitDistance;
            const newZ = planet.orbitCenter.z + Math.sin(planet.currentAngle) * planet.orbitDistance;
            planet.mesh.position.set(newX, 0, newZ);
            planet.center.set(newX, 0, newZ);
            planet.mesh.rotation.y += 0.01
          })
        }
        initializeRenderer() {
          this.scene = new THREE.Scene();
          const aspectRatio = window.innerWidth / window.innerHeight;
          const distance = 44;
          this.camera = new THREE.OrthographicCamera(-distance * aspectRatio, distance * aspectRatio, distance, -distance, 0.1, 2000);
          this.renderer = new THREE.WebGLRenderer({
            antialias: !0
          });
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.setClearColor(0x000011);
          this.renderer.sortObjects = !0;
          document.getElementById('gameContainer').appendChild(this.renderer.domElement)
        }
        spawnAlly() {
    const ally = EnemyFactory.create('f', null, 0, 1); // Red fighter ship
    if (!ally) return;
    
    // Position ally near player
    const angle = Math.random() * Math.PI * 2;
    const distance = 15 + Math.random() * 10;
    ally.mesh.position.set(
        this.playerShip.position.x + Math.cos(angle) * distance,
        5,
        this.playerShip.position.z + Math.sin(angle) * distance
    );
    
    // Mark as ally and set properties
    ally.isAlly = true;
    ally.followSide = Math.random() < 0.5 ? -1 : 1; // Random side
    ally.healCooldown = 0;
    ally.targetPosition = new THREE.Vector3();
    
    this.allies.push(ally);
    this.scene.add(ally.mesh);
}
createWaypointIndicator() {
    this.removeWaypointIndicator();
    
    // Create a bigger arrow indicator
    const arrowGeometry = new THREE.ConeGeometry(1.2, 4, 8); // CHANGED: bigger size (was 0.5, 2)
    const arrowMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x6EFFEE, 
        transparent: true, 
        opacity: 0.8 
    });
    this.waypointIndicator = new THREE.Mesh(arrowGeometry, arrowMaterial);
    // REMOVED: this.waypointIndicator.rotation.x = -Math.PI / 2; // Let lookAt handle direction
    this.scene.add(this.waypointIndicator);
}

removeWaypointIndicator() {
    if (this.waypointIndicator) {
        this.scene.remove(this.waypointIndicator);
        this.waypointIndicator = null;
    }
}

updateWaypointIndicator() {
    const waypoint = this.minimapManager.waypoint;
    
    if (!waypoint) {
        this.removeWaypointIndicator();
        return;
    }
    
    // Check if we've reached the waypoint
    const distance = Math.sqrt(
        Math.pow(this.playerShip.position.x - waypoint.x, 2) + 
        Math.pow(this.playerShip.position.z - waypoint.z, 2)
    );
    
    const reachDistance = waypoint.type === 'planet' ? 
        (waypoint.planet ? waypoint.planet.config.radius + 25 : 20) : 20;
    
    if (distance < reachDistance) {
        if (this.waypointReachedCooldown <= 0) {
            this.showWaypointReachedNotification(waypoint);
            this.minimapManager.waypoint = null; // Clear waypoint
            this.removeWaypointIndicator();
            this.waypointReachedCooldown = 180; // 3 second cooldown
        }
        return;
    }
    
    // Create indicator if it doesn't exist
    if (!this.waypointIndicator) {
        this.createWaypointIndicator();
    }
    
    // Position the indicator
    const direction = new THREE.Vector3(
        waypoint.x - this.playerShip.position.x,
        0,
        waypoint.z - this.playerShip.position.z
    ).normalize();
    
    // Place indicator in front of player
    const indicatorDistance = 8;
    this.waypointIndicator.position.copy(this.playerShip.position);
    this.waypointIndicator.position.add(direction.multiplyScalar(indicatorDistance));
    this.waypointIndicator.position.y = 6;
    
    // Point toward waypoint
    // Point toward waypoint - UPDATED FOR PROPER DIRECTION
const waypointTarget = new THREE.Vector3(waypoint.x, this.waypointIndicator.position.y, waypoint.z);
this.waypointIndicator.lookAt(waypointTarget);
this.waypointIndicator.rotateX(Math.PI / 2); // ADDED: Adjust for cone orientation
    
    // Add subtle pulsing animation
    const pulse = 0.8 + 0.2 * Math.sin(Date.now() * 0.005);
    this.waypointIndicator.scale.setScalar(pulse);
    // Animate rings
this.waypointIndicator.children.forEach(child => {
    if (child.userData.ringIndex !== undefined) {
        child.rotation.z += 0.02 * (child.userData.ringIndex + 1);
        child.material.opacity = (0.4 - child.userData.ringIndex * 0.1) * pulse;
    }
});
}

showWaypointReachedNotification(waypoint) {
    // Create subtle notification - POSITIONED NEAR TOP
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 30px;
        left: 50%;
        transform: translateX(-50%);
        color: #feca57;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        font-weight: bold;
        text-shadow: 0 0 15px rgba(254, 202, 87, 0.9);
        background: rgba(0, 0, 0, 0.8);
        padding: 15px 25px;
        border-radius: 10px;
        border: 2px solid rgba(254, 202, 87, 0.6);
        z-index: 1000;
        animation: waypointFadeTop 2s ease-out forwards;
        pointer-events: none;
        backdrop-filter: blur(5px);
    `;
    
    const message = waypoint.type === 'planet' && waypoint.planet?.config.dialogue ?
        `Reached: ${waypoint.planet.config.dialogue.name}` :
        'Waypoint Reached';
    
    notification.textContent = message;
    document.body.appendChild(notification);
    
    // Add CSS animation if not exists - UPDATED ANIMATION NAME
    if (!document.querySelector('#waypointStyles')) {
        const style = document.createElement('style');
        style.id = 'waypointStyles';
        style.textContent = `
            @keyframes waypointFadeTop {
                0% { 
                    opacity: 0; 
                    transform: translateX(-50%) translateY(-20px) scale(0.8); 
                }
                20% { 
                    opacity: 1; 
                    transform: translateX(-50%) translateY(0px) scale(1); 
                }
                80% { 
                    opacity: 1; 
                    transform: translateX(-50%) translateY(0px) scale(1); 
                }
                100% { 
                    opacity: 0; 
                    transform: translateX(-50%) translateY(-10px) scale(1.05); 
                }
            }
        `;
        document.head.appendChild(style);
    }
    
    // Remove notification after animation
    setTimeout(() => {
        if (document.body.contains(notification)) {
            document.body.removeChild(notification);
        }
    }, 2000);
    
    // Play subtle sound
    this.audioManager.playWeaponSwitch();
}
showWaypointSetFeedback(x, y) {
    // Create brief visual feedback for mobile users
    const feedback = document.createElement('div');
    feedback.style.cssText = `
        position: fixed;
        left: ${x}px;
        top: ${y}px;
        width: 20px;
        height: 20px;
        border: 2px solid #feca57;
        border-radius: 50%;
        background: rgba(254, 202, 87, 0.3);
        transform: translate(-50%, -50%);
        z-index: 1001;
        pointer-events: none;
        animation: waypointSetPulse 0.6s ease-out forwards;
    `;
    
    document.body.appendChild(feedback);
    
    // Add CSS if not exists
    if (!document.querySelector('#waypointSetStyles')) {
        const style = document.createElement('style');
        style.id = 'waypointSetStyles';
        style.textContent = `
            @keyframes waypointSetPulse {
                0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
                50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.8; }
                100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
    }
    
    setTimeout(() => {
        if (document.body.contains(feedback)) {
            document.body.removeChild(feedback);
        }
    }, 600);
}
        initializeGameState() {
          this.gameStarted = !1;
          this.trails = [];
          this.allies = [];

    this.waypointIndicator = null; // ADD THIS
    this.waypointReachedCooldown = 0; // ADD THIS
          this.collisionEnabled = !0;
          this.trailStyle = 'nebula';
          this.player = {
            health: CONFIG.player.health,
            score: 0,
            currentWeapon: 1,
            effects: {
              speed: {
                active: !1,
                endTime: 0
              },
              damage: {
                active: !1,
                endTime: 0
              }
            }
          };
          this.keys = {};
          this.bullets = [];
          this.enemyBullets = [];
          this.artifacts = [];
          this.mines = [];
          this.enemies = [];
          this.planets = [];
          this.stars = [];
          this.collisionCooldown = 0;
          this.shootPressed = !1;
          this.playerShip = null;
          this.playerVelocity = new THREE.Vector3();
          this.laserBeam = null;
          this.landingGlow = null;
          this.originalPlayerMaterials = null;
          this.touchControls = {
            moveX: 0,
            moveY: 0,
            firing: !1
          };
          this.audioManager = new AudioManager();
          this.minimapManager = new MinimapManager();
          this.explosions = [];
          this.landingState = 'none';
          this.landingTarget = null;
          this.landingStartPos = null;
          this.landingProgress = 0;
          this.landingDuration = 5000;
          this.landingStartTime = 0;
          this.wasPlayerVisible = !0;
          this.visitedPlanets = new Set();
          this.typewriterSpeed = 7;

        }
        initializeScene() {
          this.camera.position.set(0, 60, 60);
          this.camera.lookAt(0, 0, 0);
          const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
          this.scene.add(ambientLight);
          const directionalLight = new THREE.DirectionalLight(0xffeedd, 0.8);
          directionalLight.position.set(1, 10, 5);
          this.scene.add(directionalLight);
          this.backgroundManager = new BackgroundManager(this.scene);
          this.createPlayer();
          this.createPlanets();
          this.createEnemies();
          this.spawnAlly();
          this.spawnAlly();
          this.spawnAlly();
        }
        createPlayer() {
          this.playerShip = ShipFactory.create('player');
          this.playerShip.position.set(50, 5, 50);
          this.scene.add(this.playerShip)
        }
        createPlanets() {
          const sunConfig = {
            radius: 10,
            color: 0xffdf22,
            distance: 0,
            enemyCount: 0,
            irregularity:0,
               emissive: 0xffffff,        // ðŸ”§ Orange-yellow glow
    emissiveIntensity: 1,    // ðŸ”§ Triggers MeshBasicMaterial
    
    enemyType: 'f',
            health: 1000,
            orbitCenter: {
              x: 0,
              z: 0
            },
            orbitSpeed: 0,
            startAngle: 0
          };
          const sun = PlanetFactory.create(0, sunConfig);
          
          this.planets.push(sun);
          this.scene.add(sun.mesh);
           // Add point light at sun position for realistic lighting
  const sunLight = new THREE.PointLight(0xffaa00, 1, 1000);
  sunLight.position.copy(sun.mesh.position);
  this.scene.add(sunLight);


          for (let i = 0; i < PlanetFactory.configs.length; i++) {
            const planet = PlanetFactory.create(i);
            this.planets.push(planet);
            this.scene.add(planet.mesh)
          }
        }
        createEnemies() {
          this.planets.forEach((planet, planetIndex) => {
            const config = planet.config;
            for (let i = 0; i < config.enemyCount; i++) {
              const enemy = EnemyFactory.create(config.enemyType, planet, i, config.enemyCount);
              if (enemy) {
                this.updateEnemyPosition(enemy);
                this.enemies.push(enemy);
                this.scene.add(enemy.mesh)
              }
            }
          })
        }
        updateEnemyPosition(enemy) {
          const x = enemy.planet.center.x + Math.cos(enemy.angle) * enemy.planet.radius;
          const z = enemy.planet.center.z + Math.sin(enemy.angle) * enemy.planet.radius;
          enemy.mesh.position.set(x, 5, z)
        }
        switchWeapon(weaponNumber) {
    if (weaponNumber >= 1 && weaponNumber <= 5) {
        this.player.currentWeapon = weaponNumber;
        const weaponNames = ['Blaster', 'Scatter', 'Shotgun', 'Mines', 'Laser'];
        document.getElementById('currentWeapon').textContent = `${weaponNumber}-${weaponNames[weaponNumber-1]}`;
        document.getElementById('weaponBtn').innerHTML = `W<br>${weaponNumber}`;
        
        if (this.laserBeam) {
            this.scene.remove(this.laserBeam);
            this.laserBeam = null;
            this.audioManager.stopLaser();
        }
        
        // Use weaponSwitch sound, NOT powerUp
        //this.audioManager.playWeaponSwitch();
    }
}
        cycleWeapon() {
          const nextWeapon = this.player.currentWeapon % 5 + 1;
          this.switchWeapon(nextWeapon)
        }
        isPlanetLandable(planet){
    if(planet.destroyed) return false;
    
    // Don't allow landing on emissive planets (like the sun)
    if(planet.config.emissiveIntensity && planet.config.emissiveIntensity > 0.5) return false;
    
    const livingEnemies = this.enemies.filter(enemy => 
        enemy.planet === planet && enemy.health > 0
    ).length;
    
    return livingEnemies === 0;
}
        renderLandingPrompts() {
          const promptsContainer = document.getElementById('landingPrompts');
          if (!promptsContainer) {
            const container = document.createElement('div');
            container.id = 'landingPrompts';
            container.style.cssText = `position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 150;`;
            document.getElementById('gameContainer').appendChild(container)
          }
          promptsContainer.innerHTML = '';
          if (this.landingState !== 'none') return;
          this.planets.forEach(planet => {
            if (!this.isPlanetLandable(planet)) return;
            const distanceToPlayer = planet.center.distanceTo(this.playerShip.position);
            if (distanceToPlayer > 80) return;
            const vector = planet.center.clone();
            vector.project(this.camera);
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (vector.y * -0.5 + 0.5) * window.innerHeight;
            if (x >= -100 && x <= window.innerWidth + 100 && y >= -100 && y <= window.innerHeight + 100) {
              const planetName = document.createElement('div');
              planetName.style.cssText = `position: absolute;left: ${x}px;top: ${y - 70}px;transform: translateX(-50%);color: #4facfe;font-family: 'Courier New', monospace;font-size: 18px;font-weight: bold;text-shadow: 0 0 15px rgba(79, 172, 254, 0.9);text-align: center;`;
              planetName.textContent = this.getPlanetName(planet);
              promptsContainer.appendChild(planetName);
              const prompt = document.createElement('div');
              prompt.style.cssText = `position: absolute;left: ${x}px;top: ${y - 45}px;transform: translateX(-50%);color: #00ff88;font-family: 'Courier New', monospace;font-size: 14px;font-weight: bold;text-shadow: 0 0 10px rgba(0, 255, 136, 0.8);background: rgba(0, 0, 0, 0.8);padding: 6px 14px;border-radius: 15px;border: 2px solid rgba(0, 255, 136, 0.6);animation: landingPulse 2s infinite;backdrop-filter: blur(3px);pointer-events: auto;cursor: pointer;user-select: none;`;
              prompt.textContent = 'Press [E] to Land';
              prompt.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.startLanding()
              });
              prompt.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.startLanding()
              });
              promptsContainer.appendChild(prompt)
            }
          })
        }
        startLanding() {
          if (this.landingState !== 'none') return;
          let nearestPlanet = null;
          let nearestDistance = Infinity;
          this.planets.forEach(planet => {
            if (!this.isPlanetLandable(planet)) return;
            const distance = planet.center.distanceTo(this.playerShip.position);
            if (distance < 80 && distance < nearestDistance) {
              nearestDistance = distance;
              nearestPlanet = planet
            }
          });
          if (!nearestPlanet) return;
          this.landingState = 'landing';
          this.landingTarget = nearestPlanet;
          this.landingStartPos = this.playerShip.position.clone();
          this.landingStartTime = Date.now();
          this.landingProgress = 0;
          this.wasPlayerVisible = this.playerShip.visible;
          this.audioManager.playLanding()
        }
        updateLanding() {
          if (this.landingState === 'none') return;
          // Safety check - if landing target is null, reset landing state
          if (!this.landingTarget || !this.landingTarget.center) {
            console.warn('Landing target is null, resetting landing state');
            this.landingState = 'none';
            this.landingTarget = null;
            this.removeLandingGlow();
            this.collisionEnabled = true;
            // Ensure player is visible and properly positioned
            if (this.playerShip) {
              this.playerShip.visible = true;
              this.playerShip.scale.setScalar(1.0);
            }
            return;
          }
          const currentTime = Date.now();
          const elapsedTime = currentTime - this.landingStartTime;
          this.landingProgress = Math.min(elapsedTime / this.landingDuration, 1);
          if (this.landingState === 'landing') {
            this.collisionEnabled = false;
            if (this.landingProgress >= 1) {
              this.removeLandingGlow();
              this.restorePlayerDepth();
              this.landingState = 'landed';
              this.showDialogue();
              return;
            }
            this.playerShip.visible = true;
            const planetCenter = this.landingTarget.center.clone();
            const targetPos = planetCenter.clone();
            const currentPos = this.landingStartPos.clone().lerp(targetPos, this.easeInOutCubic(this.landingProgress));
            this.playerShip.position.copy(currentPos);
            this.makePlayerAlwaysVisible();
            this.createLandingGlow();
            const scale = 1.0 - (this.landingProgress * 0.95);
            this.playerShip.scale.setScalar(Math.max(0.05, scale));
            const planetRadius = this.landingTarget.config.radius;
            const cameraDistance = planetRadius * 2.2;
            const cameraHeight = planetRadius * 1.2;
            const cameraAngle = this.landingProgress * 0.3;
            const cameraPos = new THREE.Vector3(planetCenter.x + Math.cos(cameraAngle) * cameraDistance, planetCenter.y + cameraHeight, planetCenter.z + Math.sin(cameraAngle) * cameraDistance);
            this.camera.position.copy(cameraPos);
            this.camera.lookAt(currentPos);
            this.playerVelocity.set(0, 0, 0);
          } else if (this.landingState === 'taking_off') {
            this.collisionEnabled = false;
            if (this.landingProgress >= 1) {
              this.landingState = 'none';
              this.removeLandingGlow();
              this.restorePlayerDepth();
              this.playerShip.visible = this.wasPlayerVisible;
              this.scheduleCollisionReactivation();
              return;
            }
            const planetCenter = this.landingTarget.center.clone();
            const safeDistance = this.landingTarget.config.radius + 20;
            let bestDirection = this.findSafeTakeoffDirection(planetCenter);
            const endPos = planetCenter.clone().add(bestDirection.multiplyScalar(safeDistance));
            endPos.y = 5;
            this.makePlayerAlwaysVisible();
            this.createLandingGlow();
            const startCameraPos = new THREE.Vector3(planetCenter.x, planetCenter.y + 20, planetCenter.z + 30);
            const endCameraPos = new THREE.Vector3(endPos.x, 60, endPos.z + 60);
            const progress = this.easeInOutCubic(this.landingProgress);
            const currentCameraPos = startCameraPos.clone().lerp(endCameraPos, progress);
            this.camera.position.copy(currentCameraPos);
            const currentPlayerPos = planetCenter.clone().lerp(endPos, progress);
            this.playerShip.position.copy(currentPlayerPos);
            const scale = 0.05 + (this.landingProgress * 0.95);
            this.playerShip.scale.setScalar(scale);
            if (this.landingProgress > 0.98) {
              this.playerShip.scale.setScalar(1.0);
            }
            this.playerShip.visible = this.wasPlayerVisible;
            this.camera.lookAt(this.playerShip.position);
          }
        }
        findSafeTakeoffDirection(planetCenter) {
          const testDirections = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1), new THREE.Vector3(0.707, 0, 0.707), new THREE.Vector3(-0.707, 0, 0.707), new THREE.Vector3(0.707, 0, -0.707), new THREE.Vector3(-0.707, 0, -0.707)];
          let bestDirection = testDirections[0];
          let maxMinDistance = 0;
          for (let direction of testDirections) {
            const testPoint = planetCenter.clone().add(direction.clone().multiplyScalar(this.landingTarget.config.radius + 25));
            let minDistance = Infinity;
            for (let planet of this.planets) {
              if (planet === this.landingTarget || planet.destroyed) continue;
              const distance = testPoint.distanceTo(planet.center) - planet.config.radius;
              minDistance = Math.min(minDistance, distance)
            }
            if (minDistance > maxMinDistance) {
              maxMinDistance = minDistance;
              bestDirection = direction
            }
          }
          return bestDirection.normalize()
        }
        scheduleCollisionReactivation() {
          let consecutiveFramesAtSafeDistance = 0;
          const requiredFrames = 10;
          const checkDistance = () => {
            // Safety check
            if (!this.landingTarget || !this.landingTarget.center) {
              this.collisionEnabled = true;
              this.landingTarget = null;
              return;
            }
            const distanceFromPlanet = this.playerShip.position.distanceTo(this.landingTarget.center);
            const safeDistance = this.landingTarget.config.radius + 15;
            const playerToPlanet = new THREE.Vector3().subVectors(this.landingTarget.center, this.playerShip.position);
            const isMovingAway = this.playerVelocity.dot(playerToPlanet) < 0;
            if (distanceFromPlanet > safeDistance && (isMovingAway || this.playerVelocity.length() < 0.1)) {
              consecutiveFramesAtSafeDistance++;
              if (consecutiveFramesAtSafeDistance >= requiredFrames) {
                this.collisionEnabled = true;
                this.landingTarget = null;
                return;
              }
            } else {
              consecutiveFramesAtSafeDistance = 0;
            }
            requestAnimationFrame(checkDistance);
          };
          requestAnimationFrame(checkDistance);
        }
        easeInOutCubic(t) {
          return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2
        }
        easeInOutQuad(t) {
          return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t
        }
        showDialogue() {
          const dialogueSystem = document.getElementById('dialogueSystem');
          if (!dialogueSystem) {
            const dialogue = document.createElement('div');
            dialogue.id = 'dialogueSystem';
            dialogue.className = 'hidden';
            dialogue.innerHTML = `
                                                                                
              <div id="dialogueBox">
                <div id="dialogueContent">
                  <div id="planetImage"></div>
                  <h3 id="dialogueTitle">Planet</h3>
                  <p id="dialogueText"></p>
                  <div id="dialogueOptions">
                    <button class="dialogue-btn" onclick="game.closeDialogue()">Take Off</button>
                  </div>
                </div>
              </div>`;
            document.getElementById('gameContainer').appendChild(dialogue)
          }
          document.getElementById('dialogueSystem').classList.remove('hidden');
          const planetConfig = this.landingTarget.config;
          const dialogue = planetConfig.dialogue;
          //document.getElementById('planetImage').textContent = dialogue.image || 'ðŸª';
          function setPlanetImage(dialogue) {
  const planetImageElement = document.getElementById('planetImage');
  
  if (!planetImageElement) {
    console.error('Element with id "planetImage" not found');
    return;
  }
  
  const imageContent = dialogue.image || 'ðŸª';
  
  // Limpiar el contenido actual
  planetImageElement.innerHTML = '';
  
  // Verificar si es una ruta de imagen (mÃ¡s flexible)
  const isImagePath = imageContent.includes('/') || /\.(jpg|jpeg|png|gif|webp|svg)$/i.test(imageContent);
  
  if (isImagePath) {
    // Crear elemento img para rutas de imagen
    const imgElement = document.createElement('img');
    imgElement.src = imageContent;
    imgElement.alt = dialogue.name || 'Planet';
    imgElement.style.cssText = `
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      display: block;
    `;
    
    // Manejar error de carga - fallback al emoji por defecto
    imgElement.onerror = () => {
      console.warn(`Failed to load image: ${imageContent}`);
      planetImageElement.innerHTML = '';
      planetImageElement.textContent = 'ðŸª';
    };
    
    // Confirmar que la imagen se estÃ¡ cargando
    imgElement.onload = () => {
      console.log(`Image loaded successfully: ${imageContent}`);
    };
    
    planetImageElement.appendChild(imgElement);
  } else {
    // Si no es una ruta de imagen, usar como emoji/texto
    planetImageElement.textContent = imageContent;
  }
}
 setPlanetImage(dialogue);
          document.getElementById('dialogueTitle').textContent = `${dialogue.name}`;
          let dialogueText = dialogue.baseText;
          if (dialogue.flagTexts) {
            for (const [flag, text] of Object.entries(dialogue.flagTexts)) {
              if (this.visitedPlanets.has(flag)) {
                dialogueText += ' ' + text;
                break
              }
            }
          }
          this.typeWriter(dialogueText, 'dialogueText');
          const planetKey = `visited_${dialogue.name.toLowerCase().replace(/[^a-z]/g,'')}`;
          this.visitedPlanets.add(planetKey)
        }
        typeWriter(text, elementId, index = 0) {
  const element = document.getElementById(elementId);
  if (index === 0) element.textContent = '';
  
  if (index < text.length) {
    element.textContent += text.charAt(index);
    
    // Auto-scroll to bottom to show newly typed content
    element.scrollTop = element.scrollHeight;
    
    setTimeout(() => this.typeWriter(text, elementId, index + 1), this.typewriterSpeed);
  }
}
        closeDialogue(){
    const currentPlanet = this.landingTarget;
    const storyWaypoint = currentPlanet.config.dialogue?.setStoryWaypoint;
    
    document.getElementById('dialogueSystem').classList.add('hidden');
    this.landingState = 'taking_off';
    this.landingStartTime = Date.now();
    this.landingProgress = 0;
    this.playerShip.visible = false;
    
    // Set story waypoint based on type (coordinates or planet name)
    if (storyWaypoint) {
        let waypointData = null;
        let displayName = '';
        
        // Check if it's coordinates (object with x, z properties)
        if (typeof storyWaypoint === 'object' && storyWaypoint.x !== undefined && storyWaypoint.z !== undefined) {
            waypointData = {
                x: storyWaypoint.x,
                z: storyWaypoint.z,
                type: 'static'
            };
            displayName = `Coordinates (${storyWaypoint.x}, ${storyWaypoint.z})`;
        }
        // Otherwise treat as planet name
        else if (typeof storyWaypoint === 'string') {
            const targetPlanet = this.findPlanetByName(storyWaypoint);
            if (targetPlanet) {
                waypointData = {
                    x: targetPlanet.center.x,
                    z: targetPlanet.center.z,
                    planet: targetPlanet,
                    type: 'planet'
                };
                displayName = storyWaypoint;
            }
        }
        
        // Set the waypoint and show notification
        if (waypointData) {
            this.minimapManager.waypoint = waypointData;
            
            // Show navigation notification after a short delay
            setTimeout(() => {
                this.showNavigationNotification(displayName);
                //this.audioManager.playWeaponSwitch(); // Reuse power-up sound
            }, 100);
        }
    }
}
        getPlanetName(planet) {
          return planet.config.dialogue?.name || `Planet ${this.planets.indexOf(planet) + 1}`
        }
        fireWeapon() {
          switch (this.player.currentWeapon) {
            case 1:
              this.fireBlaster();
              break;
            case 2:
              this.fireScatter(3);
              break;
            case 3:
              this.fireScatter(5);
              break;
            case 4:
              this.fireMine();
              break;
            case 5:
              this.fireLaser();
              break
          }
        }
        fireBlaster() {
    this.createBullet(0);
    this.audioManager.playBlaster(this.playerShip.position, this.playerShip.position); // Same position for player sounds
}

        fireScatter(count) {
          const spreadAngle = Math.PI / 6;
          for (let i = 0; i < count; i++) {
            const angleOffset = (i - (count - 1) / 2) * (spreadAngle / (count - 1));
            this.createBullet(angleOffset)
          }
          if (count === 3) {
            this.audioManager.playScatter()
          } else {
            this.audioManager.playShotgun()
          }
        }
        createBullet(angleOffset = 0) {
          try {
            const bulletGeom = new THREE.SphereGeometry(0.2, 8, 8);
            const bulletMat = new THREE.MeshBasicMaterial({
              color: 0x00f2fe
            });
            const bullet = new THREE.Mesh(bulletGeom, bulletMat);
            if (!this.playerShip || !this.playerShip.position) {
              console.warn('Player ship not available for bullet creation');
              return;
            }
            bullet.position.copy(this.playerShip.position);
            bullet.position.y += 0.5;
            const direction = new THREE.Vector3(Math.sin(this.playerShip.rotation.y + angleOffset), 0, Math.cos(this.playerShip.rotation.y + angleOffset));
            const bulletVelocity = direction.clone().multiplyScalar(CONFIG.bullet.speed);
            const bulletObject = {
              mesh: bullet,
              velocity: bulletVelocity,
              life: CONFIG.bullet.life
            };
            this.bullets.push(bulletObject);
            this.scene.add(bullet);
          } catch (e) {
            console.error('Failed to create bullet:', e);
          }
        }
        fireMine() {
          const mineGeom = new THREE.SphereGeometry(0.5, 8, 8);
          const mineMat = new THREE.MeshBasicMaterial({
            color: 0xff4757,
            transparent: !0,
            opacity: 0.8
          });
          const mine = new THREE.Mesh(mineGeom, mineMat);
          mine.position.copy(this.playerShip.position);
          mine.position.y += 0.5;
          this.mines.push({
            mesh: mine,
            life: 600,
            exploded: !1
          });
          this.scene.add(mine);
          this.audioManager.playMine()
        }
        fireLaser() {
          if (this.laserBeam) {
            this.scene.remove(this.laserBeam)
          }
          const direction = new THREE.Vector3(Math.sin(this.playerShip.rotation.y), 0, Math.cos(this.playerShip.rotation.y));
          const laserEnd = this.playerShip.position.clone().add(direction.clone().multiplyScalar(CONFIG.weapons.laser.maxDist));
          const laserGeom = new THREE.BufferGeometry().setFromPoints([this.playerShip.position.clone().add(new THREE.Vector3(0, 0.5, 0)), laserEnd]);
          const laserMat = new THREE.LineBasicMaterial({
            color: 0x00ff00,
            transparent: !0,
            opacity: 0.8
          });
          this.laserBeam = new THREE.Line(laserGeom, laserMat);
          this.scene.add(this.laserBeam);
          this.audioManager.playLaser();
          let hitSomething = !1;
          const damage = this.player.effects.damage.active ? CONFIG.weapons.laser.damage * CONFIG.audio.damage.mult : CONFIG.weapons.laser.damage;
          this.enemies.forEach(enemy => {
            if (enemy.health > 0) {
              const distanceToLine = this.distancePointToLine(enemy.mesh.position, this.playerShip.position, laserEnd);
              if (distanceToLine < 2) {
                enemy.health -= damage;
                hitSomething = !0;
                if (enemy.health <= 0) {
                  this.createExplosion(enemy.mesh.position);
                  this.audioManager.playExplosion();
                  enemy.mesh.visible = !1;
                  this.player.score += enemy.score;
                  this.dropArtifact(enemy.mesh.position);
                  this.updateHUD()
                } else {
                  this.audioManager.playEnemyHit()
                }
              }
            }
          });
          this.planets.forEach(planet => {
            if (!planet.destroyed) {
              const distanceToLine = this.distancePointToLine(planet.center, this.playerShip.position, laserEnd);
              if (distanceToLine < planet.config.radius) {
                planet.health -= damage;
                hitSomething = !0;
                if (planet.health <= 0) {
                  this.destroyPlanet(planet)
                }
              }
            }
          })
        }
        distancePointToLine(point, lineStart, lineEnd) {
          const lineDir = new THREE.Vector3().subVectors(lineEnd, lineStart);
          const pointToStart = new THREE.Vector3().subVectors(point, lineStart);
          const t = Math.max(0, Math.min(1, pointToStart.dot(lineDir) / lineDir.dot(lineDir)));
          const projection = lineStart.clone().add(lineDir.multiplyScalar(t));
          return point.distanceTo(projection)
        }
        makePlayerAlwaysVisible() {
          if (!this.originalPlayerMaterials) {
            this.originalPlayerMaterials = [];
            this.playerShip.traverse((child) => {
              if (child.isMesh) {
                this.originalPlayerMaterials.push({
                  mesh: child,
                  material: child.material.clone()
                })
              }
            })
          }
          this.playerShip.traverse((child) => {
            if (child.isMesh) {
              child.material.depthTest = !1;
              child.material.depthWrite = !1;
              child.renderOrder = 999
            }
          });
          this.playerShip.renderOrder = 999
        }
        restorePlayerDepth() {
          if (this.originalPlayerMaterials) {
            this.originalPlayerMaterials.forEach(({
              mesh,
              material
            }) => {
              mesh.material.depthTest = !0;
              mesh.material.depthWrite = !0;
              mesh.renderOrder = 0
            });
            this.playerShip.renderOrder = 0
          }
        }
        createLandingGlow() {
          this.removeLandingGlow();
          this.landingGlow = this.playerShip.clone();
          this.landingGlow.scale.multiplyScalar(1.3);
          this.landingGlow.traverse((child) => {
            if (child.isMesh) {
              child.material = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: !0,
                opacity: 0.4,
                side: THREE.DoubleSide,
                depthTest: !1,
                depthWrite: !1
              });
              child.renderOrder = 998
            }
          });
          this.landingGlow.renderOrder = 998;
          this.scene.add(this.landingGlow)
        }
        removeLandingGlow() {
          if (this.landingGlow) {
            this.scene.remove(this.landingGlow);
            this.landingGlow = null
          }
        }
        updateLandingGlowEffect() {
          if (this.landingGlow && this.playerShip) {
            this.landingGlow.position.copy(this.playerShip.position);
            this.landingGlow.rotation.copy(this.playerShip.rotation);
            const baseScale = this.playerShip.scale.x * 1.3;
            this.landingGlow.scale.setScalar(baseScale);
            const pulseIntensity = 0.2 + 0.8 * Math.sin(Date.now() * 0.008);
            this.landingGlow.traverse((child) => {
              if (child.isMesh && child.material) {
                child.material.opacity = 0.2 + pulseIntensity * 0.4;
                const hue = (Date.now() * 0.001) % 1;
                child.material.color.setHSL(0.5 + hue * 0.2, 1, 0.6)
              }
            })
          }
        }
        update() {
          if (!this.gameStarted) return;
          this.updateLanding();
          this.updateLandingGlowEffect();
          this.renderLandingPrompts();
          if (this.landingState === 'none' || this.landingState === 'landed') {
            this.updatePlayer()
          }
          this.updateTrails();
          this.updatePlanets();
          this.updateEnemies();
          this.updateAllies();
          this.updateBullets();
          this.updateEnemyBullets();
          this.updateArtifacts();
          this.updateMines();
          this.updateCollisions();
          this.updateBackground();
          this.updateEffects();
           this.minimapManager.updateWaypoint(); // Update planet waypoints
    this.updateWaypointIndicator(); // Update 3D indicator
    if (this.waypointReachedCooldown > 0) this.waypointReachedCooldown--;
          this.updateMinimap();
          this.updateExplosions()
        }
        updateAllies() {
    this.allies = this.allies.filter(ally => {
        if (ally.health <= 0) {
            this.scene.remove(ally.mesh);
            return false;
        }
        
        const distanceToPlayer = ally.mesh.position.distanceTo(this.playerShip.position);
        const combatRadius = 40;
        const followDistance = 25;
        
        // Find nearby enemies
        const nearbyEnemies = this.enemies.filter(enemy => 
            enemy.health > 0 && 
            enemy.mesh.position.distanceTo(this.playerShip.position) < combatRadius
        );
        
        let moveDirection = new THREE.Vector3();
        
        if (nearbyEnemies.length > 0) {
            // Combat mode - attack nearest enemy
            const target = nearbyEnemies.reduce((nearest, enemy) => 
                enemy.mesh.position.distanceTo(ally.mesh.position) < 
                nearest.mesh.position.distanceTo(ally.mesh.position) ? enemy : nearest
            );
            
            moveDirection.subVectors(target.mesh.position, ally.mesh.position).normalize();
            ally.mesh.position.add(moveDirection.multiplyScalar(0.9));
            
            // Shoot at enemy
            ally.shootCooldown--;
            if (ally.shootCooldown <= 0) {
                this.createAllyBullet(ally, target);
                ally.shootCooldown = 40;
            }
        } else {
            // Follow/heal mode
            if (distanceToPlayer > followDistance) {
                // Follow player directly when too far
                moveDirection.subVectors(this.playerShip.position, ally.mesh.position).normalize();
                ally.mesh.position.add(moveDirection.multiplyScalar(0.8));
            } else {
               // Stay in formation behind and to side with improved positioning
const baseDistance = 15 + (ally.followSide * 2); // Vary distance per ally
const sideAngle = ally.followSide * Math.PI/3 + (Math.sin(Date.now() * 0.001 + ally.followSide) * 0.1); // Slight dynamic movement

const behindOffset = new THREE.Vector3(
    Math.sin(this.playerShip.rotation.y + sideAngle) * baseDistance,
    Math.sin(Date.now() * 0.002 + ally.followSide * 2) * 0.5, // Subtle vertical bobbing
    Math.cos(this.playerShip.rotation.y + sideAngle) * baseDistance
);

ally.targetPosition.copy(this.playerShip.position).add(behindOffset);

const distanceToTarget = ally.mesh.position.distanceTo(ally.targetPosition);
if (distanceToTarget > 2) {
    moveDirection.subVectors(ally.targetPosition, ally.mesh.position).normalize();
    
    // Improved movement with better speed scaling and smoothing
    const moveSpeed = Math.min(0.4, distanceToTarget * 0.15) * (0.8 + Math.random() * 0.4);
    ally.mesh.position.add(moveDirection.multiplyScalar(moveSpeed));
    
    // Smooth rotation towards movement direction
    const targetRotation = Math.atan2(moveDirection.x, moveDirection.z);
    ally.mesh.rotation.y += (targetRotation - ally.mesh.rotation.y) * 0.1;
}
            }
            
            // Heal player with visual effect
            ally.healCooldown--;
            if (ally.healCooldown <= 0 && this.player.health < CONFIG.player.health) {
                this.player.health = Math.min(CONFIG.player.health, this.player.health + 5);
                ally.healCooldown = 30;
                this.updateHUD();
                
                // Create healing beam visual
                this.createHealingBeam(ally, this.playerShip);
            }
        }
        
        // Always rotate to face movement direction
        if (moveDirection.length() > 0.1) {
            const targetRotation = Math.atan2(moveDirection.x, moveDirection.z);
            ally.mesh.rotation.y = targetRotation;
        } else if (nearbyEnemies.length === 0) {
            // Face same direction as player when in formation
            ally.mesh.rotation.y = this.playerShip.rotation.y;
        }
        const avoidanceRadius = 13;
this.allies.forEach(otherAlly => {
    if (otherAlly === ally) return;
    const distance = ally.mesh.position.distanceTo(otherAlly.mesh.position);
    if (distance < avoidanceRadius && distance > 0) {
        const avoidDirection = new THREE.Vector3()
            .subVectors(ally.mesh.position, otherAlly.mesh.position)
            .normalize()
            .multiplyScalar((avoidanceRadius - distance) * 1);
        ally.mesh.position.add(avoidDirection);
    }
});
        ally.mesh.position.y = 5;
        return true;
    });
}
createAllyBullet(ally, target) {
    const bulletGeom = new THREE.SphereGeometry(0.3, 8, 8);
    const bulletMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const bullet = new THREE.Mesh(bulletGeom, bulletMat);
    bullet.position.copy(ally.mesh.position);
    bullet.position.y += 0.5;
    const direction = new THREE.Vector3().subVectors(target.mesh.position, ally.mesh.position).normalize();
    const bulletVelocity = direction.multiplyScalar(CONFIG.bullet.speed * 1.5);
    
    this.bullets.push({
        mesh: bullet,
        velocity: bulletVelocity,
        life: CONFIG.bullet.life,
        isAlly: true,
        damage: 25
    });
    this.scene.add(bullet);
    
    // Add spatial audio for ally shots
    this.audioManager.playBlaster(ally.mesh.position, this.playerShip.position);
}
        createTrail() {
          if (Math.random() > 0.3) return;
          const trailCount = 3;
          const coneAngle = Math.PI / 4;
          const behindDistance = 3;
          for (let i = 0; i < trailCount; i++) {
            const spreadAngle = (Math.random() - 0.5) * coneAngle;
            const playerAngle = this.playerShip.rotation.y + Math.PI;
            const finalAngle = playerAngle + spreadAngle;
            const distance = behindDistance + Math.random() * 2;
            const x = this.playerShip.position.x + Math.sin(finalAngle) * distance;
            const z = this.playerShip.position.z + Math.cos(finalAngle) * distance;
            const noiseValue = new PerlinNoise().noise(x * 0.1, z * 0.1, Date.now() * 0.001);
            const intensity = Math.abs(noiseValue);
            const trailGeom = new THREE.SphereGeometry(0.3 + intensity * 0.5, 6, 6);
            const hue = (intensity * 360 + 200) % 360;
            const trailMat = new THREE.MeshBasicMaterial({
              color: new THREE.Color().setHSL(hue / 360, 0.8, 0.6),
              transparent: !0,
              opacity: 0.7
            });
            const trail = new THREE.Mesh(trailGeom, trailMat);
            trail.position.set(x, 4 + Math.random(), z);
            this.trails.push({
              mesh: trail,
              life: 60 + Math.random() * 40,
              maxLife: 60 + Math.random() * 40
            });
            this.scene.add(trail)
          }
        }
        updateTrails() {
          this.trails = this.trails.filter(trail => {
            trail.life--;
            const fadeRatio = trail.life / trail.maxLife;
            trail.mesh.material.opacity = fadeRatio * 0.7;
            trail.mesh.scale.setScalar(fadeRatio);
            if (trail.life <= 0) {
              this.scene.remove(trail.mesh);
              return !1
            }
            return !0
          })
        }
        updatePlayer() {
          let moveX = 0,
            moveZ = 0;
          if (this.keys.KeyW || this.keys.ArrowUp || this.touchControls.moveY < -0.3) moveZ -= 1;
          if (this.keys.KeyS || this.keys.ArrowDown || this.touchControls.moveY > 0.3) moveZ += 1;
          if (this.keys.KeyA || this.keys.ArrowLeft || this.touchControls.moveX < -0.3) moveX -= 1;
          if (this.keys.KeyD || this.keys.ArrowRight || this.touchControls.moveX > 0.3) moveX += 1;
          if (moveX !== 0 || moveZ !== 0) {
            if (moveX !== 0 && moveZ !== 0) {
              moveX *= Math.SQRT1_2;
              moveZ *= Math.SQRT1_2
            }
            const speedMultiplier = this.player.effects.speed.active ? CONFIG.audio.speed.mult : 1;
            this.playerVelocity.x += moveX * CONFIG.player.acc * speedMultiplier;
            this.playerVelocity.z += moveZ * CONFIG.player.acc * speedMultiplier
          }
          this.playerVelocity.multiplyScalar(CONFIG.player.friction);
          const maxSpeed = CONFIG.player.maxSpeed * (this.player.effects.speed.active ? CONFIG.audio.speed.mult : 1);
          const clampedVelocity = this.playerVelocity.clone().clampLength(0, maxSpeed);
          this.playerVelocity.copy(clampedVelocity);
          const newPosition = this.playerShip.position.clone().add(this.playerVelocity);
          if (!this.checkPlanetCollision(newPosition, !0)) {
            this.playerShip.position.copy(newPosition);
            this.playerShip.position.y = 5
          }
          if (this.playerVelocity.length() > 0.1) {
            this.createTrail()
          }
          if (this.playerVelocity.length() > 0.1) {
            const angle = Math.atan2(this.playerVelocity.x, this.playerVelocity.z);
            this.playerShip.rotation.y = angle
          }
          if ((this.keys.Space && !this.shootPressed) || this.touchControls.firing) {
            this.fireWeapon();
            this.shootPressed = !0
          } else if (!this.keys.Space && !this.touchControls.firing) {
            this.shootPressed = !1;
            if (this.laserBeam) {
              this.scene.remove(this.laserBeam);
              this.laserBeam = null;
              this.audioManager.stopLaser()
            }
          }
          const targetCameraX = this.playerShip.position.x;
          const targetCameraZ = this.playerShip.position.z + 60;
          const cameraPosition = new THREE.Vector3(targetCameraX, 60, targetCameraZ);
          if (!this.checkCameraCollision(cameraPosition)) {
            this.camera.position.copy(cameraPosition)
          } else {
            this.adjustCameraForCollision()
          }
          this.camera.lookAt(this.playerShip.position);
          this.updateCoordinates()
        }
        updateEnemies() {
          this.enemies.forEach(enemy => {
            if (enemy.health <= 0 || enemy.stuck) return;
            const distanceToPlayer = enemy.mesh.position.distanceTo(this.playerShip.position);
            enemy.shootCooldown--;
            if (distanceToPlayer < enemy.attackRange && !enemy.attacking) {
              enemy.attacking = !0;
              enemy.retreating = !1
            }
            if (enemy.attacking) {
              const distanceToPlayer = enemy.mesh.position.distanceTo(this.playerShip.position);
              const avoidanceForce = this.calculateEnemyAvoidance(enemy);
              if (distanceToPlayer > CONFIG.enemy.minDistance * 1.5) {
                const directionToPlayer = new THREE.Vector3().subVectors(this.playerShip.position, enemy.mesh.position).normalize();
                const combinedDirection = directionToPlayer.add(avoidanceForce).normalize();
                const moveDistance = Math.min(enemy.chaseSpeed, distanceToPlayer - CONFIG.enemy.minDistance);
                const movement = combinedDirection.multiplyScalar(moveDistance);
                const newPosition = enemy.mesh.position.clone().add(movement);
                if (!this.checkPlanetCollision(newPosition)) {
                  enemy.mesh.position.copy(newPosition);
                  enemy.mesh.position.y = 5
                }
              } else {
                const tangentAngle = Math.atan2(this.playerShip.position.z - enemy.mesh.position.z, this.playerShip.position.x - enemy.mesh.position.x) + Math.PI / 2;
                const circleDirection = new THREE.Vector3(Math.cos(tangentAngle), 0, Math.sin(tangentAngle));
                const combinedDirection = circleDirection.add(avoidanceForce.multiplyScalar(2)).normalize();
                const movement = combinedDirection.multiplyScalar(enemy.chaseSpeed * 0.7);
                const newPosition = enemy.mesh.position.clone().add(movement);
                if (!this.checkPlanetCollision(newPosition)) {
                  enemy.mesh.position.copy(newPosition);
                  enemy.mesh.position.y = 5
                }
              }
              enemy.mesh.lookAt(this.playerShip.position);
              if (enemy.shootCooldown <= 0 && distanceToPlayer < 30 && distanceToPlayer > CONFIG.enemy.minDistance * 0.8) {
                this.enemyShoot(enemy);
                enemy.shootCooldown = this.getShootCooldown(enemy.weaponType)
              }
              if (distanceToPlayer > enemy.attackRange * 2.5) {
                enemy.attacking = !1;
                enemy.retreating = !0
              }
            } else if (enemy.retreating) {
              if (distanceToPlayer < enemy.attackRange * 1.2) {
                enemy.attacking = !0;
                enemy.retreating = !1;
                return
              }
              const targetPosition = new THREE.Vector3(enemy.planet.center.x + Math.cos(enemy.originalAngle) * enemy.planet.radius, 5, enemy.planet.center.z + Math.sin(enemy.originalAngle) * enemy.planet.radius);
              const distanceToTarget = enemy.mesh.position.distanceTo(targetPosition);
              if (distanceToTarget > 2) {
                const direction = new THREE.Vector3().subVectors(targetPosition, enemy.mesh.position).normalize().multiplyScalar(CONFIG.enemy.retSpeed);
                const newPos = enemy.mesh.position.clone().add(direction);
                newPos.y = 5;
                enemy.mesh.position.copy(newPos);
                const lookAhead = enemy.mesh.position.clone().add(direction);
                enemy.mesh.lookAt(lookAhead)
              } else {
                enemy.retreating = !1;
                enemy.angle = enemy.originalAngle
              }
            } else {
              enemy.angle += enemy.speed;
              this.updateEnemyPosition(enemy);
              const nextAngle = enemy.angle + enemy.speed;
              const nextX = enemy.planet.center.x + Math.cos(nextAngle) * enemy.planet.radius;
              const nextZ = enemy.planet.center.z + Math.sin(nextAngle) * enemy.planet.radius;
              const nextPosition = new THREE.Vector3(nextX, 5, nextZ);
              enemy.mesh.lookAt(nextPosition)
            }
          })
        }
        calculateEnemyAvoidance(currentEnemy) {
          const avoidanceForce = new THREE.Vector3();
          let neighborCount = 0;
          this.enemies.forEach(otherEnemy => {
            if (otherEnemy === currentEnemy || otherEnemy.health <= 0) return;
            const distance = currentEnemy.mesh.position.distanceTo(otherEnemy.mesh.position);
            const avoidanceRadius = 12;
            if (distance < avoidanceRadius && distance > 0) {
              const repelDirection = new THREE.Vector3().subVectors(currentEnemy.mesh.position, otherEnemy.mesh.position);
              const repelStrength = Math.max(0.3, (avoidanceRadius - distance) / avoidanceRadius * 2);
              repelDirection.normalize().multiplyScalar(repelStrength);
              avoidanceForce.add(repelDirection);
              neighborCount++
            }
          });
          const playerDistance = currentEnemy.mesh.position.distanceTo(this.playerShip.position);
          if (playerDistance < CONFIG.enemy.minDistance) {
            const repelFromPlayer = new THREE.Vector3().subVectors(currentEnemy.mesh.position, this.playerShip.position);
            const repelStrength = Math.max(0.5, (CONFIG.enemy.minDistance - playerDistance) / CONFIG.enemy.minDistance * 3);
            repelFromPlayer.normalize().multiplyScalar(repelStrength);
            avoidanceForce.add(repelFromPlayer)
          }
          if (neighborCount > 0) {
            avoidanceForce.divideScalar(Math.max(1, neighborCount * 0.5))
          }
          return avoidanceForce
        }
        enemyShoot(enemy) {
    const weaponTypes = {
        'rapid': () => {
            this.createEnemyBullet(enemy);
            this.audioManager.playEnemyShot(enemy.mesh.position, this.playerShip.position);
        },
        'burst': () => {
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    if (enemy.health > 0) {
                        this.createEnemyBullet(enemy);
                        this.audioManager.playEnemyShot(enemy.mesh.position, this.playerShip.position);
                    }
                }, i * 100);
            }
        },
        'heavy': () => {
            this.createEnemyBullet(enemy);
            this.audioManager.playEnemyShot(enemy.mesh.position, this.playerShip.position);
        }
    };
    const shootFunction = weaponTypes[enemy.weaponType] || weaponTypes.rapid;
    shootFunction();
}
        createEnemyBullet(enemy) {
          const bulletGeom = new THREE.SphereGeometry(0.3, 8, 8);
          const bulletMat = new THREE.MeshBasicMaterial({
            color: 0xff4757,
            emissive: 0xff2030,
            emissiveIntensity: 0.5
          });
          const bullet = new THREE.Mesh(bulletGeom, bulletMat);
          bullet.position.copy(enemy.mesh.position);
          bullet.position.y = 5;
          const direction = new THREE.Vector3().subVectors(this.playerShip.position, enemy.mesh.position).normalize();
          const bulletVelocity = direction.clone().multiplyScalar(CONFIG.bullet.enemySpeed);
          this.enemyBullets.push({
            mesh: bullet,
            velocity: bulletVelocity,
            life: CONFIG.bullet.life
          });
          this.scene.add(bullet)
        }
        getShootCooldown(weaponType) {
          const cooldowns = {
            'rapid': 60,
            'burst': 180,
            'heavy': 150
          };
          return cooldowns[weaponType] || 120
        }
        updateBullets() {
          this.bullets = this.bullets.filter(bullet => {
            // Safety check
            if (!bullet || !bullet.mesh || !bullet.velocity) {
              return false;
            }
            bullet.mesh.position.add(bullet.velocity);
            bullet.life--;
            const damage = this.player.effects.damage.active ? CONFIG.bullet.damage * CONFIG.audio.damage.mult : CONFIG.bullet.damage;
            // Check enemy collisions
            for (let enemy of this.enemies) {
              if (!enemy || !enemy.mesh || !enemy.mesh.position || enemy.health <= 0) continue;
              try {
                if (bullet.mesh.position.distanceTo(enemy.mesh.position) < 3) {
                  const bulletDamage = bullet.isAlly ? (bullet.damage || 25) : 
                        (this.player.effects.damage.active ? CONFIG.bullet.damage * CONFIG.audio.damage.mult : CONFIG.bullet.damage);
    enemy.health -= bulletDamage;
                  enemy.attacking = true;
                  enemy.retreating = false;
                  this.audioManager.playEnemyHit();
                  if (enemy.health <= 0) {
                    this.createExplosion(enemy.mesh.position);
                    this.audioManager.playExplosion();
                    enemy.mesh.visible = false;
                    this.player.score += enemy.score;
                    this.dropArtifact(enemy.mesh.position);
                    this.updateHUD();
                  }
                  try {
                    this.scene.remove(bullet.mesh);
                  } catch (e) {
                    console.warn('Failed to remove bullet from scene:', e);
                  }
                  return false;
                }
              } catch (e) {
                console.warn('Error in bullet-enemy collision:', e);
                continue;
              }
            }
            // Check planet collisions
            for (let planet of this.planets) {
              if (!planet || !planet.center || planet.destroyed) continue;
              try {
                if (bullet.mesh.position.distanceTo(planet.center) < planet.config.radius) {
                  planet.health -= damage;
                  if (planet.health <= 0) {
                    this.destroyPlanet(planet);
                  }
                  try {
                    this.scene.remove(bullet.mesh);
                  } catch (e) {
                    console.warn('Failed to remove bullet from scene:', e);
                  }
                  return false;
                }
              } catch (e) {
                console.warn('Error in bullet-planet collision:', e);
                continue;
              }
            }
            // Check bullet lifetime
            if (bullet.life <= 0) {
              try {
                this.scene.remove(bullet.mesh);
              } catch (e) {
                console.warn('Failed to remove expired bullet:', e);
              }
              return false;
            }
            return true;
          });
        }
        // Fix 2: Replace the updateEnemyBullets() method (around line 1200)
        updateEnemyBullets() {
          this.enemyBullets = this.enemyBullets.filter(bullet => {
            // Safety check
            if (!bullet || !bullet.mesh || !bullet.velocity) {
              return false;
            }
            bullet.mesh.position.add(bullet.velocity);
            bullet.life--;
            // Check player collision only if not landing
            if (this.landingState === 'none' && this.playerShip && this.playerShip.position) {
              try {
                const distance = bullet.mesh.position.distanceTo(this.playerShip.position);
                if (distance < 3) {
                  this.player.health -= CONFIG.bullet.enemyDamage;
                  this.audioManager.playDamage();
                  this.createDamageEffect(this.playerShip.position);
                  this.updateHUD();
                  if (this.player.health <= 0) {
                    this.gameOver();
                  }
                  try {
                    this.scene.remove(bullet.mesh);
                  } catch (e) {
                    console.warn('Failed to remove enemy bullet from scene:', e);
                  }
                  return false;
                }
              } catch (e) {
                console.warn('Error in enemy bullet-player collision:', e);
              }
            }
            // Check bullet lifetime
            if (bullet.life <= 0) {
              try {
                this.scene.remove(bullet.mesh);
              } catch (e) {
                console.warn('Failed to remove expired enemy bullet:', e);
              }
              return false;
            }
            return true;
          });
        }
        updateArtifacts() {
          this.artifacts = this.artifacts.filter(artifact => {
            artifact.life--;
            artifact.mesh.position.y = 1 + Math.sin(Date.now() * 0.005 + artifact.bobOffset) * 0.5;
            artifact.mesh.rotation.y += 0.08;
            artifact.mesh.rotation.x += 0.03;
            const playerPosition = this.playerShip.position.clone();
            playerPosition.y = artifact.mesh.position.y;
            const distance = artifact.mesh.position.distanceTo(playerPosition);
            if (distance < 6) {
              this.applyArtifactEffect(artifact.type);
              this.scene.remove(artifact.mesh);
              return !1
            }
            if (artifact.life <= 0) {
              this.scene.remove(artifact.mesh);
              return !1
            }
            return !0
          })
        }
        updateMines() {
          this.mines = this.mines.filter(mine => {
            mine.life--;
            if (mine.life <= 0 && !mine.exploded) {
              this.scene.remove(mine.mesh);
              return !1
            }
            if (!mine.exploded) {
              const nearbyEnemies = this.enemies.filter(enemy => enemy.health > 0 && mine.mesh.position.distanceTo(enemy.mesh.position) < 8);
              if (nearbyEnemies.length > 0) {
                mine.exploded = !0;
                this.explodeMine(mine);
                this.scene.remove(mine.mesh);
                return !1
              }
            }
            return !mine.exploded
          })
        }
        updateCollisions() {
          if (this.collisionCooldown > 0) {
            this.collisionCooldown--;
            return
          }
          if (this.landingState !== 'none') return;
          this.enemies.forEach(enemy => {
    if (enemy.health > 0 && !enemy.isAlly && 
        enemy.mesh.position.distanceTo(this.playerShip.position) < 4) {
        this.player.health -= 5;
        this.collisionCooldown = 60;
        this.audioManager.playCollision();
        this.updateHUD();
        if (this.player.health <= 0) {
            this.gameOver();
        }
    }
});
        }
        updateBackground() {
          if (this.backgroundManager) {
            this.backgroundManager.update(this.playerShip.position.x, this.playerShip.position.z)
          }
        }
        updateMinimap() {
          if (this.minimapManager) {
            this.minimapManager.update(this.playerShip.position, this.planets, this.enemies)
          }
        }
        updateCoordinates() {
          document.getElementById('posX').textContent = Math.round(this.playerShip.position.x);
          document.getElementById('posZ').textContent = Math.round(this.playerShip.position.z)
        }
        updateEffects() {
          const currentTime = Date.now();
          let effectsText = '';
          if (this.player.effects.speed.active) {
            if (currentTime > this.player.effects.speed.endTime) {
              this.player.effects.speed.active = !1
            } else {
              const remaining = Math.ceil((this.player.effects.speed.endTime - currentTime) / 1000);
              effectsText += `SPEED BOOST: ${remaining}s
                                                                                                                  
              <br>`
            }
          }
          if (this.player.effects.damage.active) {
            if (currentTime > this.player.effects.damage.endTime) {
              this.player.effects.damage.active = !1
            } else {
              const remaining = Math.ceil((this.player.effects.damage.endTime - currentTime) / 1000);
              effectsText += `DAMAGE BOOST: ${remaining}s
                                                                                                                    
                <br>`
            }
          }
          document.getElementById('effects').innerHTML = effectsText
        }
        updateExplosions() {
          this.explosions = this.explosions.filter(explosion => {
            explosion.scale += 0.1;
            explosion.mesh.scale.setScalar(explosion.scale);
            explosion.mesh.material.opacity = Math.max(0, 0.8 - explosion.scale * 0.4);
            if (explosion.scale >= 2) {
              this.scene.remove(explosion.mesh);
              return !1
            }
            return !0
          })
        }
        checkPlanetCollision(newPosition, isPlayer = !1) {
          if (isPlayer && this.landingState === 'taking_off' && this.landingTarget) {
            for (let planet of this.planets) {
              if (planet.destroyed || planet === this.landingTarget) continue;
              const distance = newPosition.distanceTo(planet.center);
              const collisionDistance = planet.config.radius + 3;
              if (distance < collisionDistance) {
                return !0
              }
            }
            return !1
          }
          if (!this.collisionEnabled && isPlayer) {
            return !1
          }
          for (let planet of this.planets) {
            if (planet.destroyed) continue;
            if (isPlayer && this.landingTarget && planet === this.landingTarget) {
              continue
            }
            const distance = newPosition.distanceTo(planet.center);
            const collisionDistance = planet.config.radius + (isPlayer ? 3 : 2);
            if (distance < collisionDistance) {
              if (isPlayer) {
                const bounceDirection = new THREE.Vector3().subVectors(newPosition, planet.center).normalize();
                this.playerVelocity.copy(bounceDirection.multiplyScalar(0.5));
                this.player.health -= 10;
                this.createDamageEffect(this.playerShip.position);
                this.audioManager.playDamage();
                this.updateHUD();
                if (this.player.health <= 0) {
                  this.gameOver()
                }
              }
              return !0
            }
          }
          return !1
        }
        checkCameraCollision(cameraPosition) {
          for (let planet of this.planets) {
            if (planet.destroyed) continue;
            const distance = cameraPosition.distanceTo(planet.center);
            const collisionDistance = planet.config.radius + 15;
            if (distance < collisionDistance) {
              return !0
            }
          }
          return !1
        }
        adjustCameraForCollision() {
          let bestPosition = null;
          let maxDistance = 0;
          const baseDistance = 60;
          for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
            const offsetX = Math.sin(angle) * baseDistance;
            const offsetZ = Math.cos(angle) * baseDistance;
            const testPosition = new THREE.Vector3(this.playerShip.position.x + offsetX, 60, this.playerShip.position.z + offsetZ);
            if (!this.checkCameraCollision(testPosition)) {
              const distanceFromIdeal = testPosition.distanceTo(new THREE.Vector3(this.playerShip.position.x, 60, this.playerShip.position.z + baseDistance));
              if (!bestPosition || distanceFromIdeal < maxDistance) {
                bestPosition = testPosition;
                maxDistance = distanceFromIdeal
              }
            }
          }
          if (bestPosition) {
            this.camera.position.copy(bestPosition)
          } else {
            this.camera.position.set(this.playerShip.position.x, 80, this.playerShip.position.z)
          }
        }
        createArtifact(position, type) {
          const artifactGeom = new THREE.SphereGeometry(1.5, 12, 12);
          const artifactMat = new THREE.MeshBasicMaterial({
            color: CONFIG.audio[type].color,
            transparent: !0,
            opacity: 0.9
          });
          const artifact = new THREE.Mesh(artifactGeom, artifactMat);
          artifact.position.copy(position);
          artifact.position.y = 1;
          const artifactObj = {
            mesh: artifact,
            type: type,
            life: 900,
            bobOffset: Math.random() * Math.PI * 2
          };
          this.artifacts.push(artifactObj);
          this.scene.add(artifact);
          return artifactObj
        }
        dropArtifact(position) {
          const artifactTypes = ['speed', 'damage', 'health'];
          const randomType = artifactTypes[Math.floor(Math.random() * artifactTypes.length)];
          this.createArtifact(position, randomType)
        }
        applyArtifactEffect(type) {
          const artifactConfig = CONFIG.audio[type];
          const currentTime = Date.now();
          if (type === 'health') {
            this.player.health = Math.min(CONFIG.player.health, this.player.health + artifactConfig.amount)
          } else {
            this.player.effects[type].active = !0;
            this.player.effects[type].endTime = currentTime + artifactConfig.duration
          }
          this.audioManager.playWeaponSwitch();
          this.updateHUD()
        }
        createExplosion(position, size = 5) {
          const explosionGeom = new THREE.SphereGeometry(size, 16, 16);
          const explosionMat = new THREE.MeshBasicMaterial({
            color: 0xff4757,
            transparent: !0,
            opacity: 0.8
          });
          const explosion = new THREE.Mesh(explosionGeom, explosionMat);
          explosion.position.copy(position);
          this.scene.add(explosion);
          this.explosions.push({
            mesh: explosion,
            scale: 0
          })
        }
        createDamageEffect(position) {
          const damageGeom = new THREE.SphereGeometry(3, 32, 32);
          const damageMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: !0,
            opacity: 0.6
          });
          const damage = new THREE.Mesh(damageGeom, damageMat);
          damage.position.copy(position);
          this.scene.add(damage);
          this.explosions.push({
            mesh: damage,
            scale: 0
          })
        }
        destroyPlanet(planet) {
    planet.destroyed = true;
    this.createExplosion(planet.center, planet.config.radius);
    this.audioManager.playExplosion(2, planet.center, this.playerShip.position); // Updated call
    this.scene.remove(planet.mesh);
    this.player.score += 500;
    this.updateHUD();
    
    this.enemies = this.enemies.filter(enemy => {
        if (enemy.planet === planet) {
            this.scene.remove(enemy.mesh);
            return false;
        }
        return true;
    });
}
        explodeMine(mine) {
    const explosionGeom = new THREE.SphereGeometry(8, 16, 16);
    const explosionMat = new THREE.MeshBasicMaterial({ color: 0xff4757, transparent: true, opacity: 0.6 });
    const explosion = new THREE.Mesh(explosionGeom, explosionMat);
    explosion.position.copy(mine.mesh.position);
    this.scene.add(explosion);
    this.explosions.push({ mesh: explosion, scale: 0 });
    
    this.audioManager.playExplosion(1.5, mine.mesh.position, this.playerShip.position); // Updated call
    
    this.enemies.forEach(enemy => {
        if (enemy.health > 0 && explosion.position.distanceTo(enemy.mesh.position) < 8) {
            enemy.health -= 50;
            this.audioManager.playEnemyHit();
            if (enemy.health <= 0) {
                this.createExplosion(enemy.mesh.position);
                this.audioManager.playExplosion(1, enemy.mesh.position, this.playerShip.position); // Updated call
                enemy.mesh.visible = false;
                enemy.stuck = true;
                this.player.score += enemy.score;
                this.dropArtifact(enemy.mesh.position);
                this.updateHUD();
            }
        }
    });
}
        updateHUD() {
          document.getElementById('health').textContent = this.player.health;
          document.getElementById('score').textContent = this.player.score
        }
        gameOver() {
          this.gameStarted = !1;
          this.audioManager.stopLaser();
          setTimeout(() => {
            this.showGameOverScreen()
          }, 500)
        }
        showGameOverScreen() {
          const intro = document.getElementById('intro');
          const introContent = intro.innerHTML;
          intro.innerHTML = `
        
                                                                                                                                  
                  <h1>Game Over</h1>
                  <div style="font-size: 2rem; color: #feca57; margin: 20px 0; text-shadow: 0 0 15px rgba(254,202,87,0.8);">
            Final Score: ${this.player.score}
        </div>
                  <p>Your mission has ended. The galaxy remembers your courage.</p>
                  <button id="playAgainBtn">Play Again</button>
                  <button id="backToMenuBtn">Main Menu</button>
    `;
          intro.classList.remove('hidden');
          document.getElementById('playAgainBtn').addEventListener('click', () => {
            this.resetGame();
            intro.innerHTML = introContent;
            intro.classList.add('hidden');
            this.gameStarted = !0
          });
          document.getElementById('backToMenuBtn').addEventListener('click', () => {
            intro.innerHTML = introContent;
            this.resetGame()
          })
        }
        createHealingBeam(ally, target) {
    const healGeom = new THREE.BufferGeometry().setFromPoints([
        ally.mesh.position.clone().add(new THREE.Vector3(0, 0.5, 0)),
        target.position.clone().add(new THREE.Vector3(0, 0.5, 0))
    ]);
    const healMat = new THREE.LineBasicMaterial({
        color: 0x00ff88,
        transparent: true,
        opacity: 0.8
    });
    const healBeam = new THREE.Line(healGeom, healMat);
    this.scene.add(healBeam);
    
    // Remove beam after short time
    setTimeout(() => {
        this.scene.remove(healBeam);
    }, 200);
}
        resetGame() {
          this.player.health = CONFIG.player.health;
          this.player.score = 0;
          this.player.currentWeapon = 1;
          this.player.effects.speed.active = !1;
          this.player.effects.damage.active = !1;
          this.switchWeapon(1);
          this.playerShip.position.set(50, 5, 50);
          this.playerVelocity.set(0, 0, 0);
          this.collisionCooldown = 0;
          this.visitedPlanets.clear();
          this.landingState = 'none';
          this.landingTarget = null;
          this.removeLandingGlow();
          this.restorePlayerDepth();

    this.minimapManager.waypoint = null;
    this.removeWaypointIndicator();
    this.waypointReachedCooldown = 0;
this.allies.forEach(ally => this.scene.remove(ally.mesh));
this.allies = [];
          this.enemies.forEach(enemy => {
            const enemyConfig = EnemyFactory.types[enemy.type];
            enemy.health = enemyConfig.health;
            enemy.attacking = !1;
            enemy.retreating = !1;
            enemy.shootCooldown = 0;
            enemy.stuck = !1;
            enemy.mesh.visible = !0;
            enemy.angle = enemy.originalAngle;
            this.updateEnemyPosition(enemy)
          });
          this.planets.forEach(planet => {
            if (planet.destroyed) {
              planet.destroyed = !1;
              planet.health = planet.maxHealth;
              this.scene.add(planet.mesh)
            } else {
              planet.health = planet.maxHealth
            }
          });
          this.trails.forEach(trail => this.scene.remove(trail.mesh));
          this.trails = [];
          this.collisionEnabled = !0;
          this.bullets.forEach(bullet => this.scene.remove(bullet.mesh));
          this.bullets = [];
          this.enemyBullets.forEach(bullet => this.scene.remove(bullet.mesh));
          this.enemyBullets = [];
          this.artifacts.forEach(artifact => this.scene.remove(artifact.mesh));
          this.artifacts = [];
          this.mines.forEach(mine => this.scene.remove(mine.mesh));
          this.mines = [];
          this.explosions.forEach(explosion => this.scene.remove(explosion.mesh));
          this.explosions = [];
          if (this.laserBeam) {
            this.scene.remove(this.laserBeam);
            this.laserBeam = null
          }
          const dialogueSystem = document.getElementById('dialogueSystem');
          if (dialogueSystem) {
            dialogueSystem.classList.add('hidden')
          }
          const landingPrompts = document.getElementById('landingPrompts');
          if (landingPrompts) {
            landingPrompts.innerHTML = ''
          }
          this.updateHUD()
        }
        setupEventListeners() {
          document.addEventListener('keydown', (e) => {
            this.keys[e.code] = !0;
            if (e.code === 'KeyE') {
              this.startLanding()
            }
            if (e.code === 'KeyF') {
    this.spawnAlly();
}
            if (e.code.startsWith('Digit')) {
              const weaponNumber = parseInt(e.code.charAt(5));
              this.switchWeapon(weaponNumber)
            }
          });
          document.addEventListener('keyup', (e) => {
            this.keys[e.code] = !1
          });
          document.getElementById('startBtn').addEventListener('click', () => {
            this.startGame()
          });
          this.setupMobileControls();
          window.addEventListener('resize', () => {
            const aspectRatio = window.innerWidth / window.innerHeight;
            const distance = 60;
            this.camera.left = -distance * aspectRatio;
            this.camera.right = distance * aspectRatio;
            this.camera.top = distance;
            this.camera.bottom = -distance;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight)
          })
        }
        setupMobileControls() {
          const dpad = document.getElementById('dpad');
          const dpadInner = document.getElementById('dpadInner');
          const fireBtn = document.getElementById('fireBtn');
          const weaponBtn = document.getElementById('weaponBtn');
          let dpadPressed = !1;
          const updateDpad = (clientX, clientY) => {
            const rect = dpad.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const deltaX = clientX - centerX;
            const deltaY = clientY - centerY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = 40;
            if (distance <= maxDistance) {
              dpadInner.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
              this.touchControls.moveX = deltaX / maxDistance;
              this.touchControls.moveY = deltaY / maxDistance
            } else {
              const angle = Math.atan2(deltaY, deltaX);
              const limitedX = Math.cos(angle) * maxDistance;
              const limitedY = Math.sin(angle) * maxDistance;
              dpadInner.style.transform = `translate(${limitedX}px, ${limitedY}px)`;
              this.touchControls.moveX = limitedX / maxDistance;
              this.touchControls.moveY = limitedY / maxDistance
            }
          };
          const resetDpad = () => {
            dpadInner.style.transform = 'translate(0px, 0px)';
            this.touchControls.moveX = 0;
            this.touchControls.moveY = 0;
            dpadPressed = !1
          };
          dpad.addEventListener('touchstart', (e) => {
            e.preventDefault();
            dpadPressed = !0;
            const touch = e.touches[0];
            updateDpad(touch.clientX, touch.clientY)
          });
          dpad.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (dpadPressed) {
              const touch = e.touches[0];
              updateDpad(touch.clientX, touch.clientY)
            }
          });
          dpad.addEventListener('touchend', (e) => {
            e.preventDefault();
            resetDpad()
          });
          fireBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.touchControls.firing = !0
          });
          fireBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.touchControls.firing = !1
          });
          weaponBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.cycleWeapon()
          })
        }
        async startGame() {
          document.getElementById('intro').classList.add('hidden');
          await this.audioManager.start();
          this.gameStarted = !0;
          
          const asteriaPlanet = this.findPlanetByName('Asteria Prime');
if (asteriaPlanet) {
    this.minimapManager.waypoint = {
        x: asteriaPlanet.center.x,
        z: asteriaPlanet.center.z,
        planet: asteriaPlanet,
        type: 'planet'
    };
}
setTimeout(() => {
    this.showNavigationNotification('Asteria Prime');
}, 500);
        }
        animate() {
          requestAnimationFrame(() => this.animate());
          this.update();
          this.renderer.render(this.scene, this.camera)
        }
      }
      const game = new SpaceShooter();
    </script> 
    <style>body{margin:0;padding:0;background:#000;font-family:'Courier New',monospace;overflow:hidden}#gameContainer{position:relative;width:100vw;height:100vh}canvas{display:block}#intro{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(135deg,#0a0a2e,#16213e,#0f3460);display:flex;flex-direction:column;justify-content:center;align-items:center;color:#fff;z-index:1000;transition:opacity 0.5s}#intro h1{font-size:4rem;margin:0;text-shadow:0 0 20px #4facfe;background:linear-gradient(45deg,#4facfe,#00f2fe);-webkit-background-clip:text;-webkit-text-fill-color:#fff0;animation:glow 2s infinite alternate}#intro p{font-size:1.2rem;margin:20px 0;text-align:center;max-width:600px;line-height:1.6}#startBtn{padding:15px 30px;font-size:1.5rem;background:linear-gradient(45deg,#667eea,#764ba2);border:none;color:#fff;cursor:pointer;border-radius:50px;transition:all 0.3s;box-shadow:0 4px 15px rgb(0 0 0 / .3)}#startBtn:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgb(0 0 0 / .4)}#playAgainBtn,#backToMenuBtn{padding:12px 25px;font-size:1.2rem;background:linear-gradient(45deg,#667eea,#764ba2);border:none;color:#fff;cursor:pointer;border-radius:40px;transition:all 0.3s;box-shadow:0 4px 15px rgb(0 0 0 / .3);margin:10px}#playAgainBtn:hover,#backToMenuBtn:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgb(0 0 0 / .4)}#playAgainBtn{background:linear-gradient(45deg,#00ff88,#00d4aa)}#backToMenuBtn{background:linear-gradient(45deg,#ff6b6b,#ff5252)}@keyframes glow{0%{text-shadow:0 0 20px #4facfe}100%{text-shadow:0 0 30px #4facfe,0 0 40px #00f2fe}}#hud{position:absolute;top:20px;left:20px;color:#4facfe;font-size:1rem;z-index:100;text-shadow:0 0 10px rgb(79 172 254 / .8);display:flex;flex-direction:column;gap:8px}#healthHud{color:#0f8;font-weight:700}#scoreHud{color:#feca57;font-weight:700}#weaponHud{color:#ff6b6b;font-weight:700}#coordinates{color:rgb(79 172 254 / .7);font-size:.9rem}#minimap{position:absolute;top:20px;right:20px;width:120px;height:120px;border:2px solid rgb(79 172 254 / .4);border-radius:8px;background:rgb(0 0 0 / .8);backdrop-filter:blur(5px);z-index:100;transition:all 0.3s ease;cursor:pointer}#minimap.expanded{width:300px;height:300px;right:50%;top:50%;transform:translate(50%,-50%);z-index:1001}#minimapCanvas{width:100%;height:100%;border-radius:6px}#minimapToggle{position:absolute;top:-8px;right:-8px;width:20px;height:20px;background:rgb(79 172 254 / .8);color:#fff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:12px;cursor:pointer;border:1px solid rgb(79 172 254 / .6)}#minimapToggle:hover{background:rgb(79 172 254)}.hidden{opacity:0;pointer-events:none}#controls{position:absolute;bottom:20px;right:20px;color:rgb(255 255 255 / .7);font-size:.9rem;text-align:right;z-index:100}#effects{position:absolute;top:160px;left:20px;color:#feca57;font-size:.8rem;z-index:100;text-shadow:0 0 10px rgb(254 202 87 / .8)}#mobileControls{position:absolute;bottom:20px;left:20px;right:20px;display:none;z-index:200}#dpad{position:absolute;bottom:0px;left:20px;width:120px;height:120px}#dpadOuter{width:120px;height:120px;border:3px solid rgb(79 172 254 / .6);border-radius:50%;position:absolute;background:rgb(0 0 0 / .3);backdrop-filter:blur(5px)}#dpadInner{width:40px;height:40px;background:rgb(79 172 254 / .8);border-radius:50%;position:absolute;top:40px;left:40px;transition:all 0.1s ease;box-shadow:0 0 15px rgb(79 172 254 / .6)}#fireBtn{position:absolute;bottom:100px;right:0px;width:80px;height:80px;border:3px solid rgb(255 75 87 / .6);border-radius:50%;background:rgb(255 75 87 / .3);color:#fff;font-size:14px;display:flex;align-items:center;justify-content:center;user-select:none;backdrop-filter:blur(5px);box-shadow:0 0 20px rgb(255 75 87 / .4);font-weight:700}#weaponBtn{position:absolute;bottom:90px;right:0px;width:60px;height:60px;border:3px solid rgb(254 202 87 / .6);border-radius:50%;background:rgb(254 202 87 / .3);color:#fff;font-size:12px;display:flex;align-items:center;justify-content:center;user-select:none;backdrop-filter:blur(5px);box-shadow:0 0 20px rgb(254 202 87 / .4);font-weight:700}#fireBtn:active,#weaponBtn:active{transform:scale(.95)}@media(max-width:768px){#mobileControls{display:block}#controls{display:none}#intro h1{font-size:2.5rem}#intro p{font-size:1rem;padding:0 20px}#hud{font-size:.9rem}#minimap{width:100px;height:100px}#minimap.expanded{width:250px;height:250px}}#hud div{margin:2px 0;padding:2px 0}#effects div{animation:pulse 2s infinite}@keyframes pulse{0%,100%{opacity:1}50%{opacity:.7}}#dpadOuter:active{background:rgb(79 172 254 / .2)}#fireBtn:active{background:rgb(255 75 87 / .5);box-shadow:0 0 30px rgb(255 75 87 / .6)}#weaponBtn:active{background:rgb(254 202 87 / .5);box-shadow:0 0 30px rgb(254 202 87 / .6)}.fade-in{animation:fadeIn 1s ease-in}@keyframes fadeIn{from{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}@media(max-width:480px){#intro h1{font-size:2rem}#dpad{width:100px;height:100px}#dpadOuter{width:100px;height:100px}#dpadInner{width:35px;height:35px;top:32.5px;left:32.5px}#fireBtn{width:70px;height:70px;font-size:12px}#weaponBtn{width:50px;height:50px;font-size:10px}#minimap{width:80px;height:80px}#minimap.expanded{width:200px;height:200px}}*{box-sizing:border-box}canvas{image-rendering:optimizeSpeed;image-rendering:-moz-crisp-edges;image-rendering:-webkit-optimize-contrast;image-rendering:optimize-contrast}#landingPrompts{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:150}@keyframes landingPulse{0%,100%{opacity:1;transform:translateX(-50%)scale(1);box-shadow:0 0 10px rgb(0 255 136 / .6)}50%{opacity:.8;transform:translateX(-50%)scale(1.05);box-shadow:0 0 20px rgb(0 255 136 / .8)}}#dialogueSystem{position:absolute;top:0;left:0;width:100%;height:100%;background:rgb(0 0 0 / .8);display:flex;padding-top:3em;vertical-align:top;justify-content:center;align-items:flex-start;z-index:1000;backdrop-filter:blur(5px)}#dialogueBox{background:linear-gradient(135deg,#0a0a2e,#16213e);border:0 solid #104840;border-radius:15px;padding:0;max-width:90vw;width:500px;text-align:center;box-shadow:0 0 30px #003c71}#planetImage{font-size:4rem;margin-bottom:15px;border-radius:14px 14px 0 0;overflow:hidden;text-shadow:0 0 20px rgb(79 172 254 / .6)}#planetImage img{width:100%;height:auto;display:block;animation:planetZoom 18s ease-in-out infinite}@keyframes planetZoom{0%,100%{transform:scale(1)}50%{transform:scale(1.07)}}#dialogueContent h3{color:#4facfe;margin-top:0;font-size:1.5rem;text-shadow:0 0 10px rgb(79 172 254 / .8)}#dialogueOptions{margin-bottom:1em}#dialogueContent p{color:#fff;margin:20px 0;padding:0 30px;line-height:1.6em;min-height:60px;max-height:12em;text-align:left;overflow-y:scroll}@media(max-width:768px){#dialogueBox{padding:0;width:95vw;max-width:none}#dialogueSystem{padding-top:1em}#planetImage{font-size:3rem}#dialogueContent h3{font-size:1.2rem}#dialogueContent p{font-size:.9rem;min-height:50px}}.dialogue-btn{background:linear-gradient(45deg,#1e32e9,#2196F3);border:none;color:#fff;padding:12px 24px;font-size:1rem;border-radius:25px;cursor:pointer;transition:all 0.3s;margin:10px}.dialogue-btn:hover{transform:translateY(-2px);box-shadow:0 5px 15px rgb(0 0 0 / .3)}#landBtn{position:absolute;bottom:20px;right:100px;width:60px;height:60px;border:3px solid rgb(0 255 136 / .6);border-radius:50%;background:rgb(0 255 136 / .3);color:#fff;font-size:12px;display:none;align-items:center;justify-content:center;user-select:none;backdrop-filter:blur(5px);box-shadow:0 0 20px rgb(0 255 136 / .4);font-weight:700}#landingPrompts div{white-space:nowrap}@media(max-width:768px){#mobileControls #landBtn{display:flex}}</style>
  </body>
</html>