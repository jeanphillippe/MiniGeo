<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Frontier - Phaser Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            overflow: hidden;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        
        #game-container {
            position: relative;
            border: 2px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
        }
        
        .intro-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(26,26,46,0.95) 0%, rgba(22,33,62,0.95) 50%, rgba(15,52,96,0.95) 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s ease;
        }
        
        .intro-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .title {
            font-size: 3.5rem;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #0080ff;
            margin-bottom: 1.5rem;
            animation: pulse 2s infinite;
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: #ffffff;
            margin-bottom: 2.5rem;
            text-align: center;
            max-width: 500px;
            line-height: 1.5;
            opacity: 0.9;
        }
        
        .start-btn {
            padding: 15px 40px;
            font-size: 1.3rem;
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }
        
        .start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
        }
        
        .controls-info {
            position: absolute;
            bottom: 20px;
            color: #aaa;
            font-size: 0.85rem;
            text-align: center;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/phaser.min.js"></script>
</head>
<body>
    <div id="game-container">
        <div class="intro-overlay" id="intro">
            <h1 class="title">QUANTUM FRONTIER</h1>
            <p class="subtitle">Navigate the cosmic void. Mine resources. Survive enemy waves.</p>
            <button class="start-btn" onclick="startGame()">LAUNCH MISSION</button>
            <div class="controls-info">
                WASD/Arrows to move • Mouse to aim • Left click to shoot • ESC to pause
            </div>
        </div>
    </div>

    <script>
        let game;
        const GAME_WIDTH = 1024;
        const GAME_HEIGHT = 768;
        
        function startGame() {
            document.getElementById('intro').classList.add('hidden');
            setTimeout(() => {
                document.getElementById('intro').style.display = 'none';
                if (!game) {
                    game = new Phaser.Game(config);
                }
            }, 500);
        }
        
        // Object pools for performance
        class ObjectPool {
            constructor(createFn, resetFn, size = 50) {
                this.createFn = createFn;
                this.resetFn = resetFn;
                this.pool = [];
                this.active = [];
                
                for (let i = 0; i < size; i++) {
                    this.pool.push(this.createFn());
                }
            }
            
            get() {
                let obj = this.pool.pop() || this.createFn();
                this.active.push(obj);
                return obj;
            }
            
            release(obj) {
                const idx = this.active.indexOf(obj);
                if (idx !== -1) {
                    this.active.splice(idx, 1);
                    this.resetFn(obj);
                    this.pool.push(obj);
                }
            }
            
            releaseAll() {
                this.active.forEach(obj => {
                    this.resetFn(obj);
                    this.pool.push(obj);
                });
                this.active = [];
            }
        }
        
        // Spatial partitioning for collision optimization
        class QuadTree {
            constructor(bounds, maxObjects = 10, maxLevels = 5, level = 0) {
                this.bounds = bounds;
                this.maxObjects = maxObjects;
                this.maxLevels = maxLevels;
                this.level = level;
                this.objects = [];
                this.nodes = [];
            }
            
            clear() {
                this.objects = [];
                this.nodes.forEach(node => node.clear());
                this.nodes = [];
            }
            
            split() {
                const x = this.bounds.x;
                const y = this.bounds.y;
                const w = this.bounds.width / 2;
                const h = this.bounds.height / 2;
                
                this.nodes[0] = new QuadTree({x: x + w, y: y, width: w, height: h}, 
                    this.maxObjects, this.maxLevels, this.level + 1);
                this.nodes[1] = new QuadTree({x: x, y: y, width: w, height: h}, 
                    this.maxObjects, this.maxLevels, this.level + 1);
                this.nodes[2] = new QuadTree({x: x, y: y + h, width: w, height: h}, 
                    this.maxObjects, this.maxLevels, this.level + 1);
                this.nodes[3] = new QuadTree({x: x + w, y: y + h, width: w, height: h}, 
                    this.maxObjects, this.maxLevels, this.level + 1);
            }
            
            getIndex(obj) {
                const midX = this.bounds.x + this.bounds.width / 2;
                const midY = this.bounds.y + this.bounds.height / 2;
                
                const top = obj.y < midY && obj.y + obj.height < midY;
                const bottom = obj.y > midY;
                const left = obj.x < midX && obj.x + obj.width < midX;
                const right = obj.x > midX;
                
                if (left) {
                    if (top) return 1;
                    else if (bottom) return 2;
                } else if (right) {
                    if (top) return 0;
                    else if (bottom) return 3;
                }
                return -1;
            }
            
            insert(obj) {
                if (this.nodes.length > 0) {
                    const index = this.getIndex(obj);
                    if (index !== -1) {
                        this.nodes[index].insert(obj);
                        return;
                    }
                }
                
                this.objects.push(obj);
                
                if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {
                    if (this.nodes.length === 0) {
                        this.split();
                    }
                    
                    let i = 0;
                    while (i < this.objects.length) {
                        const index = this.getIndex(this.objects[i]);
                        if (index !== -1) {
                            this.nodes[index].insert(this.objects.splice(i, 1)[0]);
                        } else {
                            i++;
                        }
                    }
                }
            }
            
            retrieve(obj) {
                const index = this.getIndex(obj);
                let returnObjects = this.objects;
                
                if (this.nodes.length > 0) {
                    if (index !== -1) {
                        returnObjects = returnObjects.concat(this.nodes[index].retrieve(obj));
                    } else {
                        this.nodes.forEach(node => {
                            returnObjects = returnObjects.concat(node.retrieve(obj));
                        });
                    }
                }
                
                return returnObjects;
            }
        }
        
        class GameScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScene' });
                this.score = 0;
                this.waveNumber = 1;
                this.enemiesKilled = 0;
            }
            
            preload() {
                // Generate sprites programmatically
                this.generateSprites();
            }
            
            generateSprites() {
                // Player ship sprite
                const playerGraphics = this.make.graphics({x: 0, y: 0}, false);
                playerGraphics.fillStyle(0x00aaff, 1);
                playerGraphics.beginPath();
                playerGraphics.moveTo(20, 10);
                playerGraphics.lineTo(0, 0);
                playerGraphics.lineTo(4, 10);
                playerGraphics.lineTo(0, 20);
                playerGraphics.closePath();
                playerGraphics.fillPath();
                playerGraphics.generateTexture('player', 20, 20);
                
                // Enemy ship sprite
                const enemyGraphics = this.make.graphics({x: 0, y: 0}, false);
                enemyGraphics.fillStyle(0xff4444, 1);
                enemyGraphics.beginPath();
                enemyGraphics.moveTo(16, 8);
                enemyGraphics.lineTo(0, 0);
                enemyGraphics.lineTo(3, 8);
                enemyGraphics.lineTo(0, 16);
                enemyGraphics.closePath();
                enemyGraphics.fillPath();
                enemyGraphics.generateTexture('enemy', 16, 16);
                
                // Bullet sprite
                const bulletGraphics = this.make.graphics({x: 0, y: 0}, false);
                bulletGraphics.fillStyle(0x00ffff, 1);
                bulletGraphics.fillCircle(3, 3, 3);
                bulletGraphics.generateTexture('bullet', 6, 6);
                
                // Enemy bullet sprite
                const enemyBulletGraphics = this.make.graphics({x: 0, y: 0}, false);
                enemyBulletGraphics.fillStyle(0xff6666, 1);
                enemyBulletGraphics.fillCircle(2, 2, 2);
                enemyBulletGraphics.generateTexture('enemyBullet', 4, 4);
                
                // Asteroid sprite
                const asteroidGraphics = this.make.graphics({x: 0, y: 0}, false);
                asteroidGraphics.fillStyle(0x8b7355, 1);
                asteroidGraphics.fillCircle(15, 15, 15);
                asteroidGraphics.generateTexture('asteroid', 30, 30);
                
                // Particle sprite
                const particleGraphics = this.make.graphics({x: 0, y: 0}, false);
                particleGraphics.fillStyle(0xffffff, 1);
                particleGraphics.fillCircle(2, 2, 2);
                particleGraphics.generateTexture('particle', 4, 4);
            }
            
            create() {
                // Initialize spatial partitioning
                this.quadTree = new QuadTree({
                    x: 0, 
                    y: 0, 
                    width: GAME_WIDTH, 
                    height: GAME_HEIGHT
                });
                
                // Create starfield background
                this.createStarfield();
                
                // Initialize object pools
                this.bulletPool = new ObjectPool(
                    () => this.physics.add.sprite(-100, -100, 'bullet').setActive(false).setVisible(false),
                    (bullet) => {
                        bullet.setActive(false).setVisible(false);
                        bullet.setPosition(-100, -100);
                        bullet.setVelocity(0, 0);
                    },
                    100
                );
                
                this.enemyBulletPool = new ObjectPool(
                    () => this.physics.add.sprite(-100, -100, 'enemyBullet').setActive(false).setVisible(false),
                    (bullet) => {
                        bullet.setActive(false).setVisible(false);
                        bullet.setPosition(-100, -100);
                        bullet.setVelocity(0, 0);
                    },
                    100
                );
                
                this.particlePool = new ObjectPool(
                    () => this.add.image(-100, -100, 'particle').setVisible(false),
                    (particle) => {
                        particle.setVisible(false);
                        particle.setPosition(-100, -100);
                        particle.setAlpha(1);
                        particle.setScale(1);
                    },
                    200
                );
                
                // Create groups
                this.playerBullets = this.physics.add.group();
                this.enemyBullets = this.physics.add.group();
                this.enemies = this.physics.add.group();
                this.asteroids = this.physics.add.group();
                
                // Create player
                this.player = this.physics.add.sprite(GAME_WIDTH / 2, GAME_HEIGHT / 2, 'player');
                this.player.setCollideWorldBounds(true);
                this.player.setDrag(100);
                this.player.health = 100;
                this.player.maxHealth = 100;
                this.player.shootCooldown = 0;
                this.player.invulnerable = false;
                
                // Create initial asteroids
                this.createAsteroids(8);
                
                // Create initial enemies
                this.spawnWave();
                
                // Setup controls
                this.cursors = this.input.keyboard.createCursorKeys();
                this.wasd = this.input.keyboard.addKeys('W,S,A,D');
                
                // Setup collisions
                this.physics.add.overlap(this.playerBullets, this.enemies, this.hitEnemy, null, this);
                this.physics.add.overlap(this.playerBullets, this.asteroids, this.hitAsteroid, null, this);
                this.physics.add.overlap(this.enemyBullets, this.player, this.hitPlayer, null, this);
                this.physics.add.overlap(this.player, this.enemies, this.playerEnemyCollision, null, this);
                this.physics.add.overlap(this.player, this.asteroids, this.playerAsteroidCollision, null, this);
                
                // Create HUD
                this.createHUD();
                
                // Engine particles emitter
                this.engineParticles = this.add.particles(0, 0, 'particle', {
                    quantity: 1,
                    lifespan: 200,
                    speed: { min: 20, max: 50 },
                    scale: { start: 0.5, end: 0 },
                    tint: 0xff6600,
                    emitting: false
                });
                
                // Setup pause
                this.input.keyboard.on('keydown-ESC', () => {
                    this.scene.pause();
                    this.scene.launch('PauseScene');
                });
            }
            
            createStarfield() {
                // Three layers of parallax stars
                this.stars = [];
                for (let layer = 0; layer < 3; layer++) {
                    const starLayer = [];
                    const count = 50 + layer * 30;
                    const speed = 0.1 + layer * 0.2;
                    
                    for (let i = 0; i < count; i++) {
                        const star = this.add.circle(
                            Phaser.Math.Between(0, GAME_WIDTH),
                            Phaser.Math.Between(0, GAME_HEIGHT),
                            Phaser.Math.Between(1, 2),
                            0xffffff,
                            0.3 + layer * 0.2
                        );
                        star.speed = speed;
                        starLayer.push(star);
                    }
                    this.stars.push(starLayer);
                }
            }
            
            createAsteroids(count) {
                for (let i = 0; i < count; i++) {
                    const x = Phaser.Math.Between(50, GAME_WIDTH - 50);
                    const y = Phaser.Math.Between(50, GAME_HEIGHT - 50);
                    
                    // Avoid spawning near player
                    if (Phaser.Math.Distance.Between(x, y, this.player.x, this.player.y) < 150) {
                        i--;
                        continue;
                    }
                    
                    const asteroid = this.asteroids.create(x, y, 'asteroid');
                    asteroid.health = 50;
                    asteroid.setVelocity(
                        Phaser.Math.Between(-20, 20),
                        Phaser.Math.Between(-20, 20)
                    );
                    asteroid.setAngularVelocity(Phaser.Math.Between(-50, 50));
                    asteroid.setBounce(0.8);
                    asteroid.setCollideWorldBounds(true);
                }
            }
            
            spawnWave() {
                const enemyCount = Math.min(3 + this.waveNumber * 2, 15);
                
                for (let i = 0; i < enemyCount; i++) {
                    this.time.delayedCall(i * 500, () => {
                        const side = Phaser.Math.Between(0, 3);
                        let x, y;
                        
                        switch(side) {
                            case 0: // Top
                                x = Phaser.Math.Between(0, GAME_WIDTH);
                                y = -30;
                                break;
                            case 1: // Right
                                x = GAME_WIDTH + 30;
                                y = Phaser.Math.Between(0, GAME_HEIGHT);
                                break;
                            case 2: // Bottom
                                x = Phaser.Math.Between(0, GAME_WIDTH);
                                y = GAME_HEIGHT + 30;
                                break;
                            case 3: // Left
                                x = -30;
                                y = Phaser.Math.Between(0, GAME_HEIGHT);
                                break;
                        }
                        
                        const enemy = this.enemies.create(x, y, 'enemy');
                        enemy.health = 30 + this.waveNumber * 10;
                        enemy.maxHealth = enemy.health;
                        enemy.shootCooldown = 0;
                        enemy.speed = 50 + Math.random() * 30;
                        enemy.aggroRange = 200 + this.waveNumber * 20;
                        enemy.setCollideWorldBounds(true);
                        enemy.setBounce(0.5);
                    });
                }
            }
            
            createHUD() {
                const style = { 
                    fontSize: '16px', 
                    fill: '#00ffff',
                    fontFamily: 'Courier New',
                    stroke: '#000000',
                    strokeThickness: 2
                };
                
                // Health bar background
                this.healthBarBg = this.add.rectangle(20, 20, 204, 24, 0x333333);
                this.healthBarBg.setOrigin(0);
                this.healthBarBg.setStrokeStyle(2, 0x00ffff);
                
                // Health bar
                this.healthBar = this.add.rectangle(22, 22, 200, 20, 0x00ff00);
                this.healthBar.setOrigin(0);
                
                // Score text
                this.scoreText = this.add.text(20, 50, 'Score: 0', style);
                
                // Wave text
                this.waveText = this.add.text(20, 75, 'Wave: 1', style);
                
                // Enemy counter
                this.enemyText = this.add.text(20, 100, 'Enemies: 0', style);
            }
            
            update(time, delta) {
                // Update QuadTree
                this.quadTree.clear();
                
                // Insert all game objects into quadtree
                this.enemies.children.entries.forEach(enemy => {
                    if (enemy.active) {
                        this.quadTree.insert({
                            x: enemy.x - enemy.width/2,
                            y: enemy.y - enemy.height/2,
                            width: enemy.width,
                            height: enemy.height,
                            object: enemy
                        });
                    }
                });
                
                // Update parallax starfield
                this.stars.forEach((layer, layerIndex) => {
                    layer.forEach(star => {
                        star.y += star.speed;
                        if (star.y > GAME_HEIGHT) {
                            star.y = 0;
                            star.x = Phaser.Math.Between(0, GAME_WIDTH);
                        }
                    });
                });
                
                // Player movement
                const speed = 200;
                let moving = false;
                
                if (this.cursors.left.isDown || this.wasd.A.isDown) {
                    this.player.setVelocityX(-speed);
                    moving = true;
                } else if (this.cursors.right.isDown || this.wasd.D.isDown) {
                    this.player.setVelocityX(speed);
                    moving = true;
                }
                
                if (this.cursors.up.isDown || this.wasd.W.isDown) {
                    this.player.setVelocityY(-speed);
                    moving = true;
                } else if (this.cursors.down.isDown || this.wasd.S.isDown) {
                    this.player.setVelocityY(speed);
                    moving = true;
                }
                
                // Engine particles
                if (moving) {
                    this.engineParticles.setPosition(
                        this.player.x - Math.cos(this.player.rotation) * 10,
                        this.player.y - Math.sin(this.player.rotation) * 10
                    );
                    this.engineParticles.emitting = true;
                } else {
                    this.engineParticles.emitting = false;
                }
                
                // Player rotation to mouse
                const pointer = this.input.activePointer;
                this.player.rotation = Phaser.Math.Angle.Between(
                    this.player.x, this.player.y,
                    pointer.x, pointer.y
                ) + Math.PI / 2;
                
                // Shooting
                this.player.shootCooldown = Math.max(0, this.player.shootCooldown - delta);
                if (pointer.isDown && this.player.shootCooldown <= 0) {
                    this.playerShoot();
                    this.player.shootCooldown = 150;
                }
                
                // Update enemies
                this.enemies.children.entries.forEach(enemy => {
                    if (enemy.active) {
                        this.updateEnemy(enemy, delta);
                    }
                });
                
                // Clean up bullets
                this.playerBullets.children.entries.forEach(bullet => {
                    if (bullet.active) {
                        if (bullet.x < -50 || bullet.x > GAME_WIDTH + 50 || 
                            bullet.y < -50 || bullet.y > GAME_HEIGHT + 50) {
                            this.bulletPool.release(bullet);
                            this.playerBullets.remove(bullet);
                        }
                    }
                });
                
                this.enemyBullets.children.entries.forEach(bullet => {
                    if (bullet.active) {
                        if (bullet.x < -50 || bullet.x > GAME_WIDTH + 50 || 
                            bullet.y < -50 || bullet.y > GAME_HEIGHT + 50) {
                            this.enemyBulletPool.release(bullet);
                            this.enemyBullets.remove(bullet);
                        }
                    }
                });
                
                // Update HUD
                this.updateHUD();
                
                // Check wave completion
                if (this.enemies.countActive() === 0) {
                    this.waveNumber++;
                    this.waveText.setText('Wave: ' + this.waveNumber);
                    this.time.delayedCall(2000, () => this.spawnWave());
                }
                
                // Respawn asteroids
                if (this.asteroids.countActive() < 3) {
                    this.createAsteroids(2);
                }
            }
            
            updateEnemy(enemy, delta) {
                const dist = Phaser.Math.Distance.Between(
                    enemy.x, enemy.y,
                    this.player.x, this.player.y
                );
                
                if (dist < enemy.aggroRange) {
                    // Chase player
                    const angle = Phaser.Math.Angle.Between(
                        enemy.x, enemy.y,
                        this.player.x, this.player.y
                    );
                    
                    enemy.setVelocity(
                        Math.cos(angle) * enemy.speed,
                        Math.sin(angle) * enemy.speed
                    );
                    
                    enemy.rotation = angle + Math.PI / 2;
                    
                    // Enemy shooting
                    enemy.shootCooldown = Math.max(0, enemy.shootCooldown - delta);
                    if (enemy.shootCooldown <= 0 && dist < 300) {
                        this.enemyShoot(enemy);
                        enemy.shootCooldown = 1500 + Math.random() * 1000;
                    }
                } else {
                    // Patrol behavior
                    if (Math.random() < 0.02) {
                        enemy.setVelocity(
                            Phaser.Math.Between(-50, 50),
                            Phaser.Math.Between(-50, 50)
                        );
                    }
                }
            }
            
            playerShoot() {
                const bullet = this.bulletPool.get();
                bullet.setPosition(this.player.x, this.player.y);
                bullet.setActive(true).setVisible(true);
                
                const angle = this.player.rotation - Math.PI / 2;
                const speed = 500;
                bullet.setVelocity(
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed
                );
                
                this.playerBullets.add(bullet);
                
                // Muzzle flash
                this.createParticleExplosion(this.player.x, this.player.y, 0x00ffff, 5);
            }
            
            enemyShoot(enemy) {
                const bullet = this.enemyBulletPool.get();
                bullet.setPosition(enemy.x, enemy.y);
                bullet.setActive(true).setVisible(true);
                
                const angle = Phaser.Math.Angle.Between(
                    enemy.x, enemy.y,
                    this.player.x, this.player.y
                );
                const speed = 300;
                bullet.setVelocity(
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed
                );
                
                this.enemyBullets.add(bullet);
            }
            
            hitEnemy(bullet, enemy) {
                this.bulletPool.release(bullet);
                this.playerBullets.remove(bullet);
                
                enemy.health -= 25;
                
                // Flash effect
                enemy.setTint(0xffffff);
                this.time.delayedCall(100, () => enemy.clearTint());
                
                if (enemy.health <= 0) {
                    this.createParticleExplosion(enemy.x, enemy.y, 0xff4444, 15);
                    enemy.destroy();
                    this.score += 100;
                    this.enemiesKilled++;
                } else {
                    this.createParticleExplosion(enemy.x, enemy.y, 0xff6666, 5);
                }
            }
            
            hitAsteroid(bullet, asteroid) {
                this.bulletPool.release(bullet);
                this.playerBullets.remove(bullet);
                
                asteroid.health -= 25;
                
                if (asteroid.health <= 0) {
                    this.createParticleExplosion(asteroid.x, asteroid.y, 0x8b7355, 10);
                    asteroid.destroy();
                    this.score += 50;
                    
                    // Chance to spawn smaller asteroids
                    if (Math.random() < 0.3) {
                        for (let i = 0; i < 2; i++) {
                            const small = this.asteroids.create(
                                asteroid.x + Phaser.Math.Between(-20, 20),
                                asteroid.y + Phaser.Math.Between(-20, 20),
                                'asteroid'
                            );
                            small.setScale(0.5);
                            small.health = 25;
                            small.setVelocity(
                                Phaser.Math.Between(-50, 50),
                                Phaser.Math.Between(-50, 50)
                            );
                            small.setBounce(0.8);
                            small.setCollideWorldBounds(true);
                        }
                    }
                } else {
                    this.createParticleExplosion(asteroid.x, asteroid.y, 0x8b7355, 3);
                }
            }
            
            hitPlayer(player, bullet) {
                if (this.player.invulnerable) return;
                
                this.enemyBulletPool.release(bullet);
                this.enemyBullets.remove(bullet);
                
                this.player.health -= 10;
                this.createParticleExplosion(player.x, player.y, 0xff0000, 8);
                
                // Invulnerability frames
                this.player.invulnerable = true;
                this.player.setAlpha(0.5);
                this.time.delayedCall(1000, () => {
                    this.player.invulnerable = false;
                    this.player.setAlpha(1);
                });
                
                // Screen shake
                this.cameras.main.shake(200, 0.01);
                
                if (this.player.health <= 0) {
                    this.gameOver();
                }
            }
            
            playerEnemyCollision(player, enemy) {
                if (this.player.invulnerable) return;
                
                this.player.health -= 20;
                enemy.health -= 50;
                
                // Knockback
                const angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, player.x, player.y);
                player.setVelocity(Math.cos(angle) * 300, Math.sin(angle) * 300);
                enemy.setVelocity(Math.cos(angle + Math.PI) * 200, Math.sin(angle + Math.PI) * 200);
                
                this.createParticleExplosion(
                    (player.x + enemy.x) / 2,
                    (player.y + enemy.y) / 2,
                    0xffaa00, 12
                );
                
                // Invulnerability
                this.player.invulnerable = true;
                this.player.setAlpha(0.5);
                this.time.delayedCall(1500, () => {
                    this.player.invulnerable = false;
                    this.player.setAlpha(1);
                });
                
                // Check enemy death
                if (enemy.health <= 0) {
                    enemy.destroy();
                    this.score += 50;
                }
                
                // Screen shake
                this.cameras.main.shake(300, 0.02);
                
                if (this.player.health <= 0) {
                    this.gameOver();
                }
            }
            
            playerAsteroidCollision(player, asteroid) {
                if (this.player.invulnerable) return;
                
                this.player.health -= 15;
                
                // Knockback
                const angle = Phaser.Math.Angle.Between(asteroid.x, asteroid.y, player.x, player.y);
                player.setVelocity(Math.cos(angle) * 250, Math.sin(angle) * 250);
                asteroid.setVelocity(Math.cos(angle + Math.PI) * 100, Math.sin(angle + Math.PI) * 100);
                
                this.createParticleExplosion(
                    (player.x + asteroid.x) / 2,
                    (player.y + asteroid.y) / 2,
                    0x8b7355, 8
                );
                
                // Invulnerability
                this.player.invulnerable = true;
                this.player.setAlpha(0.5);
                this.time.delayedCall(1000, () => {
                    this.player.invulnerable = false;
                    this.player.setAlpha(1);
                });
                
                // Screen shake
                this.cameras.main.shake(250, 0.015);
                
                if (this.player.health <= 0) {
                    this.gameOver();
                }
            }
            
            createParticleExplosion(x, y, color, count) {
                for (let i = 0; i < count; i++) {
                    const particle = this.particlePool.get();
                    particle.setPosition(x, y);
                    particle.setVisible(true);
                    particle.setTint(color);
                    
                    const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
                    const speed = 2 + Math.random() * 3;
                    const lifetime = 500 + Math.random() * 500;
                    
                    this.tweens.add({
                        targets: particle,
                        x: x + Math.cos(angle) * speed * 20,
                        y: y + Math.sin(angle) * speed * 20,
                        alpha: 0,
                        scale: 0.1,
                        duration: lifetime,
                        ease: 'Power2',
                        onComplete: () => {
                            this.particlePool.release(particle);
                        }
                    });
                }
            }
            
            updateHUD() {
                // Update health bar
                const healthPercent = Math.max(0, this.player.health / this.player.maxHealth);
                this.healthBar.width = 200 * healthPercent;
                
                // Change color based on health
                if (healthPercent > 0.6) {
                    this.healthBar.setFillStyle(0x00ff00);
                } else if (healthPercent > 0.3) {
                    this.healthBar.setFillStyle(0xffff00);
                } else {
                    this.healthBar.setFillStyle(0xff0000);
                }
                
                // Update texts
                this.scoreText.setText('Score: ' + this.score);
                this.enemyText.setText('Enemies: ' + this.enemies.countActive());
            }
            
            gameOver() {
                this.physics.pause();
                this.scene.pause();
                
                // Game over text
                const gameOverText = this.add.text(
                    GAME_WIDTH / 2,
                    GAME_HEIGHT / 2 - 50,
                    'GAME OVER',
                    {
                        fontSize: '48px',
                        fill: '#ff0000',
                        fontFamily: 'Courier New',
                        stroke: '#000000',
                        strokeThickness: 4
                    }
                );
                gameOverText.setOrigin(0.5);
                
                const finalScoreText = this.add.text(
                    GAME_WIDTH / 2,
                    GAME_HEIGHT / 2 + 20,
                    'Final Score: ' + this.score,
                    {
                        fontSize: '24px',
                        fill: '#ffffff',
                        fontFamily: 'Courier New'
                    }
                );
                finalScoreText.setOrigin(0.5);
                
                const restartText = this.add.text(
                    GAME_WIDTH / 2,
                    GAME_HEIGHT / 2 + 60,
                    'Click to Restart',
                    {
                        fontSize: '20px',
                        fill: '#00ffff',
                        fontFamily: 'Courier New'
                    }
                );
                restartText.setOrigin(0.5);
                
                this.input.once('pointerdown', () => {
                    this.scene.restart();
                    this.score = 0;
                    this.waveNumber = 1;
                    this.enemiesKilled = 0;
                });
            }
        }
        
        class PauseScene extends Phaser.Scene {
            constructor() {
                super({ key: 'PauseScene' });
            }
            
            create() {
                const bg = this.add.rectangle(
                    GAME_WIDTH / 2,
                    GAME_HEIGHT / 2,
                    GAME_WIDTH,
                    GAME_HEIGHT,
                    0x000000,
                    0.7
                );
                
                const pauseText = this.add.text(
                    GAME_WIDTH / 2,
                    GAME_HEIGHT / 2 - 30,
                    'PAUSED',
                    {
                        fontSize: '36px',
                        fill: '#00ffff',
                        fontFamily: 'Courier New',
                        stroke: '#000000',
                        strokeThickness: 3
                    }
                );
                pauseText.setOrigin(0.5);
                
                const resumeText = this.add.text(
                    GAME_WIDTH / 2,
                    GAME_HEIGHT / 2 + 20,
                    'Press ESC to Resume',
                    {
                        fontSize: '20px',
                        fill: '#ffffff',
                        fontFamily: 'Courier New'
                    }
                );
                resumeText.setOrigin(0.5);
                
                this.input.keyboard.on('keydown-ESC', () => {
                    this.scene.stop();
                    this.scene.resume('GameScene');
                });
            }
        }
        
        // Phaser configuration
        const config = {
            type: Phaser.AUTO,
            width: GAME_WIDTH,
            height: GAME_HEIGHT,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: [GameScene, PauseScene],
            fps: {
                target: 60,
                forceSetTimeOut: true
            },
            render: {
                antialias: false,
                pixelArt: false,
                roundPixels: true
            }
        };
    </script>
</body>
</html>