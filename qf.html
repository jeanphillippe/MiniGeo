<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Frontier</title>
  </head>
  <body>
    <div id="gameContainer">
      <div id="intro">
        <h1>Quantum Frontier</h1>
        <p>Navigate through hostile space territories.Defend against alien sentries orbiting distant worlds.Use WASD or Arrow Keys to move,SPACE to fire.Keys 1-5 to change weapons.Stay alert-enemies will attack when you get too close!</p>
        <button id="startBtn">Launch Mission</button>
      </div>
      <div id="hud">
        <div id="healthHud">✚ <span id="health">100</span>
        </div>
        <div id="scoreHud">★ <span id="score">0</span>
        </div>
        <div id="weaponHud">
          <span id="currentWeapon">1-Blaster</span>
        </div>
        <div id="coordinates">
          <span id="posX">0</span>, <span id="posZ">0</span>
        </div>
      </div>
      <div id="minimap">
        <canvas id="minimapCanvas" width="120" height="120"></canvas>
        <div id="minimapToggle">⊞</div>
      </div>
      <div id="effects"></div>
      <div id="controls">
        <div>WASD/Arrows-Move</div>
        <div>SPACE-Fire</div>
        <div>1-5-Weapons</div>
      </div>
      <div id="mobileControls">
        <div id="dpad">
          <div id="dpadOuter"></div>
          <div id="dpadInner"></div>
        </div>
        <div id="fireBtn">FIRE</div>
        <div id="weaponBtn">W <br>1 </div>
      </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script>
      const CONFIG = {
        player: {
          acc: 0.1,
          maxSpeed: 0.8,
          friction: 0.92,
          health: 1000
        },
        space: {
          starCount: 1000,
          rotSpeed: 0.0001,
          size: 600
        },
        enemy: {
          orbitMod: 8,
          baseSpeed: 0.015,
          speedVar: 0.005,
          attackRange: 40,
          health: 30,
          chaseSpeed: 0.3,
          retSpeed: 0.3,
          shootCooldown: 120,
          minDistance: 4
        },
        bullet: {
          speed: 2,
          life: 80,
          damage: 10,
          enemySpeed: 1.5,
          enemyDamage: 15
        },
        weapons: {
          laser: {
            damage: 20,
            width: 10,
            maxDist: 100
          }
        },
        audio: {
          speed: {
            color: 0x00ff00,
            effect: 'speed',
            mult: 1.5,
            duration: 30000
          },
          damage: {
            color: 0xff0000,
            effect: 'damage',
            mult: 2,
            duration: 30000
          },
          health: {
            color: 0x0088ff,
            effect: 'health',
            amount: 200,
            duration: 0
          }
        }
      };
      class ShipFactory {
        static templates = {
          player: {
            type: 'tie',
            scale: 0.9,
            cockpit: 'octahedron',
            cockpitScale: 1.5,
            panelCount: 2,
            panelShape: 'diamond',
            panelSize: 4,
            panelDist: 2.2,
            panelThick: 0.1,
            panelY: 0.2,
            panelZ: 0.1,
            panelRotX: -50,
            panelRotY: 0,
            panelAngle: 0,
            hasStruts: !0,
            strutType: 'hexagonal',
            strutThick: 0.19,
            strutCount: 1,
            strutAngle: -90,
            primaryColor: 0x3742fa,
            secondaryColor: 0x2f3542,
            accentColor: 0x70a1ff,
            cockpitColor: 0xff4757
          },
          fighter: {
            type: 'classic',
            scale: 1,
            bodyWidth: 1.5,
            bodyHeight: 0.2,
            bodyLength: 3,
            hasWings: !0,
            wingSpan: 3,
            wingThick: 0.15,
            wingPos: 0,
            wingRotY: 0,
            wingDihedral: 0,
            engineCount: 2,
            engineSize: 0.25,
            enginePosZ: -1.5,
            engineSpacing: 1.5,
            hasCockpit: !0,
            cockpit: 'sphere',
            cockpitScale: 0.3,
            cockpitY: 0.2,
            cockpitZ: 1,
            primaryColor: 0xff4757,
            secondaryColor: 0xff3838,
            accentColor: 0xff6b6b,
            cockpitColor: 0x2f3542
          },
          interceptor: {
            type: 'tie',
            scale: 1.33,
            cockpit: 'sphere',
            cockpitScale: 1.2,
            panelCount: 2,
            panelShape: 'hexagon',
            panelSize: 2,
            panelDist: 2.5,
            panelThick: 0.1,
            panelY: 0,
            panelZ: 0,
            panelRotX: 5,
            panelRotY: -90,
            panelAngle: 90,
            hasStruts: !0,
            strutType: 'cylinder',
            strutThick: 0.11,
            strutCount: 1,
            strutAngle: 90,
            primaryColor: 0x9b59b6,
            secondaryColor: 0x8e44ad,
            accentColor: 0xd63031,
            cockpitColor: 0x2d3436
          },
          heavy: {
            type: 'classic',
            scale: 1.2,
            bodyWidth: 2.5,
            bodyHeight: 0.4,
            bodyLength: 5,
            hasWings: !0,
            wingSpan: 5,
            wingThick: 0.3,
            wingPos: -1.5,
            wingRotY: 0,
            wingDihedral: 0,
            engineCount: 4,
            engineSize: 0.4,
            enginePosZ: -2.5,
            engineSpacing: 1.5,
            hasCockpit: !0,
            cockpit: 'sphere',
            cockpitScale: 0.5,
            cockpitY: 0.4,
            cockpitZ: 1.5,
            primaryColor: 0x2ed573,
            secondaryColor: 0x1e90ff,
            accentColor: 0x7bed9f,
            cockpitColor: 0xff5252
          },
          scout: {
            type: 'classic',
            scale: 1.6,
            bodyWidth: 1.2,
            bodyHeight: 0.6,
            bodyLength: 4.6,
            hasWings: !0,
            wingSpan: 5.6,
            wingThick: 0.15,
            wingPos: -1.5,
            wingRotY: 0,
            wingDihedral: 0,
            engineCount: 2,
            engineSize: 0.4,
            enginePosZ: -2,
            engineSpacing: 1.6,
            hasCockpit: !0,
            cockpit: 'sphere',
            cockpitScale: 0.5,
            cockpitY: 0.3,
            cockpitZ: -0.5,
            primaryColor: 0xfeca57,
            secondaryColor: 0x2ed9ff,
            accentColor: 0xfeca57,
            cockpitColor: 0x616161
          },
          purplediamond: {
            type: 'tie',
            scale: 1.8,
            cockpit: 'octahedron',
            cockpitScale: 2.1,
            panelCount: 2,
            panelShape: 'triangle',
            panelSize: 1.4,
            panelDist: 2,
            panelThick: 0.5,
            panelY: 0,
            panelZ: 0.1,
            panelRotX: 35,
            panelRotY: 5,
            panelAngle: 0,
            hasStruts: !1,
            strutType: 'cylinder',
            strutThick: 0.19,
            strutCount: 3,
            strutAngle: -10,
            primaryColor: 0x5f27cd,
            secondaryColor: 0xfeca57,
            accentColor: 0x96ceb4,
            cockpitColor: 0x5f27cd
          },
          doradito: {
            type: 'tie',
            scale: 0.5,
            cockpit: 'dodecahedron',
            cockpitScale: 2.1,
            panelCount: 2,
            panelShape: 'diamond',
            panelSize: 4,
            panelDist: 3.3,
            panelThick: 0.4,
            panelY: 0.2,
            panelZ: -2,
            panelRotX: -90,
            panelRotY: 90,
            panelAngle: 0,
            hasStruts: !0,
            strutType: 'box',
            strutThick: 0.29,
            strutCount: 2,
            strutAngle: -40,
            primaryColor: 0xff9f43,
            secondaryColor: 0xff6b6b,
            accentColor: 0xfeca57,
            cockpitColor: 0xfeca57
          }
        };
        static geometries = {
          hexagon: (sz) => new THREE.CylinderGeometry(sz, sz, 0.1, 6),
          square: (sz) => new THREE.BoxGeometry(sz, sz, 0.1),
          diamond: (sz) => {
            const g = new THREE.OctahedronGeometry(sz / 1.4);
            g.scale(1, 1, 0.1);
            return g
          },
          circle: (sz) => new THREE.CylinderGeometry(sz / 2, sz / 2, 0.1, 16),
          triangle: (sz) => {
            const g = new THREE.ConeGeometry(sz, 0.1, 3);
            g.rotateX(Math.PI / 2);
            return g
          },
          star: (sz) => {
            const shape = new THREE.Shape();
            const outerRadius = sz;
            const innerRadius = sz * 0.5;
            const spikes = 5;
            for (let i = 0; i < spikes * 2; i++) {
              const angle = (i / (spikes * 2)) * Math.PI * 2;
              const radius = i % 2 === 0 ? outerRadius : innerRadius;
              const x = Math.cos(angle) * radius;
              const y = Math.sin(angle) * radius;
              if (i === 0) shape.moveTo(x, y);
              else shape.lineTo(x, y)
            }
            return new THREE.ExtrudeGeometry(shape, {
              depth: 0.1,
              bevelEnabled: !1
            })
          }
        };
        static create(templateName, customProps = {}) {
          const template = {
            ...this.templates[templateName],
            ...customProps
          };
          if (!template) {
            console.warn(`Ship template '${templateName}' not found`);
            return this.create('fighter')
          }
          return template.type === 'tie' ? this.createTieShip(template) : this.createClassicShip(template)
        }
        static createTieShip(cfg) {
          const ship = new THREE.Group();
          const sc = cfg.scale || 1.8;
          let cockpitGeom;
          switch (cfg.cockpit || 'sphere') {
            case 'sphere':
              cockpitGeom = new THREE.SphereGeometry((cfg.cockpitScale || 1.2) * sc, 12, 12);
              break;
            case 'box':
              cockpitGeom = new THREE.BoxGeometry((cfg.cockpitScale || 1.2) * sc, (cfg.cockpitScale || 1.2) * sc, (cfg.cockpitScale || 1.2) * sc);
              break;
            case 'octahedron':
              cockpitGeom = new THREE.OctahedronGeometry((cfg.cockpitScale || 1.2) * sc);
              break;
            case 'cylinder':
              cockpitGeom = new THREE.CylinderGeometry((cfg.cockpitScale || 1.2) * sc, (cfg.cockpitScale || 1.2) * sc, (cfg.cockpitScale || 1.2) * sc, 8);
              break;
            case 'dodecahedron':
              cockpitGeom = new THREE.DodecahedronGeometry((cfg.cockpitScale || 1.2) * sc);
              break;
            default:
              cockpitGeom = new THREE.SphereGeometry((cfg.cockpitScale || 1.2) * sc, 12, 12)
          }
          const cockpitMat = new THREE.MeshLambertMaterial({
            color: cfg.cockpitColor || 0xff5252
          });
          const cockpit = new THREE.Mesh(cockpitGeom, cockpitMat);
          ship.add(cockpit);
          for (let i = 0; i < (cfg.panelCount || 2); i++) {
            const panelGeom = this.geometries[cfg.panelShape || 'hexagon']((cfg.panelSize || 2) * sc);
            panelGeom.scale(1, 1, (cfg.panelThick || 0.1) * sc * 10);
            const panelMat = new THREE.MeshLambertMaterial({
              color: cfg.primaryColor || 0x2ed573
            });
            const panel = new THREE.Mesh(panelGeom, panelMat);
            const angle = (i * Math.PI * 2) / (cfg.panelCount || 2);
            const x = Math.cos(angle) * (cfg.panelDist || 2.5) * sc;
            const z = Math.sin(angle) * (cfg.panelDist || 2.5) * sc;
            panel.position.set(x, (cfg.panelY || 0) * sc, z + (cfg.panelZ || 0) * sc);
            panel.rotation.x = ((cfg.panelRotX || 0) * Math.PI) / 180;
            panel.rotation.y = angle + Math.PI / 2 + ((cfg.panelRotY || 0) * Math.PI) / 180;
            panel.rotation.z = ((cfg.panelAngle || 0) * Math.PI) / 180;
            ship.add(panel);
            if (cfg.hasStruts !== !1) {
              for (let s = 0; s < (cfg.strutCount || 1); s++) {
                let strutGeom;
                const strutLength = (cfg.panelDist || 2.5) * sc * 0.8;
                switch (cfg.strutType || 'cylinder') {
                  case 'cylinder':
                    strutGeom = new THREE.CylinderGeometry((cfg.strutThick || 0.1) * sc, (cfg.strutThick || 0.1) * sc, strutLength, 8);
                    break;
                  case 'box':
                    strutGeom = new THREE.BoxGeometry((cfg.strutThick || 0.1) * sc * 2, strutLength, (cfg.strutThick || 0.1) * sc * 2);
                    break;
                  case 'hexagonal':
                    strutGeom = new THREE.CylinderGeometry((cfg.strutThick || 0.1) * sc, (cfg.strutThick || 0.1) * sc, strutLength, 6);
                    break;
                  default:
                    strutGeom = new THREE.CylinderGeometry((cfg.strutThick || 0.1) * sc, (cfg.strutThick || 0.1) * sc, strutLength, 8)
                }
                const strutMat = new THREE.MeshLambertMaterial({
                  color: cfg.secondaryColor || 0x1e90ff
                });
                const strut = new THREE.Mesh(strutGeom, strutMat);
                const strutOffset = (cfg.strutCount || 1) > 1 ? (s - ((cfg.strutCount || 1) - 1) / 2) * 0.3 * sc : 0;
                const strutX = x / 2;
                const strutZ = (z + (cfg.panelZ || 0) * sc) / 2 + strutOffset;
                strut.position.set(strutX, (cfg.panelY || 0) * sc / 2, strutZ);
                strut.rotation.z = -angle + ((cfg.strutAngle || 0) * Math.PI) / 180;
                if ((cfg.strutType || 'cylinder') === 'box') {
                  strut.rotation.y = angle
                }
                ship.add(strut)
              }
            }
          }
          return ship
        }
        static createClassicShip(cfg) {
          const ship = new THREE.Group();
          const sc = cfg.scale || 1.8;
          const bodyGeom = new THREE.BoxGeometry((cfg.bodyWidth || 2) * sc, (cfg.bodyHeight || 0.3) * sc, (cfg.bodyLength || 4) * sc);
          const bodyMat = new THREE.MeshLambertMaterial({
            color: cfg.primaryColor || 0x2ed573
          });
          const body = new THREE.Mesh(bodyGeom, bodyMat);
          ship.add(body);
          if (cfg.hasWings !== !1) {
            const wingGeom = new THREE.BoxGeometry((cfg.wingSpan || 4) * sc, (cfg.wingThick || 0.2) * sc, 1 * sc);
            const wingMat = new THREE.MeshLambertMaterial({
              color: cfg.secondaryColor || 0x1e90ff
            });
            const wing = new THREE.Mesh(wingGeom, wingMat);
            wing.position.set(0, -0.1 * sc, (cfg.wingPos || -1) * sc);
            wing.rotation.z = ((cfg.wingRotY || 0) * Math.PI) / 180;
            wing.rotation.x = ((cfg.wingDihedral || 0) * Math.PI) / 180;
            ship.add(wing)
          }
          const engineCount = cfg.engineCount || 2;
          const engineSpacing = cfg.engineSpacing || 1.5;
          const enginePositions = [];
          if (engineCount === 1) {
            enginePositions.push([0, 0])
          } else if (engineCount === 2) {
            enginePositions.push([-(engineSpacing * sc), 0], [engineSpacing * sc, 0])
          } else if (engineCount === 3) {
            enginePositions.push([0, 0], [-(engineSpacing * sc), 0], [engineSpacing * sc, 0])
          } else if (engineCount === 4) {
            enginePositions.push([-(engineSpacing * sc), 0], [engineSpacing * sc, 0], [-(engineSpacing * sc), 0.3 * sc], [engineSpacing * sc, 0.3 * sc])
          } else if (engineCount === 6) {
            enginePositions.push([-(engineSpacing * sc), 0], [engineSpacing * sc, 0], [-(engineSpacing * sc) * 0.7, 0.3 * sc], [engineSpacing * sc * 0.7, 0.3 * sc], [-(engineSpacing * sc) * 0.7, -0.3 * sc], [engineSpacing * sc * 0.7, -0.3 * sc])
          }
          for (let i = 0; i < enginePositions.length; i++) {
            const engineGeom = new THREE.SphereGeometry((cfg.engineSize || 0.3) * sc, 8, 8);
            const engineMat = new THREE.MeshBasicMaterial({
              color: cfg.accentColor || 0x7bed9f,
              transparent: !0,
              opacity: 0.8
            });
            const engine = new THREE.Mesh(engineGeom, engineMat);
            engine.position.set(enginePositions[i][0], enginePositions[i][1], (cfg.enginePosZ || -2) * sc);
            ship.add(engine)
          }
          if (cfg.hasCockpit !== !1) {
            let cockpitGeom;
            switch (cfg.cockpit || 'sphere') {
              case 'sphere':
                cockpitGeom = new THREE.SphereGeometry((cfg.cockpitScale || 0.4) * sc, 8, 8);
                break;
              case 'box':
                cockpitGeom = new THREE.BoxGeometry((cfg.cockpitScale || 0.4) * sc, (cfg.cockpitScale || 0.4) * sc, (cfg.cockpitScale || 0.4) * sc);
                break;
              case 'cylinder':
                cockpitGeom = new THREE.CylinderGeometry((cfg.cockpitScale || 0.4) * sc, (cfg.cockpitScale || 0.4) * sc, (cfg.cockpitScale || 0.4) * sc, 8);
                break;
              case 'cone':
                cockpitGeom = new THREE.ConeGeometry((cfg.cockpitScale || 0.4) * sc, (cfg.cockpitScale || 0.4) * sc * 1.5, 8);
                break;
              default:
                cockpitGeom = new THREE.SphereGeometry((cfg.cockpitScale || 0.4) * sc, 8, 8)
            }
            const cockpitMat = new THREE.MeshLambertMaterial({
              color: cfg.cockpitColor || 0xff5252
            });
            const cockpit = new THREE.Mesh(cockpitGeom, cockpitMat);
            cockpit.position.set(0, (cfg.cockpitY || 0.3) * sc, (cfg.cockpitZ || 0.5) * sc);
            ship.add(cockpit)
          }
          return ship
        }
      }
      class EnemyFactory {
        static types = {
          'f': {
            shipType: 'fighter',
            health: 30,
            chaseSpeed: 0.4,
            weaponType: 'rapid',
            attackRange: 40,
            score: 100
          },
          'i': {
            shipType: 'interceptor',
            health: 50,
            chaseSpeed: 0.5,
            weaponType: 'burst',
            attackRange: 40,
            score: 150
          },
          's': {
            shipType: 'scout',
            health: 50,
            chaseSpeed: 0.6,
            weaponType: 'burst',
            attackRange: 40,
            score: 150
          },
          'd': {
            shipType: 'doradito',
            health: 50,
            chaseSpeed: 0.6,
            weaponType: 'burst',
            attackRange: 40,
            score: 150
          },
          'p': {
            shipType: 'purplediamond',
            health: 50,
            chaseSpeed: 0.6,
            weaponType: 'burst',
            attackRange: 40,
            score: 150
          },
          'h': {
            shipType: 'heavy',
            health: 100,
            chaseSpeed: 0.3,
            weaponType: 'heavy',
            attackRange: 45,
            score: 200
          }
        };
        static create(type, planet, index, totalCount) {
          const config = this.types[type];
          if (!config) {
            console.warn(`Enemy type '${type}' not found`);
            return null
          }
          const ship = ShipFactory.create(config.shipType);
          const angle = (index * Math.PI * 2) / totalCount;
          return {
            mesh: ship,
            planet: planet,
            angle: angle,
            originalAngle: angle,
            speed: CONFIG.enemy.baseSpeed + Math.random() * CONFIG.enemy.speedVar,
            attackRange: config.attackRange,
            attacking: !1,
            retreating: !1,
            health: config.health,
            maxHealth: config.health,
            type: type,
            chaseSpeed: config.chaseSpeed,
            shootCooldown: 0,
            weaponType: config.weaponType,
            score: config.score,
            stuck: !1
          }
        }
      }
      class PlanetFactory {
        static configs = [{
    radius: 18, 
    color: 0xff6b6b, 
    distance: 100, 
    enemyCount: 9, 
    enemyType: 'f', 
    health: 200,
    // NUEVAS PROPIEDADES DE ÓRBITA
    orbitCenter: { x: 0, z: 0 },     // Centro de órbita
    orbitSpeed: 0.005,               // Velocidad de rotación
    startAngle: 0                    // Ángulo inicial
  },
  {
    radius: 25, 
    color: 0x00ff88, 
    distance: 180, 
    enemyCount: 6, 
    enemyType: 'd', 
    health: 300,
    orbitCenter: { x: 0, z: 0 },
    orbitSpeed: 0.003,
    startAngle: Math.PI / 4
  },
  {
    radius: 25, 
    color: 0x00ff88, 
    distance: 220, 
    enemyCount: 6, 
    enemyType: 'p', 
    health: 300,
    orbitCenter: { x: 50, z: 50 },   // Ejemplo: centro diferente
    orbitSpeed: 0.002,
    startAngle: Math.PI / 2
  }];
        static createPlanetTexture(color, radius, type) {
          const canvas = document.createElement('canvas');
          canvas.width = 512;
          canvas.height = 512;
          const ctx = canvas.getContext('2d');
          const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
          if (type === 'gas') {
            gradient.addColorStop(0, `hsl(${(color >> 16) & 255}, 70%, 60%)`);
            gradient.addColorStop(0.3, `hsl(${((color >> 8) & 255) + 20}, 80%, 45%)`);
            gradient.addColorStop(0.7, `hsl(${(color & 255) + 40}, 60%, 35%)`);
            gradient.addColorStop(1, `hsl(${(color >> 16) & 255}, 50%, 25%)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            for (let i = 0; i < 8; i++) {
              ctx.strokeStyle = `hsla(${((color >> 8) & 255) + i * 10}, 60%, ${40 + i * 3}%, 0.6)`;
              ctx.lineWidth = 2 + Math.random() * 3;
              ctx.beginPath();
              ctx.moveTo(0, 100 + i * 40 + Math.sin(i) * 20);
              for (let x = 0; x < 512; x += 10) {
                ctx.lineTo(x, 100 + i * 40 + Math.sin(x * 0.02 + i) * 15 + Math.cos(x * 0.01) * 10)
              }
              ctx.stroke()
            }
          } else if (type === 'ice') {
            const iceGrad = ctx.createLinearGradient(0, 0, 512, 512);
            iceGrad.addColorStop(0, '#b3e5fc');
            iceGrad.addColorStop(0.5, '#81d4fa');
            iceGrad.addColorStop(1, '#4fc3f7');
            ctx.fillStyle = iceGrad;
            ctx.fillRect(0, 0, 512, 512);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            for (let i = 0; i < 200; i++) {
              const x = Math.random() * 512;
              const y = Math.random() * 512;
              const size = Math.random() * 3 + 1;
              ctx.fillRect(x, y, size, size)
            }
            for (let i = 0; i < 50; i++) {
              ctx.strokeStyle = 'rgba(200, 230, 255, 0.6)';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.arc(Math.random() * 512, Math.random() * 512, Math.random() * 20 + 5, 0, Math.PI * 2);
              ctx.stroke()
            }
          } else {
            const baseHue = (color >> 16) & 255;
            ctx.fillStyle = `hsl(${baseHue}, 40%, 35%)`;
            ctx.fillRect(0, 0, 512, 512);
            for (let i = 0; i < 100; i++) {
              const x = Math.random() * 512;
              const y = Math.random() * 512;
              const size = Math.random() * 15 + 5;
              ctx.fillStyle = `hsla(${baseHue + Math.random() * 30 - 15}, 50%, ${25 + Math.random() * 20}%, 0.7)`;
              ctx.beginPath();
              ctx.arc(x, y, size, 0, Math.PI * 2);
              ctx.fill()
            }
            for (let i = 0; i < 50; i++) {
              const x = Math.random() * 512;
              const y = Math.random() * 512;
              const size = Math.random() * 8 + 3;
              ctx.fillStyle = `hsla(${baseHue}, 30%, 20%, 0.8)`;
              ctx.beginPath();
              ctx.arc(x, y, size, 0, Math.PI * 2);
              ctx.fill()
            }
          }
          return new THREE.CanvasTexture(canvas)
        }
        static create(index, config = null) {
  const cfg = config || this.configs[index % this.configs.length];
  
  const planetTypes = ['rocky', 'gas', 'rocky', 'rocky', 'gas'];
  // Calcular posición inicial usando centro de órbita y ángulo inicial
  const initialAngle = cfg.startAngle || ((Math.PI * 2 / this.configs.length) * index);
  const planetGeom = new THREE.SphereGeometry(cfg.radius, 32, 32);
  const texture = this.createPlanetTexture(cfg.color, cfg.radius, planetTypes[index % planetTypes.length]);
  const planetMat = new THREE.MeshLambertMaterial({ map: texture, color: cfg.color });
  const planet = new THREE.Mesh(planetGeom, planetMat);
  
  // Posición inicial basada en centro de órbita
  const x = (cfg.orbitCenter?.x || 0) + Math.cos(initialAngle) * cfg.distance;
  const z = (cfg.orbitCenter?.z || 0) + Math.sin(initialAngle) * cfg.distance;
  planet.position.set(x, 0, z);
  planet.rotation.y = Math.random() * Math.PI * 2;
  
  const orbitRadius = cfg.radius + CONFIG.enemy.orbitMod;
  
  return {
    mesh: planet,
    radius: orbitRadius,
    center: planet.position.clone(),
    config: cfg,
    health: cfg.health,
    maxHealth: cfg.health,
    destroyed: false,
    // NUEVAS PROPIEDADES PARA ÓRBITA
    orbitCenter: { x: cfg.orbitCenter?.x || 0, z: cfg.orbitCenter?.z || 0 },
    orbitDistance: cfg.distance,
    orbitSpeed: cfg.orbitSpeed || 0.001,
    currentAngle: initialAngle
  };
}
      }
      class PerlinNoise {
        constructor(seed = Math.random()) {
          this.seed = seed;
          this.p = [];
          for (let i = 0; i < 512; i++) {
            this.p[i] = Math.floor(Math.random() * 256)
          }
          for (let i = 0; i < 256; i++) {
            this.p[256 + i] = this.p[i]
          }
        }
        fade(t) {
          return t * t * t * (t * (t * 6 - 15) + 10)
        }
        lerp(t, a, b) {
          return a + t * (b - a)
        }
        grad(hash, x, y, z) {
          const h = hash & 15;
          const u = h < 8 ? x : y;
          const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
          return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v)
        }
        noise(x, y, z) {
          const X = Math.floor(x) & 255;
          const Y = Math.floor(y) & 255;
          const Z = Math.floor(z) & 255;
          x -= Math.floor(x);
          y -= Math.floor(y);
          z -= Math.floor(z);
          const u = this.fade(x);
          const v = this.fade(y);
          const w = this.fade(z);
          const A = this.p[X] + Y;
          const AA = this.p[A] + Z;
          const AB = this.p[A + 1] + Z;
          const B = this.p[X + 1] + Y;
          const BA = this.p[B] + Z;
          const BB = this.p[B + 1] + Z;
          return this.lerp(w, this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y, z), this.grad(this.p[BA], x - 1, y, z)), this.lerp(u, this.grad(this.p[AB], x, y - 1, z), this.grad(this.p[BB], x - 1, y - 1, z))), this.lerp(v, this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1), this.grad(this.p[BA + 1], x - 1, y, z - 1)), this.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1), this.grad(this.p[BB + 1], x - 1, y - 1, z - 1))))
        }
        turbulence2d(x, y, octaves, persistence) {
          let value = 0;
          let amplitude = 1;
          let frequency = 1;
          let maxValue = 0;
          for (let i = 0; i < octaves; i++) {
            value += Math.abs(this.noise(x * frequency, y * frequency, 0)) * amplitude;
            maxValue += amplitude;
            amplitude *= persistence;
            frequency *= 2
          }
          return value / maxValue
        }
      }
      class Gradient {
        constructor() {
          this.points = []
        }
        add(point) {
          this.points.push(point);
          this.points.sort((a, b) => a[0] - b[0])
        }
        get(t) {
          if (this.points.length === 0) return [0, 0, 0];
          if (t <= this.points[0][0]) return [this.points[0][1], this.points[0][2], this.points[0][3]];
          if (t >= this.points[this.points.length - 1][0]) {
            const last = this.points[this.points.length - 1];
            return [last[1], last[2], last[3]]
          }
          for (let i = 0; i < this.points.length - 1; i++) {
            const p1 = this.points[i];
            const p2 = this.points[i + 1];
            if (t >= p1[0] && t <= p2[0]) {
              const factor = (t - p1[0]) / (p2[0] - p1[0]);
              return [Math.floor(p1[1] + (p2[1] - p1[1]) * factor), Math.floor(p1[2] + (p2[2] - p1[2]) * factor), Math.floor(p1[3] + (p2[3] - p1[3]) * factor)]
            }
          }
          return [0, 0, 0]
        }
      }
      class DeepSpaceGenerator {
        constructor() {
          this.createTexture()
        }
        createTexture() {
          const canvas = document.createElement('canvas');
          canvas.width = canvas.height = 1024;
          const ctx = canvas.getContext('2d');
          const imageData = ctx.getImageData(0, 0, 1024, 1024);
          const noise1 = new PerlinNoise(Math.random());
          const noise2 = new PerlinNoise(Math.random());
          const noise3 = new PerlinNoise(Math.random());
          const gradient = new Gradient();
          const colorThemes = [
            [
              [5, 5, 15],
              [15, 25, 45],
              [25, 15, 60],
              [10, 5, 25]
            ],
            [
              [15, 5, 5],
              [45, 15, 25],
              [60, 25, 15],
              [25, 10, 5]
            ],
            [
              [5, 15, 10],
              [15, 45, 35],
              [25, 60, 45],
              [10, 25, 15]
            ],
            [
              [15, 5, 15],
              [35, 15, 45],
              [50, 25, 60],
              [20, 10, 25]
            ]
          ];
          const theme = colorThemes[Math.floor(Math.random() * colorThemes.length)];
          gradient.add([0, theme[0][0], theme[0][1], theme[0][2]]);
          gradient.add([0.3, theme[1][0], theme[1][1], theme[1][2]]);
          gradient.add([0.6, theme[2][0], theme[2][1], theme[2][2]]);
          gradient.add([1, theme[3][0], theme[3][1], theme[3][2]]);
          const data = imageData.data;
          for (let y = 0; y < 1024; y++) {
            for (let x = 0; x < 1024; x++) {
              const nx = x / 1024 * 8;
              const ny = y / 1024 * 8;
              let noiseValue = noise1.turbulence2d(nx, ny, 8, 0.6);
              noiseValue += noise2.turbulence2d(nx * 2, ny * 2, 4, 0.3) * 0.5;
              noiseValue += noise3.noise(nx * 4, ny * 4, 0) * 0.3;
              noiseValue = Math.pow(Math.max(0, Math.min(1, noiseValue)), 2);
              const color = gradient.get(noiseValue);
              const index = (y * 1024 + x) * 4;
              data[index] = color[0];
              data[index + 1] = color[1];
              data[index + 2] = color[2];
              data[index + 3] = 255
            }
          }
          ctx.putImageData(imageData, 0, 0);
          const texture = new THREE.CanvasTexture(canvas);
          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(1, 1);
          texture.needsUpdate = !0;
          const geometry = new THREE.PlaneGeometry(3000, 3000);
          const material = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: !1,
            opacity: 1
          });
          this.mesh = new THREE.Mesh(geometry, material);
          this.mesh.position.z = -800;
          this.texture = texture
        }
        update(playerX, playerZ) {
          this.mesh.position.x = playerX * 0.2;
          this.mesh.position.y = playerZ * 0.2;
          this.texture.offset.x += 0.000005;
          this.texture.offset.y += 0.000005;
          this.texture.offset.x += playerX * 0.0000009;
          this.texture.offset.y += playerZ * 0.0000009
        }
      }
      class NebulaGenerator {
        constructor() {
          this.group = new THREE.Group();
          this.createNebulas()
        }
        createNebulas() {
          const nebulaColors = [
            [
              [0, 0, 0],
              [0, 30, 80],
              [20, 100, 200],
              [80, 150, 255]
            ],
            [
              [0, 0, 0],
              [60, 0, 30],
              [150, 40, 80],
              [255, 100, 150]
            ],
            [
              [0, 0, 0],
              [0, 40, 30],
              [50, 150, 100],
              [100, 255, 180]
            ],
            [
              [0, 0, 0],
              [40, 0, 60],
              [120, 50, 150],
              [200, 100, 255]
            ],
            [
              [0, 0, 0],
              [60, 20, 0],
              [200, 100, 50],
              [255, 150, 80]
            ]
          ];
          for (let layer = 0; layer < 5; layer++) {
            const nebulaTexture = this.createNebulaTexture(layer, nebulaColors[layer]);
            const size = 800 + layer * 200;
            const geometry = new THREE.PlaneGeometry(size, size);
            const material = new THREE.MeshBasicMaterial({
              map: nebulaTexture,
              transparent: !0,
              opacity: 0.3 - layer * 0.04,
              blending: THREE.AdditiveBlending
            });
            const nebula = new THREE.Mesh(geometry, material);
            nebula.position.set((Math.random() - 0.5) * 1000, (Math.random() - 0.5) * 1000, -300 - layer * 150);
            nebula.rotation.z = Math.random() * Math.PI * 2;
            this.group.add(nebula)
          }
        }
        createNebulaTexture(layer, colorScheme) {
          const canvas = document.createElement('canvas');
          canvas.width = canvas.height = 512;
          const ctx = canvas.getContext('2d');
          const imageData = ctx.getImageData(0, 0, 512, 512);
          const noise = new PerlinNoise(Math.random());
          const gradient = new Gradient();
          gradient.add([0, colorScheme[0][0], colorScheme[0][1], colorScheme[0][2]]);
          gradient.add([0.2, colorScheme[1][0], colorScheme[1][1], colorScheme[1][2]]);
          gradient.add([0.6, colorScheme[2][0], colorScheme[2][1], colorScheme[2][2]]);
          gradient.add([1, colorScheme[3][0], colorScheme[3][1], colorScheme[3][2]]);
          const data = imageData.data;
          for (let y = 0; y < 512; y++) {
            for (let x = 0; x < 512; x++) {
              const nx = (x - 256) / 512 * 8;
              const ny = (y - 256) / 512 * 8;
              const distance = Math.sqrt(nx * nx + ny * ny);
              const angle = Math.atan2(ny, nx);
              const spiral = Math.sin(angle * 3 + distance * 2) * 0.3;
              const radialFalloff = Math.max(0, (1 - distance / 4) + spiral * 0.2);
              let noiseValue = noise.turbulence2d(x / 80, y / 80, 6, 0.6);
              noiseValue += noise.turbulence2d(x / 40, y / 40, 4, 0.4) * 0.7;
              noiseValue += noise.noise(x / 20, y / 20, layer * 5) * 0.5;
              const flow = Math.sin(x / 30 + y / 20) * Math.cos(y / 25) * 0.3;
              noiseValue += flow;
              let intensity = noiseValue * radialFalloff;
              intensity = Math.pow(Math.max(0, Math.min(1, intensity)), 1.8);
              const color = gradient.get(intensity);
              const index = (y * 512 + x) * 4;
              data[index] = color[0];
              data[index + 1] = color[1];
              data[index + 2] = color[2];
              data[index + 3] = Math.floor(intensity * 200 * radialFalloff)
            }
          }
          ctx.putImageData(imageData, 0, 0);
          const texture = new THREE.CanvasTexture(canvas);
          texture.needsUpdate = !0;
          return texture
        }
        update(playerX, playerZ) {
          this.group.children.forEach((nebula, index) => {
            const parallax = 0.05 + index * 0.02;
            const targetX = playerX * parallax + (index - 2) * 200;
            const targetY = playerZ * parallax + (index - 2) * 150;
            nebula.position.x += (targetX - nebula.position.x) * 0.01;
            nebula.position.y += (targetY - nebula.position.y) * 0.01;
            nebula.rotation.z += 0.0001 * (index + 1)
          })
        }
      }
      class BackgroundManager {
        constructor(scene) {
          this.scene = scene;
          this.createStarField();
          this.createDeepSpace();
          this.createNebulas()
        }
        createStarField() {
          const starGeom = new THREE.BufferGeometry();
          const starCount = CONFIG.space.starCount;
          const positions = new Float32Array(starCount * 3);
          const colors = new Float32Array(starCount * 3);
          const sizes = new Float32Array(starCount);
          for (let i = 0; i < starCount; i++) {
            const i3 = i * 3;
            positions[i3] = (Math.random() - 0.5) * CONFIG.space.size;
            positions[i3 + 1] = (Math.random() - 0.5) * CONFIG.space.size;
            positions[i3 + 2] = (Math.random() - 0.5) * CONFIG.space.size;
            const starType = Math.random();
            if (starType < 0.7) {
              colors[i3] = colors[i3 + 1] = colors[i3 + 2] = 1.0
            } else if (starType < 0.85) {
              colors[i3] = 0.7;
              colors[i3 + 1] = 0.8;
              colors[i3 + 2] = 1.0
            } else if (starType < 0.95) {
              colors[i3] = 1.0;
              colors[i3 + 1] = 1.0;
              colors[i3 + 2] = 0.7
            } else {
              colors[i3] = 1.0;
              colors[i3 + 1] = 0.7;
              colors[i3 + 2] = 0.7
            }
            sizes[i] = Math.random() * 2 + 0.5
          }
          starGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          starGeom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
          starGeom.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
          const starMat = new THREE.PointsMaterial({
            size: 1.0,
            vertexColors: !0,
            transparent: !0,
            opacity: 0.8,
            sizeAttenuation: !0
          });
          this.stars = new THREE.Points(starGeom, starMat);
          this.scene.add(this.stars)
        }
        createDeepSpace() {
          this.deepSpaceGenerator = new DeepSpaceGenerator();
          this.scene.add(this.deepSpaceGenerator.mesh)
        }
        createNebulas() {
          this.nebulaGenerator = new NebulaGenerator();
          this.scene.add(this.nebulaGenerator.group)
        }
        update(playerX, playerZ) {
          this.stars.rotation.y += CONFIG.space.rotSpeed;
          if (this.deepSpaceGenerator) {
            this.deepSpaceGenerator.update(playerX, playerZ)
          }
          if (this.nebulaGenerator) {
            this.nebulaGenerator.update(playerX, playerZ)
          }
        }
      }
      class MinimapManager {
        constructor() {
          this.canvas = document.getElementById('minimapCanvas');
          this.ctx = this.canvas.getContext('2d');
          this.expanded = !1;
          this.setupEvents()
        }
        setupEvents() {
          document.getElementById('minimapToggle').addEventListener('click', () => {
            this.toggleExpanded()
          })
        }
        toggleExpanded() {
          this.expanded = !this.expanded;
          const minimap = document.getElementById('minimap');
          const toggle = document.getElementById('minimapToggle');
          if (this.expanded) {
            minimap.classList.add('expanded');
            toggle.textContent = '⊟';
            this.canvas.width = this.canvas.height = 300
          } else {
            minimap.classList.remove('expanded');
            toggle.textContent = '⊞';
            this.canvas.width = this.canvas.height = 120
          }
        }
        update(playerPos, planets, enemies) {
          const ctx = this.ctx;
          const size = this.expanded ? 300 : 120;
          const scale = this.expanded ? 0.8 : 0.3;
          const centerX = size / 2;
          const centerY = size / 2;
          ctx.clearRect(0, 0, size, size);
          ctx.fillStyle = 'rgba(0, 0, 20, 0.9)';
          ctx.fillRect(0, 0, size, size);
          ctx.strokeStyle = 'rgba(79, 172, 254, 0.3)';
          ctx.lineWidth = 1;
          ctx.strokeRect(1, 1, size - 2, size - 2);
          planets.forEach(planet => {
            if (planet.destroyed) return;
            const relX = (planet.center.x - playerPos.x) * scale + centerX;
            const relY = (planet.center.z - playerPos.z) * scale + centerY;
            if (relX >= -10 && relX <= size + 10 && relY >= -10 && relY <= size + 10) {
              const radius = Math.max(2, planet.config.radius * scale * 0.3);
              ctx.fillStyle = `#${planet.config.color.toString(16).padStart(6,'0')}`;
              ctx.beginPath();
              ctx.arc(relX, relY, radius, 0, Math.PI * 2);
              ctx.fill();
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
              ctx.lineWidth = 1;
              ctx.stroke()
            }
          });
          enemies.forEach(enemy => {
            if (enemy.health <= 0) return;
            const relX = (enemy.mesh.position.x - playerPos.x) * scale + centerX;
            const relY = (enemy.mesh.position.z - playerPos.z) * scale + centerY;
            if (relX >= -5 && relX <= size + 5 && relY >= -5 && relY <= size + 5) {
              ctx.fillStyle = enemy.attacking ? '#ff4757' : '#ff9f43';
              ctx.beginPath();
              ctx.arc(relX, relY, 2, 0, Math.PI * 2);
              ctx.fill()
            }
          });
          ctx.fillStyle = '#00f2fe';
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(centerX, centerY, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          const angle = Math.atan2(0, 1);
          const arrowLength = 8;
          const arrowX = centerX + Math.cos(angle) * arrowLength;
          const arrowY = centerY + Math.sin(angle) * arrowLength;
          ctx.strokeStyle = '#00f2fe';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(arrowX, arrowY);
          ctx.stroke()
        }
      }
      class AudioManager {
        constructor() {
          this.initialized = !1;
          this.audioContexts = {};
          this.lastCollisionTime = 0;
          this.mineHum = !1;
          this.engineRunning = !1;
          this.setup()
        }
        async setup() {
          try {
            this.bassSynth = new Tone.FMSynth({
              harmonicity: 8,
              modulationIndex: 25,
              oscillator: {
                type: "sine"
              },
              envelope: {
                attack: 0.001,
                decay: 0.1,
                sustain: 0.3,
                release: 0.1
              },
              modulation: {
                type: "square"
              },
              modulationEnvelope: {
                attack: 0.002,
                decay: 0.2,
                sustain: 0,
                release: 0.2
              }
            }).toDestination();
            this.shotSynth = new Tone.NoiseSynth({
              noise: {
                type: "pink"
              },
              envelope: {
                attack: 0.001,
                decay: 0.05,
                sustain: 0,
                release: 0.02
              }
            }).toDestination();
            this.explosionSynth = new Tone.NoiseSynth({
              noise: {
                type: "brown"
              },
              envelope: {
                attack: 0.001,
                decay: 0.2,
                sustain: 0,
                release: 0.3
              }
            }).toDestination();
            this.toneSynth = new Tone.Synth({
              oscillator: {
                type: "triangle"
              },
              envelope: {
                attack: 0.001,
                decay: 0.3,
                sustain: 0,
                release: 0.4
              }
            }).toDestination();
            this.laserOsc1 = new Tone.Oscillator({
              type: "sawtooth",
              frequency: 800
            });
            this.laserOsc2 = new Tone.Oscillator({
              type: "square",
              frequency: 400
            });
            this.laserFilter = new Tone.Filter({
              frequency: 2000,
              type: "lowpass",
              Q: 15
            });
            this.laserEnv = new Tone.AmplitudeEnvelope({
              attack: 0.01,
              decay: 0.1,
              sustain: 0.8,
              release: 0.2
            });
            this.laserOsc1.chain(this.laserFilter, this.laserEnv, Tone.Destination);
            this.laserOsc2.chain(this.laserFilter);
            this.laserActive = !1;
            this.uiSynth = new Tone.Synth({
              oscillator: {
                type: "sine"
              },
              envelope: {
                attack: 0.01,
                decay: 0.05,
                sustain: 0,
                release: 0.1
              }
            }).toDestination();
            this.metalSynth = new Tone.MetalSynth({
              frequency: 400,
              envelope: {
                attack: 0.001,
                decay: 0.4,
                release: 0.1
              },
              harmonicity: 12,
              modulationIndex: 64,
              resonance: 2000
            }).toDestination()
          } catch (error) {
            console.warn('Audio setup failed:', error)
          }
        }
        async start() {
          if (!this.initialized) {
            try {
              await Tone.start();
              this.initialized = !0
            } catch (error) {
              console.warn('Audio start failed:', error)
            }
          }
        }
        dispose() {
          try {
            if (this.laserOsc1 && this.laserOsc1.state === "started") this.laserOsc1.stop();
            if (this.laserOsc2 && this.laserOsc2.state === "started") this.laserOsc2.stop();
            this.laserActive = !1;
            [this.bassSynth, this.shotSynth, this.explosionSynth, this.toneSynth, this.laserOsc1, this.laserOsc2, this.laserFilter, this.laserEnv, this.uiSynth, this.metalSynth].forEach(synth => {
              if (synth && synth.dispose) {
                synth.dispose()
              }
            })
          } catch (error) {
            console.warn('Audio disposal error:', error)
          }
        }
        playBlaster() {
          if (!this.initialized) return;
          try {
            this.bassSynth.triggerAttackRelease("E5", "8n")
          } catch (e) {}
        }
        playEnemyShot() {
          if (!this.initialized) return;
          try {
            this.bassSynth.triggerAttackRelease("C4", "16n", "+0", 0.6)
          } catch (e) {}
        }
        playScatter() {
          if (!this.initialized) return;
          try {
            for (let i = 0; i < 3; i++) {
              setTimeout(() => {
                this.shotSynth.triggerAttackRelease("32n");
                this.bassSynth.triggerAttackRelease("A4", "64n", "+0", 0.3)
              }, i * 50)
            }
          } catch (e) {}
        }
        playShotgun() {
          if (!this.initialized) return;
          try {
            this.explosionSynth.triggerAttackRelease("4n");
            this.toneSynth.triggerAttackRelease("G2", "4n");
            for (let i = 0; i < 8; i++) {
              setTimeout(() => {
                this.shotSynth.triggerAttackRelease("64n", "+0", 0.4)
              }, 20 + i * 15)
            }
          } catch (e) {}
        }
        playLaser() {
          if (!this.initialized || this.laserActive) return;
          try {
            this.laserActive = !0;
            this.laserOsc1.start();
            this.laserOsc2.start();
            this.laserEnv.triggerAttack()
          } catch (e) {
            this.laserActive = !1
          }
        }
        stopLaser() {
          if (!this.initialized || !this.laserActive) return;
          try {
            this.laserEnv.triggerRelease();
            setTimeout(() => {
              if (this.laserOsc1.state === "started") this.laserOsc1.stop();
              if (this.laserOsc2.state === "started") this.laserOsc2.stop();
              this.laserActive = !1
            }, 200)
          } catch (e) {
            this.laserActive = !1
          }
        }
        playExplosion(size = 1) {
          if (!this.initialized) return;
          try {
            this.explosionSynth.triggerAttackRelease("2n");
            this.toneSynth.triggerAttackRelease("C1", "1n");
            setTimeout(() => {
              this.shotSynth.triggerAttackRelease("4n", "+0", 0.6)
            }, 100)
          } catch (e) {}
        }
        playCollision() {
          if (!this.initialized) return;
          const currentTime = Tone.now();
          if (currentTime - this.lastCollisionTime < 0.2) return;
          this.lastCollisionTime = currentTime;
          try {
            if (this.metalSynth?.triggerAttackRelease) {
              this.metalSynth.triggerAttackRelease("C4", "8n")
            }
          } catch (e) {}
        }
        playDamage() {
          if (!this.initialized) return;
          const currentTime = Tone.now();
          if (currentTime - this.lastCollisionTime < 0.15) return;
          this.lastCollisionTime = currentTime;
          try {
            if (this.metalSynth?.triggerAttackRelease) {
              this.metalSynth.triggerAttackRelease("F3", "4n");
              setTimeout(() => {
                if (this.uiSynth?.triggerAttackRelease) {
                  this.uiSynth.triggerAttackRelease("C4", "16n", "+0", 0.8)
                }
              }, 100)
            }
          } catch (e) {}
        }
        playEnemyHit() {
          if (!this.initialized) return;
          try {
            if (this.metalSynth?.triggerAttackRelease) {
              this.metalSynth.triggerAttackRelease("G4", "16n", "+0", 0.7)
            }
          } catch (e) {}
        }
        playWeaponSwitch() {
          if (!this.initialized) return;
          try {
            this.uiSynth.triggerAttackRelease("C5", "32n");
            setTimeout(() => this.uiSynth.triggerAttackRelease("G5", "32n"), 60);
            setTimeout(() => this.uiSynth.triggerAttackRelease("C6", "16n"), 120)
          } catch (e) {}
        }
        playPowerUp() {
          if (!this.initialized) return;
          try {
            const notes = ["C4", "E4", "G4", "C5", "E5"];
            notes.forEach((note, i) => {
              setTimeout(() => {
                this.uiSynth.triggerAttackRelease(note, "16n", "+0", 0.8)
              }, i * 100)
            })
          } catch (e) {}
        }
        playMine() {
          if (!this.initialized) return;
          try {
            this.toneSynth.triggerAttackRelease("A4", "16n");
            setTimeout(() => this.toneSynth.triggerAttackRelease("F4", "16n"), 100);
            setTimeout(() => this.toneSynth.triggerAttackRelease("D4", "8n"), 200)
          } catch (e) {}
        }
      }
      class SpaceShooter {
        constructor() {
          this.initializeRenderer();
          this.initializeGameState();
          this.initializeScene();
          this.setupEventListeners();
          this.animate()
        }
        updatePlanets() {
  this.planets.forEach(planet => {
    if (planet.destroyed) return;
    
    // Actualizar ángulo de órbita
    planet.currentAngle += planet.orbitSpeed;
    
    // Calcular nueva posición
    const newX = planet.orbitCenter.x + Math.cos(planet.currentAngle) * planet.orbitDistance;
    const newZ = planet.orbitCenter.z + Math.sin(planet.currentAngle) * planet.orbitDistance;
    
    // Actualizar posición del mesh
    planet.mesh.position.set(newX, 0, newZ);
    
    // Actualizar centro para cálculos de enemigos
    planet.center.set(newX, 0, newZ);
    
    // Rotación propia del planeta (opcional)
    planet.mesh.rotation.y += 0.01;
  });
}
        initializeRenderer() {
          this.scene = new THREE.Scene();
          const aspectRatio = window.innerWidth / window.innerHeight;
          const distance = 44;
          this.camera = new THREE.OrthographicCamera(-distance * aspectRatio, distance * aspectRatio, distance, -distance, 0.1, 2000);
          this.renderer = new THREE.WebGLRenderer({
            antialias: !0
          });
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.setClearColor(0x000011);
          this.renderer.sortObjects = !0;
          document.getElementById('gameContainer').appendChild(this.renderer.domElement)
        }
        initializeGameState() {
          this.gameStarted = !1;
          this.trails = [];
          this.trailStyle = 'nebula'; 
          this.player = {
            health: CONFIG.player.health,
            score: 0,
            currentWeapon: 1,
            effects: {
              speed: {
                active: !1,
                endTime: 0
              },
              damage: {
                active: !1,
                endTime: 0
              }
            }
          };
          this.keys = {};
          this.bullets = [];
          this.enemyBullets = [];
          this.artifacts = [];
          this.mines = [];
          this.enemies = [];
          this.planets = [];
          this.stars = [];
          this.collisionCooldown = 0;
          this.shootPressed = !1;
          this.playerShip = null;
          this.playerVelocity = new THREE.Vector3();
          this.laserBeam = null;
          this.touchControls = {
            moveX: 0,
            moveY: 0,
            firing: !1
          };
          this.audioManager = new AudioManager();
          this.minimapManager = new MinimapManager();
          this.explosions = [];
            this.landingState = 'none'; // 'none', 'landing', 'landed', 'taking_off'
    this.landingTarget = null;
    this.landingStartPos = null;
    this.landingProgress = 0;
    this.landingDuration = 5000; // 5 seconds in milliseconds
    this.landingStartTime = 0;
    this.wasPlayerVisible = true;
        }
        initializeScene() {
          this.camera.position.set(0, 60, 60);
          this.camera.lookAt(0, 0, 0);
          const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
          this.scene.add(ambientLight);
          const directionalLight = new THREE.DirectionalLight(0xffeedd, 0.8);
          directionalLight.position.set(1, 10, 5);
          this.scene.add(directionalLight);
          this.backgroundManager = new BackgroundManager(this.scene);
          this.createPlayer();
          this.createPlanets();
          this.createEnemies()
        }
        createPlayer() {
          this.playerShip = ShipFactory.create('player');
          this.playerShip.position.y = 5;
          this.scene.add(this.playerShip)
        }
        createPlanets() {
          for (let i = 0; i < PlanetFactory.configs.length; i++) {
            const planet = PlanetFactory.create(i);
            this.planets.push(planet);
            this.scene.add(planet.mesh)
          }
        }
        createEnemies() {
          this.planets.forEach((planet, planetIndex) => {
            const config = planet.config;
            for (let i = 0; i < config.enemyCount; i++) {
              const enemy = EnemyFactory.create(config.enemyType, planet, i, config.enemyCount);
              if (enemy) {
                this.updateEnemyPosition(enemy);
                this.enemies.push(enemy);
                this.scene.add(enemy.mesh)
              }
            }
          })
        }
        updateEnemyPosition(enemy) {
          const x = enemy.planet.center.x + Math.cos(enemy.angle) * enemy.planet.radius;
          const z = enemy.planet.center.z + Math.sin(enemy.angle) * enemy.planet.radius;
          enemy.mesh.position.set(x, 5, z)
        }
        switchWeapon(weaponNumber) {
          if (weaponNumber >= 1 && weaponNumber <= 5) {
            this.player.currentWeapon = weaponNumber;
            const weaponNames = ['Blaster', 'Scatter', 'Shotgun', 'Mines', 'Laser'];
            document.getElementById('currentWeapon').textContent = `${weaponNumber}-${weaponNames[weaponNumber-1]}`;
            document.getElementById('weaponBtn').innerHTML = `W
                                                                                                                                            
                                                                                                                                            <br>${weaponNumber}`;
            if (this.laserBeam) {
              this.scene.remove(this.laserBeam);
              this.laserBeam = null;
              this.audioManager.stopLaser()
            }
            this.audioManager.playWeaponSwitch()
          }
        }
        cycleWeapon() {
          const nextWeapon = this.player.currentWeapon % 5 + 1;
          this.switchWeapon(nextWeapon)
        }
        isPlanetLandable(planet) {
    if (planet.destroyed) return false;
    
    // Count living enemies for this planet
    const livingEnemies = this.enemies.filter(enemy => 
        enemy.planet === planet && enemy.health > 0
    ).length;
    
    return livingEnemies === 0;
}

// 3. ADD THIS NEW METHOD TO RENDER LANDING PROMPTS
renderLandingPrompts() {
    const promptsContainer = document.getElementById('landingPrompts');
    if (!promptsContainer) {
        const container = document.createElement('div');
        container.id = 'landingPrompts';
        container.style.cssText = `
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            pointer-events: none; 
            z-index: 150;
        `;
        document.getElementById('gameContainer').appendChild(container);
    }
    
    promptsContainer.innerHTML = '';
    
    if (this.landingState !== 'none') return;
    
    this.planets.forEach(planet => {
        if (!this.isPlanetLandable(planet)) return;
        
        const distanceToPlayer = planet.center.distanceTo(this.playerShip.position);
        // INCREASED RANGE - show prompt from much further away
        if (distanceToPlayer > 80) return;
        
        // Convert 3D position to screen coordinates
        const vector = planet.center.clone();
        vector.project(this.camera);
        
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (vector.y * -0.5 + 0.5) * window.innerHeight;
        
        // Check if planet is in view
        if (x >= -100 && x <= window.innerWidth + 100 && y >= -100 && y <= window.innerHeight + 100) {
            // Planet name
            const planetName = document.createElement('div');
            planetName.style.cssText = `
                position: absolute;
                left: ${x}px;
                top: ${y - 70}px;
                transform: translateX(-50%);
                color: #4facfe;
                font-family: 'Courier New', monospace;
                font-size: 18px;
                font-weight: bold;
                text-shadow: 0 0 15px rgba(79, 172, 254, 0.9);
                text-align: center;
            `;
            planetName.textContent = this.getPlanetName(planet);
            promptsContainer.appendChild(planetName);
            
            // Landing prompt - ALWAYS show "Press [E] to Land" (no "approach" message)
            const prompt = document.createElement('div');
            prompt.style.cssText = `
                position: absolute;
                left: ${x}px;
                top: ${y - 45}px;
                transform: translateX(-50%);
                color: #00ff88;
                font-family: 'Courier New', monospace;
                font-size: 14px;
                font-weight: bold;
                text-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
                background: rgba(0, 0, 0, 0.8);
                padding: 6px 14px;
                border-radius: 15px;
                border: 2px solid rgba(0, 255, 136, 0.6);
                animation: landingPulse 2s infinite;
                backdrop-filter: blur(3px);
            `;
            prompt.textContent = 'Press [E] to Land';
            promptsContainer.appendChild(prompt);
        }
    });
}
startLanding() {
    if (this.landingState !== 'none') return;
    
    // Find the nearest landable planet
    let nearestPlanet = null;
    let nearestDistance = Infinity;
    
    this.planets.forEach(planet => {
        if (!this.isPlanetLandable(planet)) return;
        
        const distance = planet.center.distanceTo(this.playerShip.position);
        if (distance < 80 && distance < nearestDistance) { // Increased range
            nearestDistance = distance;
            nearestPlanet = planet;
        }
    });
    
    if (!nearestPlanet) return;
    
    // Start landing sequence
    this.landingState = 'landing';
    this.landingTarget = nearestPlanet;
    this.landingStartPos = this.playerShip.position.clone();
    this.landingStartTime = Date.now();
    this.landingProgress = 0;
    
    // Make player invisible and invulnerable
    this.wasPlayerVisible = this.playerShip.visible;
    //this.playerShip.visible = false;
    
    // Play landing sound
    this.audioManager.playPowerUp();
}

// 4. REPLACE THE updateLanding() METHOD:
updateLanding() {
    if (this.landingState === 'none') return;
    
    const currentTime = Date.now();
    const elapsedTime = currentTime - this.landingStartTime;
    this.landingProgress = Math.min(elapsedTime / this.landingDuration, 1);
    
    if (this.landingState === 'landing') {
        if (this.landingProgress >= 1) {
            // Landing complete - NOW make ship invisible
            this.playerShip.visible = false;
            this.landingState = 'landed';
            this.showDialogue();
            return;
        }
        
        // KEEP PLAYER VISIBLE during landing animation
        this.playerShip.visible = true;
        
        // Target position - center of planet surface
        const planetCenter = this.landingTarget.center.clone();
        const targetPos = planetCenter.clone();
        targetPos.y = this.landingTarget.config.radius + 2; // On planet surface
        
        // Animate ship position from start to planet center
        const currentPos = this.landingStartPos.clone().lerp(
            targetPos, 
            this.easeInOutCubic(this.landingProgress)
        );
        this.playerShip.position.copy(currentPos);
        
        // Scale ship down as it lands (1.0 to 0.1)
        const scale = 1.0 - (this.landingProgress * 0.9);
        this.playerShip.scale.setScalar(Math.max(0.1, scale));
        
        // Position camera to watch the landing from a cinematic angle
        const planetRadius = this.landingTarget.config.radius;
        const cameraDistance = planetRadius * 2.5; // Scale camera distance with planet
        const cameraHeight = planetRadius * 1.5;
        
        // Camera orbits slightly around the planet for better view
        const cameraAngle = this.landingProgress * 0.3; // Slight rotation during landing
        const cameraPos = new THREE.Vector3(
            planetCenter.x + Math.cos(cameraAngle) * cameraDistance,
            planetCenter.y + cameraHeight,
            planetCenter.z + Math.sin(cameraAngle) * cameraDistance
        );
        
        this.camera.position.copy(cameraPos);
        this.camera.lookAt(currentPos); // Always look at the ship
        
        // Disable player velocity
        this.playerVelocity.set(0, 0, 0);
        
    } else if (this.landingState === 'taking_off') {
        if (this.landingProgress >= 1) {
            // Takeoff complete - restore normal scale
            this.playerShip.scale.setScalar(1.0);
            this.landingState = 'none';
            this.landingTarget = null;
            this.playerShip.visible = this.wasPlayerVisible;
            return;
        }
        
        // Takeoff animation - reverse of landing
        const planetPos = this.landingTarget.center.clone();
        planetPos.y = this.landingTarget.config.radius + 15;
        
        // End position should be away from planet
        const direction = new THREE.Vector3(
            Math.random() - 0.5,
            0,
            Math.random() - 0.5
        ).normalize().multiplyScalar(40);
        
        const endPos = planetPos.clone().add(direction);
        endPos.y = 5;
        
        // Animate camera from planet to end position
        const startCameraPos = new THREE.Vector3(
            planetPos.x,
            planetPos.y + 20,
            planetPos.z + 30
        );
        const endCameraPos = new THREE.Vector3(
            endPos.x,
            60,
            endPos.z + 60
        );
        
        const progress = this.easeInOutCubic(this.landingProgress);
        const currentCameraPos = startCameraPos.clone().lerp(endCameraPos, progress);
        
        this.camera.position.copy(currentCameraPos);
        
        // Update player position
        const currentPlayerPos = planetPos.clone().lerp(endPos, progress);
        this.playerShip.position.copy(currentPlayerPos);
        
        // Make player visible again near the end
        if (this.landingProgress > 0.8) {
            this.playerShip.visible = this.wasPlayerVisible;
        }
        
        // Look at player position
        this.camera.lookAt(this.playerShip.position);
    }
}

// 5. ADD THIS NEW EASING FUNCTION (smoother than quad):
easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}
// 6. ADD THIS EASING FUNCTION
easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
}

// 7. ADD THIS NEW METHOD TO SHOW DIALOGUE
showDialogue() {
    const dialogueSystem = document.getElementById('dialogueSystem');
    if (!dialogueSystem) {
        // Create dialogue system if it doesn't exist
        const dialogue = document.createElement('div');
        dialogue.id = 'dialogueSystem';
        dialogue.className = 'hidden';
        dialogue.innerHTML = `
            <div id="dialogueBox">
                <div id="dialogueContent">
                    <h3 id="dialogueTitle">Planet Surface</h3>
                    <p id="dialogueText">You have successfully landed on the planet surface.</p>
                    <div id="dialogueOptions">
                        <button class="dialogue-btn" onclick="game.closeDialogue()">Take Off</button>
                    </div>
                </div>
            </div>
        `;
        document.getElementById('gameContainer').appendChild(dialogue);
    }
    
    // Show dialogue
    document.getElementById('dialogueSystem').classList.remove('hidden');
    
    // Update dialogue content based on planet
    const planetName = this.getPlanetName(this.landingTarget);
    document.getElementById('dialogueTitle').textContent = `${planetName} Surface`;
    document.getElementById('dialogueText').textContent = 
        `You have successfully landed on ${planetName}. The planet appears to be secure.`;
}

// 6. REPLACE THE closeDialogue() METHOD:
closeDialogue() {
    document.getElementById('dialogueSystem').classList.add('hidden');
    
    // Start takeoff sequence instead of immediately returning to normal
    this.landingState = 'taking_off';
    this.landingStartTime = Date.now();
    this.landingProgress = 0;
    
    // Make sure player is still invisible during takeoff
    this.playerShip.visible = false;
    
    // Play takeoff sound
    this.audioManager.playPowerUp();
}


// 9. ADD THIS HELPER METHOD
getPlanetName(planet) {
    const planetIndex = this.planets.indexOf(planet);
    const names = ['Kepler-442b', 'Proxima Centauri b', 'TRAPPIST-1e', 'Wolf 1061c', 'Gliese 667Cc'];
    return names[planetIndex] || `Planet ${planetIndex + 1}`;
}
        fireWeapon() {
          switch (this.player.currentWeapon) {
            case 1:
              this.fireBlaster();
              break;
            case 2:
              this.fireScatter(3);
              break;
            case 3:
              this.fireScatter(5);
              break;
            case 4:
              this.fireMine();
              break;
            case 5:
              this.fireLaser();
              break
          }
        }
        fireBlaster() {
          this.createBullet(0);
          this.audioManager.playBlaster()
        }
        fireScatter(count) {
          const spreadAngle = Math.PI / 6;
          for (let i = 0; i < count; i++) {
            const angleOffset = (i - (count - 1) / 2) * (spreadAngle / (count - 1));
            this.createBullet(angleOffset)
          }
          if (count === 3) {
            this.audioManager.playScatter()
          } else {
            this.audioManager.playShotgun()
          }
        }
        createBullet(angleOffset = 0) {
          const bulletGeom = new THREE.SphereGeometry(0.2, 8, 8);
          const bulletMat = new THREE.MeshBasicMaterial({
            color: 0x00f2fe
          });
          const bullet = new THREE.Mesh(bulletGeom, bulletMat);
          bullet.position.copy(this.playerShip.position);
          bullet.position.y += 0.5;
          const direction = new THREE.Vector3(Math.sin(this.playerShip.rotation.y + angleOffset), 0, Math.cos(this.playerShip.rotation.y + angleOffset));
          const bulletVelocity = direction.clone().multiplyScalar(CONFIG.bullet.speed);
          this.bullets.push({
            mesh: bullet,
            velocity: bulletVelocity,
            life: CONFIG.bullet.life
          });
          this.scene.add(bullet)
        }
        fireMine() {
          const mineGeom = new THREE.SphereGeometry(0.5, 8, 8);
          const mineMat = new THREE.MeshBasicMaterial({
            color: 0xff4757,
            transparent: !0,
            opacity: 0.8
          });
          const mine = new THREE.Mesh(mineGeom, mineMat);
          mine.position.copy(this.playerShip.position);
          mine.position.y += 0.5;
          this.mines.push({
            mesh: mine,
            life: 600,
            exploded: !1
          });
          this.scene.add(mine);
          this.audioManager.playMine()
        }
        fireLaser() {
          if (this.laserBeam) {
            this.scene.remove(this.laserBeam)
          }
          const direction = new THREE.Vector3(Math.sin(this.playerShip.rotation.y), 0, Math.cos(this.playerShip.rotation.y));
          const laserEnd = this.playerShip.position.clone().add(direction.clone().multiplyScalar(CONFIG.weapons.laser.maxDist));
          const laserGeom = new THREE.BufferGeometry().setFromPoints([this.playerShip.position.clone().add(new THREE.Vector3(0, 0.5, 0)), laserEnd]);
          const laserMat = new THREE.LineBasicMaterial({
            color: 0x00ff00,
            transparent: !0,
            opacity: 0.8
          });
          this.laserBeam = new THREE.Line(laserGeom, laserMat);
          this.scene.add(this.laserBeam);
          this.audioManager.playLaser();
          let hitSomething = !1;
          const damage = this.player.effects.damage.active ? CONFIG.weapons.laser.damage * CONFIG.audio.damage.mult : CONFIG.weapons.laser.damage;
          this.enemies.forEach(enemy => {
            if (enemy.health > 0) {
              const distanceToLine = this.distancePointToLine(enemy.mesh.position, this.playerShip.position, laserEnd);
              if (distanceToLine < 2) {
                enemy.health -= damage;
                hitSomething = !0;
                if (enemy.health <= 0) {
                  this.createExplosion(enemy.mesh.position);
                  this.audioManager.playExplosion();
                  enemy.mesh.visible = !1;
                  this.player.score += enemy.score;
                  this.dropArtifact(enemy.mesh.position);
                  this.updateHUD()
                } else {
                  this.audioManager.playEnemyHit()
                }
              }
            }
          });
          this.planets.forEach(planet => {
            if (!planet.destroyed) {
              const distanceToLine = this.distancePointToLine(planet.center, this.playerShip.position, laserEnd);
              if (distanceToLine < planet.config.radius) {
                planet.health -= damage;
                hitSomething = !0;
                if (planet.health <= 0) {
                  this.destroyPlanet(planet)
                }
              }
            }
          })
        }
        distancePointToLine(point, lineStart, lineEnd) {
          const lineDir = new THREE.Vector3().subVectors(lineEnd, lineStart);
          const pointToStart = new THREE.Vector3().subVectors(point, lineStart);
          const t = Math.max(0, Math.min(1, pointToStart.dot(lineDir) / lineDir.dot(lineDir)));
          const projection = lineStart.clone().add(lineDir.multiplyScalar(t));
          return point.distanceTo(projection)
        }
        update() {
          if (!this.gameStarted) return;
           // ADD THESE TWO LINES:
    this.updateLanding();
    this.renderLandingPrompts();
      // Only update normal game logic if not in landing sequence
    if (this.landingState === 'none' || this.landingState === 'landed') {
        this.updatePlayer();
        this.updateTrails();
    }
    
    // Always update these systems
    this.updatePlanets();
    this.updateEnemies();
    this.updateBullets();
    this.updateEnemyBullets();
    this.updateArtifacts();
    this.updateMines();
    this.updateCollisions();
    this.updateBackground();
    this.updateEffects();
    this.updateMinimap();
    this.updateExplosions();
        }
createTrail() {
    if (Math.random() > 0.3) return; // Sparse trail creation
    
    const trailCount = 3;
    const coneAngle = Math.PI / 4; // 45 degree cone
    const behindDistance = 3;
    
    for (let i = 0; i < trailCount; i++) {
        const spreadAngle = (Math.random() - 0.5) * coneAngle;
        const playerAngle = this.playerShip.rotation.y + Math.PI; // Behind player
        const finalAngle = playerAngle + spreadAngle;
        
        const distance = behindDistance + Math.random() * 2;
        const x = this.playerShip.position.x + Math.sin(finalAngle) * distance;
        const z = this.playerShip.position.z + Math.cos(finalAngle) * distance;
        
        // Use existing PerlinNoise for pattern
        const noiseValue = new PerlinNoise().noise(x * 0.1, z * 0.1, Date.now() * 0.001);
        const intensity = Math.abs(noiseValue);
        
        const trailGeom = new THREE.SphereGeometry(0.3 + intensity * 0.5, 6, 6);
        const hue = (intensity * 360 + 200) % 360; // Color based on noise
        const trailMat = new THREE.MeshBasicMaterial({
            color: new THREE.Color().setHSL(hue / 360, 0.8, 0.6),
            transparent: true,
            opacity: 0.7
        });
        
        const trail = new THREE.Mesh(trailGeom, trailMat);
        trail.position.set(x, 4 + Math.random(), z);
        
        this.trails.push({
            mesh: trail,
            life: 60 + Math.random() * 40,
            maxLife: 60 + Math.random() * 40
        });
        
        this.scene.add(trail);
    }
}

updateTrails() {
    this.trails = this.trails.filter(trail => {
        trail.life--;
        
        // Fade and shrink
        const fadeRatio = trail.life / trail.maxLife;
        trail.mesh.material.opacity = fadeRatio * 0.7;
        trail.mesh.scale.setScalar(fadeRatio);
        
        if (trail.life <= 0) {
            this.scene.remove(trail.mesh);
            return false;
        }
        return true;
    });
}
        updatePlayer() {
          let moveX = 0,
            moveZ = 0;
          if (this.keys.KeyW || this.keys.ArrowUp || this.touchControls.moveY < -0.3) moveZ -= 1;
          if (this.keys.KeyS || this.keys.ArrowDown || this.touchControls.moveY > 0.3) moveZ += 1;
          if (this.keys.KeyA || this.keys.ArrowLeft || this.touchControls.moveX < -0.3) moveX -= 1;
          if (this.keys.KeyD || this.keys.ArrowRight || this.touchControls.moveX > 0.3) moveX += 1;
          if (moveX !== 0 || moveZ !== 0) {
            if (moveX !== 0 && moveZ !== 0) {
              moveX *= Math.SQRT1_2;
              moveZ *= Math.SQRT1_2
            }
            const speedMultiplier = this.player.effects.speed.active ? CONFIG.audio.speed.mult : 1;
            this.playerVelocity.x += moveX * CONFIG.player.acc * speedMultiplier;
            this.playerVelocity.z += moveZ * CONFIG.player.acc * speedMultiplier
          }
          this.playerVelocity.multiplyScalar(CONFIG.player.friction);
          const maxSpeed = CONFIG.player.maxSpeed * (this.player.effects.speed.active ? CONFIG.audio.speed.mult : 1);
          const clampedVelocity = this.playerVelocity.clone().clampLength(0, maxSpeed);
          this.playerVelocity.copy(clampedVelocity);
          const newPosition = this.playerShip.position.clone().add(this.playerVelocity);
          if (!this.checkPlanetCollision(newPosition, !0)) {
            this.playerShip.position.copy(newPosition);
            this.playerShip.position.y = 5
          }

          if (this.playerVelocity.length() > 0.1) {
    this.createTrail();
}
          if (this.playerVelocity.length() > 0.1) {
            const angle = Math.atan2(this.playerVelocity.x, this.playerVelocity.z);
            this.playerShip.rotation.y = angle
          }
          if ((this.keys.Space && !this.shootPressed) || this.touchControls.firing) {
            this.fireWeapon();
            this.shootPressed = !0
          } else if (!this.keys.Space && !this.touchControls.firing) {
            this.shootPressed = !1;
            if (this.laserBeam) {
              this.scene.remove(this.laserBeam);
              this.laserBeam = null;
              this.audioManager.stopLaser()
            }
          }
          const targetCameraX = this.playerShip.position.x;
          const targetCameraZ = this.playerShip.position.z + 60;
          const cameraPosition = new THREE.Vector3(targetCameraX, 60, targetCameraZ);
          if (!this.checkCameraCollision(cameraPosition)) {
            this.camera.position.copy(cameraPosition)
          } else {
            this.adjustCameraForCollision()
          }
          this.camera.lookAt(this.playerShip.position);
          this.updateCoordinates()
        }
        updateEnemies() {
          this.enemies.forEach(enemy => {
            if (enemy.health <= 0 || enemy.stuck) return;
            const distanceToPlayer = enemy.mesh.position.distanceTo(this.playerShip.position);
            enemy.shootCooldown--;
            if (distanceToPlayer < enemy.attackRange && !enemy.attacking) {
              enemy.attacking = !0;
              enemy.retreating = !1
            }
            if (enemy.attacking) {
              const distanceToPlayer = enemy.mesh.position.distanceTo(this.playerShip.position);
              const avoidanceForce = this.calculateEnemyAvoidance(enemy);
              if (distanceToPlayer > CONFIG.enemy.minDistance * 1.5) {
                const directionToPlayer = new THREE.Vector3().subVectors(this.playerShip.position, enemy.mesh.position).normalize();
                const combinedDirection = directionToPlayer.add(avoidanceForce).normalize();
                const moveDistance = Math.min(enemy.chaseSpeed, distanceToPlayer - CONFIG.enemy.minDistance);
                const movement = combinedDirection.multiplyScalar(moveDistance);
                const newPosition = enemy.mesh.position.clone().add(movement);
                if (!this.checkPlanetCollision(newPosition)) {
                  enemy.mesh.position.copy(newPosition);
                  enemy.mesh.position.y = 5
                }
              } else {
                const tangentAngle = Math.atan2(this.playerShip.position.z - enemy.mesh.position.z, this.playerShip.position.x - enemy.mesh.position.x) + Math.PI / 2;
                const circleDirection = new THREE.Vector3(Math.cos(tangentAngle), 0, Math.sin(tangentAngle));
                const combinedDirection = circleDirection.add(avoidanceForce.multiplyScalar(2)).normalize();
                const movement = combinedDirection.multiplyScalar(enemy.chaseSpeed * 0.7);
                const newPosition = enemy.mesh.position.clone().add(movement);
                if (!this.checkPlanetCollision(newPosition)) {
                  enemy.mesh.position.copy(newPosition);
                  enemy.mesh.position.y = 5
                }
              }
              enemy.mesh.lookAt(this.playerShip.position);
              if (enemy.shootCooldown <= 0 && distanceToPlayer < 30 && distanceToPlayer > CONFIG.enemy.minDistance * 0.8) {
                this.enemyShoot(enemy);
                enemy.shootCooldown = this.getShootCooldown(enemy.weaponType)
              }
              if (distanceToPlayer > enemy.attackRange * 2.5) {
                enemy.attacking = !1;
                enemy.retreating = !0
              }
            } else if (enemy.retreating) {
              if (distanceToPlayer < enemy.attackRange * 1.2) {
                enemy.attacking = !0;
                enemy.retreating = !1;
                return
              }
              const targetPosition = new THREE.Vector3(enemy.planet.center.x + Math.cos(enemy.originalAngle) * enemy.planet.radius, 5, enemy.planet.center.z + Math.sin(enemy.originalAngle) * enemy.planet.radius);
              const distanceToTarget = enemy.mesh.position.distanceTo(targetPosition);
              if (distanceToTarget > 2) {
                const direction = new THREE.Vector3().subVectors(targetPosition, enemy.mesh.position).normalize().multiplyScalar(CONFIG.enemy.retSpeed);
                const newPos = enemy.mesh.position.clone().add(direction);
                newPos.y = 5;
                enemy.mesh.position.copy(newPos);
                const lookAhead = enemy.mesh.position.clone().add(direction);
                enemy.mesh.lookAt(lookAhead)
              } else {
                enemy.retreating = !1;
                enemy.angle = enemy.originalAngle
              }
            } else {
              enemy.angle += enemy.speed;
              this.updateEnemyPosition(enemy);
              const nextAngle = enemy.angle + enemy.speed;
              const nextX = enemy.planet.center.x + Math.cos(nextAngle) * enemy.planet.radius;
              const nextZ = enemy.planet.center.z + Math.sin(nextAngle) * enemy.planet.radius;
              const nextPosition = new THREE.Vector3(nextX, 5, nextZ);
              enemy.mesh.lookAt(nextPosition)
            }
          })
        }
        calculateEnemyAvoidance(currentEnemy) {
          const avoidanceForce = new THREE.Vector3();
          let neighborCount = 0;
          this.enemies.forEach(otherEnemy => {
            if (otherEnemy === currentEnemy || otherEnemy.health <= 0) return;
            const distance = currentEnemy.mesh.position.distanceTo(otherEnemy.mesh.position);
            const avoidanceRadius = 12;
            if (distance < avoidanceRadius && distance > 0) {
              const repelDirection = new THREE.Vector3().subVectors(currentEnemy.mesh.position, otherEnemy.mesh.position);
              const repelStrength = Math.max(0.3, (avoidanceRadius - distance) / avoidanceRadius * 2);
              repelDirection.normalize().multiplyScalar(repelStrength);
              avoidanceForce.add(repelDirection);
              neighborCount++
            }
          });
          const playerDistance = currentEnemy.mesh.position.distanceTo(this.playerShip.position);
          if (playerDistance < CONFIG.enemy.minDistance) {
            const repelFromPlayer = new THREE.Vector3().subVectors(currentEnemy.mesh.position, this.playerShip.position);
            const repelStrength = Math.max(0.5, (CONFIG.enemy.minDistance - playerDistance) / CONFIG.enemy.minDistance * 3);
            repelFromPlayer.normalize().multiplyScalar(repelStrength);
            avoidanceForce.add(repelFromPlayer)
          }
          if (neighborCount > 0) {
            avoidanceForce.divideScalar(Math.max(1, neighborCount * 0.5))
          }
          return avoidanceForce
        }
        enemyShoot(enemy) {
          const weaponTypes = {
            'rapid': () => {
              this.createEnemyBullet(enemy);
              this.audioManager.playEnemyShot()
            },
            'burst': () => {
              for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                  if (enemy.health > 0) {
                    this.createEnemyBullet(enemy);
                    this.audioManager.playEnemyShot()
                  }
                }, i * 100)
              }
            },
            'heavy': () => {
              this.createEnemyBullet(enemy);
              this.audioManager.playEnemyShot()
            }
          };
          const shootFunction = weaponTypes[enemy.weaponType] || weaponTypes.rapid;
          shootFunction()
        }
        createEnemyBullet(enemy) {
          const bulletGeom = new THREE.SphereGeometry(0.3, 8, 8);
          const bulletMat = new THREE.MeshBasicMaterial({
            color: 0xff4757,
            emissive: 0xff2030,
            emissiveIntensity: 0.5
          });
          const bullet = new THREE.Mesh(bulletGeom, bulletMat);
          bullet.position.copy(enemy.mesh.position);
          bullet.position.y = 5;
          const direction = new THREE.Vector3().subVectors(this.playerShip.position, enemy.mesh.position).normalize();
          const bulletVelocity = direction.clone().multiplyScalar(CONFIG.bullet.enemySpeed);
          this.enemyBullets.push({
            mesh: bullet,
            velocity: bulletVelocity,
            life: CONFIG.bullet.life
          });
          this.scene.add(bullet)
        }
        getShootCooldown(weaponType) {
          const cooldowns = {
            'rapid': 60,
            'burst': 180,
            'heavy': 150
          };
          return cooldowns[weaponType] || 120
        }
        updateBullets() {
          this.bullets = this.bullets.filter(bullet => {
            bullet.mesh.position.add(bullet.velocity);
            bullet.life--;
            const damage = this.player.effects.damage.active ? CONFIG.bullet.damage * CONFIG.audio.damage.mult : CONFIG.bullet.damage;
            for (let enemy of this.enemies) {
              if (enemy.health > 0 && bullet.mesh.position.distanceTo(enemy.mesh.position) < 3) {
                enemy.health -= damage;
                enemy.attacking = !0;
                enemy.retreating = !1;
                this.audioManager.playEnemyHit();
                if (enemy.health <= 0) {
                  this.createExplosion(enemy.mesh.position);
                  this.audioManager.playExplosion();
                  enemy.mesh.visible = !1;
                  this.player.score += enemy.score;
                  this.dropArtifact(enemy.mesh.position);
                  this.updateHUD()
                }
                this.scene.remove(bullet.mesh);
                return !1
              }
            }
            for (let planet of this.planets) {
              if (!planet.destroyed && bullet.mesh.position.distanceTo(planet.center) < planet.config.radius) {
                planet.health -= damage;
                if (planet.health <= 0) {
                  this.destroyPlanet(planet)
                }
                this.scene.remove(bullet.mesh);
                return !1
              }
            }
            if (bullet.life <= 0) {
              this.scene.remove(bullet.mesh);
              return !1
            }
            return !0
          })
        }
        updateEnemyBullets(){
    this.enemyBullets = this.enemyBullets.filter(bullet => {
        bullet.mesh.position.add(bullet.velocity);
        bullet.life--;
        
        // ADD THIS CHECK - no damage during landing/takeoff
        if (this.landingState === 'none') {
            const distance = bullet.mesh.position.distanceTo(this.playerShip.position);
            if (distance < 3) {
                this.player.health -= CONFIG.bullet.enemyDamage;
                this.audioManager.playDamage();
                this.createDamageEffect(this.playerShip.position);
                this.updateHUD();
                if (this.player.health <= 0) {
                    this.gameOver();
                }
                this.scene.remove(bullet.mesh);
                return false;
            }
        }
        
        if (bullet.life <= 0) {
            this.scene.remove(bullet.mesh);
            return false;
        }
        return true;
    });
}
        updateArtifacts() {
          this.artifacts = this.artifacts.filter(artifact => {
            artifact.life--;
            artifact.mesh.position.y = 1 + Math.sin(Date.now() * 0.005 + artifact.bobOffset) * 0.5;
            artifact.mesh.rotation.y += 0.08;
            artifact.mesh.rotation.x += 0.03;
            const playerPosition = this.playerShip.position.clone();
            playerPosition.y = artifact.mesh.position.y;
            const distance = artifact.mesh.position.distanceTo(playerPosition);
            if (distance < 6) {
              this.applyArtifactEffect(artifact.type);
              this.scene.remove(artifact.mesh);
              return !1
            }
            if (artifact.life <= 0) {
              this.scene.remove(artifact.mesh);
              return !1
            }
            return !0
          })
        }
        updateMines() {
          this.mines = this.mines.filter(mine => {
            mine.life--;
            if (mine.life <= 0 && !mine.exploded) {
              this.scene.remove(mine.mesh);
              return !1
            }
            if (!mine.exploded) {
              const nearbyEnemies = this.enemies.filter(enemy => enemy.health > 0 && mine.mesh.position.distanceTo(enemy.mesh.position) < 8);
              if (nearbyEnemies.length > 0) {
                mine.exploded = !0;
                this.explodeMine(mine);
                this.scene.remove(mine.mesh);
                return !1
              }
            }
            return !mine.exploded
          })
        }
        updateCollisions(){
    if (this.collisionCooldown > 0) {
        this.collisionCooldown--;
        return;
    }
    
    // ADD THIS CHECK - no collisions during landing/takeoff
    if (this.landingState !== 'none') return;
    
    this.enemies.forEach(enemy => {
        if (enemy.health > 0 && enemy.mesh.position.distanceTo(this.playerShip.position) < 4) {
            this.player.health -= 5;
            this.collisionCooldown = 60;
            this.audioManager.playCollision();
            this.updateHUD();
            if (this.player.health <= 0) {
                this.gameOver();
            }
        }
    });
}
        updateBackground() {
          if (this.backgroundManager) {
            this.backgroundManager.update(this.playerShip.position.x, this.playerShip.position.z)
          }
        }
        updateMinimap() {
          if (this.minimapManager) {
            this.minimapManager.update(this.playerShip.position, this.planets, this.enemies)
          }
        }
        updateCoordinates() {
          document.getElementById('posX').textContent = Math.round(this.playerShip.position.x);
          document.getElementById('posZ').textContent = Math.round(this.playerShip.position.z)
        }
        updateEffects() {
          const currentTime = Date.now();
          let effectsText = '';
          if (this.player.effects.speed.active) {
            if (currentTime > this.player.effects.speed.endTime) {
              this.player.effects.speed.active = !1
            } else {
              const remaining = Math.ceil((this.player.effects.speed.endTime - currentTime) / 1000);
              effectsText += `SPEED BOOST: ${remaining}s
                                                                                                                                                                                                            
                                                                                                                                                                                                            <br>`
            }
          }
          if (this.player.effects.damage.active) {
            if (currentTime > this.player.effects.damage.endTime) {
              this.player.effects.damage.active = !1
            } else {
              const remaining = Math.ceil((this.player.effects.damage.endTime - currentTime) / 1000);
              effectsText += `DAMAGE BOOST: ${remaining}s
                                                                                                                                                                                                                
                                                                                                                                                                                                                <br>`
            }
          }
          document.getElementById('effects').innerHTML = effectsText
        }
        updateExplosions() {
          this.explosions = this.explosions.filter(explosion => {
            explosion.scale += 0.1;
            explosion.mesh.scale.setScalar(explosion.scale);
            explosion.mesh.material.opacity = Math.max(0, 0.8 - explosion.scale * 0.4);
            if (explosion.scale >= 2) {
              this.scene.remove(explosion.mesh);
              return !1
            }
            return !0
          })
        }
        checkPlanetCollision(newPosition, isPlayer = !1) {
          for (let planet of this.planets) {
            if (planet.destroyed) continue;
            const distance = newPosition.distanceTo(planet.center);
            const collisionDistance = planet.config.radius + (isPlayer ? 3 : 2);
            if (distance < collisionDistance) {
              if (isPlayer) {
                const bounceDirection = new THREE.Vector3().subVectors(newPosition, planet.center).normalize();
                this.playerVelocity.copy(bounceDirection.multiplyScalar(0.5));
                this.player.health -= 10;
                this.createDamageEffect(this.playerShip.position);
                this.audioManager.playDamage();
                this.updateHUD();
                if (this.player.health <= 0) {
                  this.gameOver()
                }
              }
              return !0
            }
          }
          return !1
        }
        checkCameraCollision(cameraPosition) {
          for (let planet of this.planets) {
            if (planet.destroyed) continue;
            const distance = cameraPosition.distanceTo(planet.center);
            const collisionDistance = planet.config.radius + 15;
            if (distance < collisionDistance) {
              return !0
            }
          }
          return !1
        }
        adjustCameraForCollision() {
          let bestPosition = null;
          let maxDistance = 0;
          const baseDistance = 60;
          for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
            const offsetX = Math.sin(angle) * baseDistance;
            const offsetZ = Math.cos(angle) * baseDistance;
            const testPosition = new THREE.Vector3(this.playerShip.position.x + offsetX, 60, this.playerShip.position.z + offsetZ);
            if (!this.checkCameraCollision(testPosition)) {
              const distanceFromIdeal = testPosition.distanceTo(new THREE.Vector3(this.playerShip.position.x, 60, this.playerShip.position.z + baseDistance));
              if (!bestPosition || distanceFromIdeal < maxDistance) {
                bestPosition = testPosition;
                maxDistance = distanceFromIdeal
              }
            }
          }
          if (bestPosition) {
            this.camera.position.copy(bestPosition)
          } else {
            this.camera.position.set(this.playerShip.position.x, 80, this.playerShip.position.z)
          }
        }
        createArtifact(position, type) {
          const artifactGeom = new THREE.SphereGeometry(1.5, 12, 12);
          const artifactMat = new THREE.MeshBasicMaterial({
            color: CONFIG.audio[type].color,
            transparent: !0,
            opacity: 0.9
          });
          const artifact = new THREE.Mesh(artifactGeom, artifactMat);
          artifact.position.copy(position);
          artifact.position.y = 1;
          const artifactObj = {
            mesh: artifact,
            type: type,
            life: 900,
            bobOffset: Math.random() * Math.PI * 2
          };
          this.artifacts.push(artifactObj);
          this.scene.add(artifact);
          return artifactObj
        }
        dropArtifact(position) {
          const artifactTypes = ['speed', 'damage', 'health'];
          const randomType = artifactTypes[Math.floor(Math.random() * artifactTypes.length)];
          this.createArtifact(position, randomType)
        }
        applyArtifactEffect(type) {
          const artifactConfig = CONFIG.audio[type];
          const currentTime = Date.now();
          if (type === 'health') {
            this.player.health = Math.min(CONFIG.player.health, this.player.health + artifactConfig.amount)
          } else {
            this.player.effects[type].active = !0;
            this.player.effects[type].endTime = currentTime + artifactConfig.duration
          }
          this.audioManager.playPowerUp();
          this.updateHUD()
        }
        createExplosion(position, size = 5) {
          const explosionGeom = new THREE.SphereGeometry(size, 16, 16);
          const explosionMat = new THREE.MeshBasicMaterial({
            color: 0xff4757,
            transparent: !0,
            opacity: 0.8
          });
          const explosion = new THREE.Mesh(explosionGeom, explosionMat);
          explosion.position.copy(position);
          this.scene.add(explosion);
          this.explosions.push({
            mesh: explosion,
            scale: 0
          })
        }
        createDamageEffect(position) {
          const damageGeom = new THREE.SphereGeometry(3, 32, 32);
          const damageMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: !0,
            opacity: 0.6
          });
          const damage = new THREE.Mesh(damageGeom, damageMat);
          damage.position.copy(position);
          this.scene.add(damage);
          this.explosions.push({
            mesh: damage,
            scale: 0
          })
        }
        destroyPlanet(planet) {
          planet.destroyed = !0;
          this.createExplosion(planet.center, planet.config.radius);
          this.audioManager.playExplosion(2);
          this.scene.remove(planet.mesh);
          this.player.score += 500;
          this.updateHUD();
          this.enemies = this.enemies.filter(enemy => {
            if (enemy.planet === planet) {
              this.scene.remove(enemy.mesh);
              return !1
            }
            return !0
          })
        }
        explodeMine(mine) {
          const explosionGeom = new THREE.SphereGeometry(8, 16, 16);
          const explosionMat = new THREE.MeshBasicMaterial({
            color: 0xff4757,
            transparent: !0,
            opacity: 0.6
          });
          const explosion = new THREE.Mesh(explosionGeom, explosionMat);
          explosion.position.copy(mine.mesh.position);
          this.scene.add(explosion);
          this.explosions.push({
            mesh: explosion,
            scale: 0
          });
          this.audioManager.playExplosion(1.5);
          this.enemies.forEach(enemy => {
            if (enemy.health > 0 && explosion.position.distanceTo(enemy.mesh.position) < 8) {
              enemy.health -= 50;
              this.audioManager.playEnemyHit();
              if (enemy.health <= 0) {
                this.createExplosion(enemy.mesh.position);
                this.audioManager.playExplosion();
                enemy.mesh.visible = !1;
                enemy.stuck = !0;
                this.player.score += enemy.score;
                this.dropArtifact(enemy.mesh.position);
                this.updateHUD()
              }
            }
          })
        }
        updateHUD() {
          document.getElementById('health').textContent = this.player.health;
          document.getElementById('score').textContent = this.player.score
        }
        gameOver() {
          this.gameStarted = !1;
          setTimeout(() => {
            const playAgain = confirm(`Game Over! Final Score: ${this.player.score}\n\nWould you like to play again?`);
            if (playAgain) {
              this.resetGame()
            } else {
              location.reload()
            }
          }, 100)
        }
        resetGame() {
          this.audioManager.stopLaser();
          this.player.health = CONFIG.player.health;
          this.player.score = 0;
          this.player.currentWeapon = 1;
          this.player.effects.speed.active = !1;
          this.player.effects.damage.active = !1;
          this.switchWeapon(1);
          this.playerShip.position.set(0, 5, 0);
          this.playerVelocity.set(0, 0, 0);
          this.collisionCooldown = 0;
          this.enemies.forEach(enemy => {
            const enemyConfig = EnemyFactory.types[enemy.type];
            enemy.health = enemyConfig.health;
            enemy.attacking = !1;
            enemy.retreating = !1;
            enemy.shootCooldown = 0;
            enemy.stuck = !1;
            enemy.mesh.visible = !0;
            enemy.angle = enemy.originalAngle;
            this.updateEnemyPosition(enemy)
          });
          this.planets.forEach(planet => {
            if (planet.destroyed) {
              planet.destroyed = !1;
              planet.health = planet.maxHealth;
              this.scene.add(planet.mesh)
            } else {
              planet.health = planet.maxHealth
            }
          });
          this.trails.forEach(trail => this.scene.remove(trail.mesh));
this.trails = [];
          this.bullets.forEach(bullet => this.scene.remove(bullet.mesh));
          this.bullets = [];
          this.enemyBullets.forEach(bullet => this.scene.remove(bullet.mesh));
          this.enemyBullets = [];
          this.artifacts.forEach(artifact => this.scene.remove(artifact.mesh));
          this.artifacts = [];
          this.mines.forEach(mine => this.scene.remove(mine.mesh));
          this.mines = [];
          this.explosions.forEach(explosion => this.scene.remove(explosion.mesh));
          this.explosions = [];
          if (this.laserBeam) {
            this.scene.remove(this.laserBeam);
            this.laserBeam = null
          }
          this.updateHUD();
          this.gameStarted = !0
        }
        setupEventListeners() {
          document.addEventListener('keydown', (e) => {
            this.keys[e.code] = !0;
              if (e.code === 'KeyE') {
            this.startLanding();
        }
        
            if (e.code.startsWith('Digit')) {
              const weaponNumber = parseInt(e.code.charAt(5));
              this.switchWeapon(weaponNumber)
            }
          });
          document.addEventListener('keyup', (e) => {
            this.keys[e.code] = !1
          });
          document.getElementById('startBtn').addEventListener('click', () => {
            this.startGame()
          });

          this.setupMobileControls();
          window.addEventListener('resize', () => {
            const aspectRatio = window.innerWidth / window.innerHeight;
            const distance = 60;
            this.camera.left = -distance * aspectRatio;
            this.camera.right = distance * aspectRatio;
            this.camera.top = distance;
            this.camera.bottom = -distance;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight)
          })
        }
        setupMobileControls() {
          const dpad = document.getElementById('dpad');
          const dpadInner = document.getElementById('dpadInner');
          const fireBtn = document.getElementById('fireBtn');
          const weaponBtn = document.getElementById('weaponBtn');
          let dpadPressed = !1;
          const updateDpad = (clientX, clientY) => {
            const rect = dpad.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const deltaX = clientX - centerX;
            const deltaY = clientY - centerY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = 40;
            if (distance <= maxDistance) {
              dpadInner.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
              this.touchControls.moveX = deltaX / maxDistance;
              this.touchControls.moveY = deltaY / maxDistance
            } else {
              const angle = Math.atan2(deltaY, deltaX);
              const limitedX = Math.cos(angle) * maxDistance;
              const limitedY = Math.sin(angle) * maxDistance;
              dpadInner.style.transform = `translate(${limitedX}px, ${limitedY}px)`;
              this.touchControls.moveX = limitedX / maxDistance;
              this.touchControls.moveY = limitedY / maxDistance
            }
          };
          const resetDpad = () => {
            dpadInner.style.transform = 'translate(0px, 0px)';
            this.touchControls.moveX = 0;
            this.touchControls.moveY = 0;
            dpadPressed = !1
          };
          dpad.addEventListener('touchstart', (e) => {
            e.preventDefault();
            dpadPressed = !0;
            const touch = e.touches[0];
            updateDpad(touch.clientX, touch.clientY)
          });
          dpad.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (dpadPressed) {
              const touch = e.touches[0];
              updateDpad(touch.clientX, touch.clientY)
            }
          });
          dpad.addEventListener('touchend', (e) => {
            e.preventDefault();
            resetDpad()
          });
          fireBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.touchControls.firing = !0
          });
          fireBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.touchControls.firing = !1
          });
          weaponBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.cycleWeapon()
          })
        }
        async startGame() {
          document.getElementById('intro').classList.add('hidden');
          await this.audioManager.start();
          this.gameStarted = !0
        }
        animate() {
          requestAnimationFrame(() => this.animate());
          this.update();
          this.renderer.render(this.scene, this.camera)
        }
      }
      const game = new SpaceShooter();
    </script>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #000;
        font-family: 'Courier New', monospace;
        overflow: hidden
      }

      #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh
      }

      canvas {
        display: block
      }

      #intro {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #0a0a2e, #16213e, #0f3460);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: #fff;
        z-index: 1000;
        transition: opacity 0.5s
      }

      #intro h1 {
        font-size: 4rem;
        margin: 0;
        text-shadow: 0 0 20px #4facfe;
        background: linear-gradient(45deg, #4facfe, #00f2fe);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: glow 2s infinite alternate
      }

      #intro p {
        font-size: 1.2rem;
        margin: 20px 0;
        text-align: center;
        max-width: 600px;
        line-height: 1.6
      }

      #startBtn {
        padding: 15px 30px;
        font-size: 1.5rem;
        background: linear-gradient(45deg, #667eea, #764ba2);
        border: none;
        color: white;
        cursor: pointer;
        border-radius: 50px;
        transition: all 0.3s;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3)
      }

      #startBtn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4)
      }

      @keyframes glow {
        0% {
          text-shadow: 0 0 20px #4facfe
        }

        100% {
          text-shadow: 0 0 30px #4facfe, 0 0 40px #00f2fe
        }
      }

      #hud {
        position: absolute;
        top: 20px;
        left: 20px;
        color: #4facfe;
        font-size: 1rem;
        z-index: 100;
        text-shadow: 0 0 10px rgba(79, 172, 254, 0.8);
        display: flex;
        flex-direction: column;
        gap: 8px
      }

      #healthHud {
        color: #00ff88;
        font-weight: bold
      }

      #scoreHud {
        color: #feca57;
        font-weight: bold
      }

      #weaponHud {
        color: #ff6b6b;
        font-weight: bold
      }

      #coordinates {
        color: rgba(79, 172, 254, 0.7);
        font-size: 0.9rem
      }

      #minimap {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 120px;
        height: 120px;
        border: 2px solid rgba(79, 172, 254, 0.4);
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(5px);
        z-index: 100;
        transition: all 0.3s ease;
        cursor: pointer
      }

      #minimap.expanded {
        width: 300px;
        height: 300px;
        right: 50%;
        top: 50%;
        transform: translate(50%, -50%);
        z-index: 1001
      }

      #minimapCanvas {
        width: 100%;
        height: 100%;
        border-radius: 6px
      }

      #minimapToggle {
        position: absolute;
        top: -8px;
        right: -8px;
        width: 20px;
        height: 20px;
        background: rgba(79, 172, 254, 0.8);
        color: #fff;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        cursor: pointer;
        border: 1px solid rgba(79, 172, 254, 0.6)
      }

      #minimapToggle:hover {
        background: rgba(79, 172, 254, 1)
      }

      .hidden {
        opacity: 0;
        pointer-events: none
      }

      #controls {
        position: absolute;
        bottom: 20px;
        right: 20px;
        color: rgba(255, 255, 255, 0.7);
        font-size: 0.9rem;
        text-align: right;
        z-index: 100
      }

      #effects {
        position: absolute;
        top: 120px;
        left: 20px;
        color: #feca57;
        font-size: 1rem;
        z-index: 100;
        text-shadow: 0 0 10px rgba(254, 202, 87, 0.8)
      }

      #mobileControls {
        position: absolute;
        bottom: 80px;
        left: 20px;
        right: 20px;
        display: none;
        z-index: 200
      }

      #dpad {
        position: absolute;
        bottom: 80px;
        left: 20px;
        width: 120px;
        height: 120px
      }

      #dpadOuter {
        width: 120px;
        height: 120px;
        border: 3px solid rgba(79, 172, 254, 0.6);
        border-radius: 50%;
        position: absolute;
        background: rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(5px)
      }

      #dpadInner {
        width: 40px;
        height: 40px;
        background: rgba(79, 172, 254, 0.8);
        border-radius: 50%;
        position: absolute;
        top: 40px;
        left: 40px;
        transition: all 0.1s ease;
        box-shadow: 0 0 15px rgba(79, 172, 254, 0.6)
      }

      #fireBtn {
        position: absolute;
        bottom: 100px;
        right: 20px;
        width: 80px;
        height: 80px;
        border: 3px solid rgba(255, 75, 87, 0.6);
        border-radius: 50%;
        background: rgba(255, 75, 87, 0.3);
        color: #fff;
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
        backdrop-filter: blur(5px);
        box-shadow: 0 0 20px rgba(255, 75, 87, 0.4);
        font-weight: bold
      }

      #weaponBtn {
        position: absolute;
        bottom: 200px;
        right: 20px;
        width: 60px;
        height: 60px;
        border: 3px solid rgba(254, 202, 87, 0.6);
        border-radius: 50%;
        background: rgba(254, 202, 87, 0.3);
        color: #fff;
        font-size: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
        backdrop-filter: blur(5px);
        box-shadow: 0 0 20px rgba(254, 202, 87, 0.4);
        font-weight: bold
      }

      #fireBtn:active,
      #weaponBtn:active {
        transform: scale(0.95)
      }

      @media(max-width:768px) {
        #mobileControls {
          display: block
        }

        #controls {
          display: none
        }

        #intro h1 {
          font-size: 2.5rem
        }

        #intro p {
          font-size: 1rem;
          padding: 0 20px
        }

        #hud {
          font-size: 0.9rem
        }

        #minimap {
          width: 100px;
          height: 100px
        }

        #minimap.expanded {
          width: 250px;
          height: 250px
        }
      }

      #hud div {
        margin: 2px 0;
        padding: 2px 0
      }

      #effects div {
        animation: pulse 2s infinite
      }

      @keyframes pulse {

        0%,
        100% {
          opacity: 1
        }

        50% {
          opacity: 0.7
        }
      }

      #dpadOuter:active {
        background: rgba(79, 172, 254, 0.2)
      }

      #fireBtn:active {
        background: rgba(255, 75, 87, 0.5);
        box-shadow: 0 0 30px rgba(255, 75, 87, 0.6)
      }

      #weaponBtn:active {
        background: rgba(254, 202, 87, 0.5);
        box-shadow: 0 0 30px rgba(254, 202, 87, 0.6)
      }

      .fade-in {
        animation: fadeIn 1s ease-in
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px)
        }

        to {
          opacity: 1;
          transform: translateY(0)
        }
      }

      @media(max-width:480px) {
        #intro h1 {
          font-size: 2rem
        }

        #dpad {
          width: 100px;
          height: 100px
        }

        #dpadOuter {
          width: 100px;
          height: 100px
        }

        #dpadInner {
          width: 35px;
          height: 35px;
          top: 32.5px;
          left: 32.5px
        }

        #fireBtn {
          width: 70px;
          height: 70px;
          font-size: 12px
        }

        #weaponBtn {
          width: 50px;
          height: 50px;
          font-size: 10px
        }

        #minimap {
          width: 80px;
          height: 80px
        }

        #minimap.expanded {
          width: 200px;
          height: 200px
        }
      }

      * {
        box-sizing: border-box
      }

      canvas {
        image-rendering: optimizeSpeed;
        image-rendering: -moz-crisp-edges;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: optimize-contrast
      }
#landingPrompts {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 150;
}

@keyframes pulse {
    0%, 100% { opacity: 1; transform: translateX(-50%) scale(1); }
    50% { opacity: 0.7; transform: translateX(-50%) scale(1.1); }
}

#dialogueSystem {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    backdrop-filter: blur(5px);
}

#dialogueBox {
    background: linear-gradient(135deg, #0a0a2e, #16213e);
    border: 2px solid #4facfe;
    border-radius: 15px;
    padding: 30px;
    max-width: 500px;
    text-align: center;
    box-shadow: 0 0 30px rgba(79, 172, 254, 0.5);
}

#dialogueContent h3 {
    color: #4facfe;
    margin-top: 0;
    font-size: 1.5rem;
    text-shadow: 0 0 10px rgba(79, 172, 254, 0.8);
}

#dialogueContent p {
    color: #ffffff;
    margin: 20px 0;
    line-height: 1.6;
}

.dialogue-btn {
    background: linear-gradient(45deg, #667eea, #764ba2);
    border: none;
    color: white;
    padding: 12px 24px;
    font-size: 1rem;
    border-radius: 25px;
    cursor: pointer;
    transition: all 0.3s;
    margin: 10px;
}

.dialogue-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

#landBtn {
    position: absolute;
    bottom: 20px;
    right: 100px;
    width: 60px;
    height: 60px;
    border: 3px solid rgba(0, 255, 136, 0.6);
    border-radius: 50%;
    background: rgba(0, 255, 136, 0.3);
    color: #fff;
    font-size: 12px;
    display: none;
    align-items: center;
    justify-content: center;
    user-select: none;
    backdrop-filter: blur(5px);
    box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
    font-weight: bold;
}
@keyframes landingPulse {
    0%, 100% { 
        opacity: 1; 
        transform: translateX(-50%) scale(1);
        box-shadow: 0 0 10px rgba(0, 255, 136, 0.6);
    }
    50% { 
        opacity: 0.8; 
        transform: translateX(-50%) scale(1.05);
        box-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
    }
}

#landingPrompts div {
    white-space: nowrap;
}
@media(max-width:768px) {
    #mobileControls #landBtn {
        display: flex;
    }
}

    </style>
  </body>
</html>