<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Isometric Game - Steps 2-3: Terrain & Controls</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #2c3e50; overflow: hidden; }
        #gameCanvas { display: block; width: 100vw; height: 100vh; touch-action: none; cursor: grab; }
        #gameCanvas:active { cursor: grabbing; }
        .panel { position: absolute; color: white; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; font-size: 12px; z-index: 100; }
        #debugInfo { top: 10px; left: 10px; }
        #controls { bottom: 10px; left: 10px; font-size: 11px; }
        #editPanel { top: 10px; right: 10px; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px; min-width: 180px; }
        #editPanel button { background: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 2px; }
        #editPanel button:hover { background: #45a049; }
        #editPanel button.active { background: #ff6b6b; }
        #editPanel button:disabled { background: #666; cursor: not-allowed; }
        .edit-mode-indicator { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #ff6b6b; font-size: 16px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); z-index: 99; pointer-events: none; }
        .hidden { display: none; }
        @media (max-width: 768px) { .panel { font-size: 10px; padding: 8px; } }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="debugInfo" class="panel">
        <div>FPS: <span id="fps">60</span></div>
        <div>Camera: <span id="cameraPos">0, 0, 0</span></div>
        <div>Zoom: <span id="zoomLevel">1.0</span></div>
        <div>Status: <span id="status">Initializing...</span></div>
    </div>
    <div id="controls" class="panel">
        <div><strong>Desktop:</strong> WASD/Arrow Keys = Move | Mouse Wheel = Zoom | Click+Drag = Pan</div>
        <div><strong>Mobile:</strong> Touch+Drag = Pan | Pinch = Zoom | Tap = Select</div>
        <div><strong>Edit Mode:</strong> Click/Tap tiles to modify height | Shift+Click = Lower | Ctrl+Click = Set to 0</div>
    </div>
    <div id="editPanel" class="panel">
        <div><strong>Tile Editor</strong></div>
        <button id="toggleEdit">Enable Edit Mode</button>
        <div style="margin: 10px 0;">
            <div>Selected Tile: <span id="selectedTile">None</span></div>
            <div>Height: <span id="selectedHeight">-</span></div>
        </div>
        <div>
            <button id="raiseBtn" disabled>Raise (+1)</button>
            <button id="lowerBtn" disabled>Lower (-1)</button>
        </div>
        <div>
            <button id="setWaterBtn" disabled>Water (0)</button>
            <button id="setLandBtn" disabled>Land (3)</button>
            <button id="setMountainBtn" disabled>Mountain (6)</button>
        </div>
        <div style="margin-top: 10px;">
            <button id="undoBtn" disabled>Undo</button>
            <button id="clearBtn">Clear All</button>
        </div>
    </div>
    <div id="editModeIndicator" class="edit-mode-indicator hidden">EDIT MODE ACTIVE</div>

    <script>
        class GameEngine {
            constructor() {
                this.scene = null; this.camera = null; this.renderer = null; this.canvas = null; this.terrain = null;
                this.gridSize = 16; this.tileSize = 2; this.heightLevels = 8;
                this.cameraTarget = new THREE.Vector3(0, 0, 0); this.cameraOffset = new THREE.Vector3(10, 10, 10); this.zoomLevel = 1.0; this.minZoom = 0.3; this.maxZoom = 3.0;
                this.editMode = false; this.selectedTile = null; this.raycaster = new THREE.Raycaster(); this.mouse = new THREE.Vector2(); this.editHistory = []; this.maxHistorySize = 20;
                this.input = { keys: {}, mouse: { x: 0, y: 0, pressed: false }, touch: { active: false, start: null, current: null, pinchDistance: 0 } };
                this.frameCount = 0; this.lastFpsUpdate = 0; this.currentFps = 60; this.isRunning = false; this.cloudSprites = [];
                this.init();
            }

            init() {
                this.setupRenderer(); this.setupCamera(); this.setupScene(); this.setupLighting(); this.setupClouds(); this.setupTerrain(); this.setupInput(); this.setupEditMode(); this.start(); this.updateDebugInfo();
            }

            setupRenderer() {
                this.canvas = document.getElementById('gameCanvas');
                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true, alpha: false, powerPreference: "high-performance" });
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x4FB3D9, 1); this.renderer.shadowMap.enabled = true; this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            }

            setupCamera() {
                const aspect = window.innerWidth / window.innerHeight, frustumSize = 20;
                this.camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
                this.updateCameraPosition();
            }

            setupScene() { this.scene = new THREE.Scene(); this.scene.fog = new THREE.Fog(0x4FB3D9, 30, 100); }

            setupLighting() {
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.4));
                const light = new THREE.DirectionalLight(0xfff6e0, 0.95);
                light.position.set(50, 50, 25); light.castShadow = true;
                light.shadow.mapSize.width = light.shadow.mapSize.height = 2048;
                Object.assign(light.shadow.camera, { near: 0.1, far: 200, left: -50, right: 50, top: 50, bottom: -50 });
                this.scene.add(light);
            }

            setupClouds() {
                const loader = new THREE.TextureLoader();
                loader.load('https://i.imgur.com/mYRt74O.png', texture => {
                    for (let i = 0; i < 6; i++) {
                        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, color: 0xffffff, opacity: 0.7, transparent: true, depthWrite: false }));
                        sprite.position.set((Math.random() - 0.5) * this.gridSize * this.tileSize, 8 + Math.random() * 2, (Math.random() - 0.5) * this.gridSize * this.tileSize);
                        sprite.scale.set(8 + Math.random() * 6, 4 + Math.random() * 2, 1);
                        this.scene.add(sprite); this.cloudSprites.push(sprite);
                    }
                });
            }

            setupTerrain() { this.terrain = new TerrainSystem(this.gridSize, this.tileSize, this.heightLevels); this.terrain.generateTerrain(); this.scene.add(this.terrain.terrainGroup); }

            setupInput() {
                ['keydown', 'keyup'].forEach(evt => document.addEventListener(evt, e => this.input.keys[e.code] = evt === 'keydown'));
                ['mousedown', 'mousemove', 'mouseup'].forEach(evt => this.canvas.addEventListener(evt, e => this.handleMouse(evt, e)));
                this.canvas.addEventListener('click', e => this.editMode && this.handleTileClick(e));
                this.canvas.addEventListener('wheel', e => { e.preventDefault(); this.zoomCamera(e.deltaY > 0 ? 0.1 : -0.1); });
                ['touchstart', 'touchmove', 'touchend'].forEach(evt => this.canvas.addEventListener(evt, e => { e.preventDefault(); this[`handleTouch${evt.slice(5)}`](e); }));
                window.addEventListener('resize', () => this.handleResize());
            }

            handleMouse(evt, e) {
                const m = this.input.mouse;
                if (evt === 'mousedown') { m.pressed = true; m.x = e.clientX; m.y = e.clientY; }
                else if (evt === 'mousemove' && m.pressed && !this.editMode) this.panCamera(e.clientX - m.x, e.clientY - m.y);
                else if (evt === 'mouseup') m.pressed = false;
                if (evt !== 'mouseup') { m.x = e.clientX; m.y = e.clientY; }
            }

            setupEditMode() {
                const btns = { toggleEdit: () => this.toggleEditMode(), raiseBtn: () => this.modifySelected(1), lowerBtn: () => this.modifySelected(-1), setWaterBtn: () => this.setSelected(0), setLandBtn: () => this.setSelected(3), setMountainBtn: () => this.setSelected(6), undoBtn: () => this.undoLastEdit(), clearBtn: () => confirm('Clear all terrain? This cannot be undone.') && this.clearTerrain() };
                Object.keys(btns).forEach(id => document.getElementById(id).addEventListener('click', btns[id]));
            }

            toggleEditMode() {
                this.editMode = !this.editMode;
                const btn = document.getElementById('toggleEdit'), ind = document.getElementById('editModeIndicator');
                btn.textContent = this.editMode ? 'Disable Edit Mode' : 'Enable Edit Mode';
                btn.classList.toggle('active', this.editMode); ind.classList.toggle('hidden', !this.editMode);
                this.canvas.style.cursor = this.editMode ? 'crosshair' : 'grab';
                !this.editMode && this.clearSelection();
            }

            handleTileClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                this.mouse.set(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.terrain.terrainGroup.children);
                if (intersects.length) {
                    const tile = intersects[0].object.userData;
                    this.selectTile(tile.x, tile.z);
                    if (e.shiftKey) this.modifyTileHeight(tile.x, tile.z, -1);
                    else if (e.ctrlKey || e.metaKey) this.setTileHeight(tile.x, tile.z, 0);
                    else this.modifyTileHeight(tile.x, tile.z, 1);
                }
            }

            selectTile(x, z) {
                const tile = this.terrain.getTile(x, z);
                if (tile) { this.selectedTile = { x, z, height: tile.height }; this.updateEditUI(); this.highlightTile(tile.mesh); }
            }

            clearSelection() { this.selectedTile = null; this.updateEditUI(); this.removeHighlight(); }

            highlightTile(mesh) {
                this.removeHighlight();
                const edges = new THREE.EdgesGeometry(mesh.geometry);
                this.tileHighlight = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 3 }));
                this.tileHighlight.position.copy(mesh.position); this.tileHighlight.position.y += 0.01; this.scene.add(this.tileHighlight);
            }

            removeHighlight() {
                if (this.tileHighlight) { this.scene.remove(this.tileHighlight); this.tileHighlight.geometry.dispose(); this.tileHighlight.material.dispose(); this.tileHighlight = null; }
            }

            modifySelected(delta) { this.selectedTile && this.modifyTileHeight(this.selectedTile.x, this.selectedTile.z, delta); }
            setSelected(height) { this.selectedTile && this.setTileHeight(this.selectedTile.x, this.selectedTile.z, height); }

            modifyTileHeight(x, z, delta) {
                const tile = this.terrain.getTile(x, z);
                if (tile) {
                    const newHeight = Math.max(0, Math.min(this.heightLevels - 1, tile.height + delta));
                    if (newHeight !== tile.height) {
                        this.addToHistory(x, z, tile.height, newHeight); this.terrain.updateTileHeight(x, z, newHeight);
                        if (this.selectedTile?.x === x && this.selectedTile?.z === z) { this.selectedTile.height = newHeight; this.updateEditUI(); this.highlightTile(tile.mesh); }
                    }
                }
            }

            setTileHeight(x, z, height) {
                const tile = this.terrain.getTile(x, z);
                if (tile && tile.height !== height) {
                    this.addToHistory(x, z, tile.height, height); this.terrain.updateTileHeight(x, z, height);
                    if (this.selectedTile?.x === x && this.selectedTile?.z === z) { this.selectedTile.height = height; this.updateEditUI(); this.highlightTile(tile.mesh); }
                }
            }

            addToHistory(x, z, oldHeight, newHeight) {
                this.editHistory.push({ x, z, oldHeight, newHeight });
                if (this.editHistory.length > this.maxHistorySize) this.editHistory.shift();
                document.getElementById('undoBtn').disabled = false;
            }

            undoLastEdit() {
                if (this.editHistory.length) {
                    const action = this.editHistory.pop();
                    this.terrain.updateTileHeight(action.x, action.z, action.oldHeight);
                    if (this.selectedTile?.x === action.x && this.selectedTile?.z === action.z) { this.selectedTile.height = action.oldHeight; this.updateEditUI(); this.highlightTile(this.terrain.getTile(action.x, action.z).mesh); }
                    document.getElementById('undoBtn').disabled = !this.editHistory.length;
                }
            }

            clearTerrain() {
                this.editHistory = [];
                for (let x = 0; x < this.gridSize; x++) for (let z = 0; z < this.gridSize; z++) this.terrain.updateTileHeight(x, z, 2);
                this.clearSelection(); document.getElementById('undoBtn').disabled = true;
            }

            updateEditUI() {
                const elems = ['selectedTile', 'selectedHeight', 'raiseBtn', 'lowerBtn', 'setWaterBtn', 'setLandBtn', 'setMountainBtn'].map(id => document.getElementById(id));
                if (this.selectedTile) {
                    elems[0].textContent = `${this.selectedTile.x}, ${this.selectedTile.z}`; elems[1].textContent = this.selectedTile.height;
                    const atMax = this.selectedTile.height >= this.heightLevels - 1, atMin = this.selectedTile.height <= 0;
                    elems[2].disabled = !this.editMode || atMax; elems[3].disabled = !this.editMode || atMin;
                    [4, 5, 6].forEach(i => elems[i].disabled = !this.editMode);
                } else {
                    elems[0].textContent = 'None'; elems[1].textContent = '-';
                    elems.slice(2).forEach(btn => btn.disabled = true);
                }
            }

            handleTouchStart(e) {
                const touches = e.touches;
                if (touches.length === 1) {
                    this.input.touch.active = true; this.input.touch.moved = false;
                    this.input.touch.start = this.input.touch.current = { x: touches[0].clientX, y: touches[0].clientY };
                } else if (touches.length === 2) {
                    this.input.touch.pinchDistance = this.getTouchDistance(touches[0], touches[1]); this.input.touch.moved = false;
                }
            }

            handleTouchMove(e) {
                const touches = e.touches;
                if (touches.length === 1 && this.input.touch.active) {
                    const delta = { x: touches[0].clientX - this.input.touch.current.x, y: touches[0].clientY - this.input.touch.current.y };
                    const dist = Math.sqrt(delta.x * delta.x + delta.y * delta.y);
                    if (dist > 5) { this.input.touch.moved = true; !this.editMode && this.panCamera(delta.x, delta.y); }
                    this.input.touch.current = { x: touches[0].clientX, y: touches[0].clientY };
                } else if (touches.length === 2) {
                    const currentDist = this.getTouchDistance(touches[0], touches[1]);
                    this.zoomCamera((this.input.touch.pinchDistance - currentDist) * 0.01);
                    this.input.touch.pinchDistance = currentDist; this.input.touch.moved = true;
                }
            }

            handleTouchEnd(e) {
                const wasTap = this.input.touch.active && !this.input.touch.moved && e.changedTouches.length === 1;
                if (wasTap && this.editMode) {
                    const touch = e.changedTouches[0];
                    this.handleTileClick({ clientX: touch.clientX, clientY: touch.clientY, shiftKey: false, ctrlKey: false, metaKey: false });
                }
                Object.assign(this.input.touch, { active: false, start: null, current: null, moved: false });
            }

            getTouchDistance(t1, t2) { const dx = t1.clientX - t2.clientX, dy = t1.clientY - t2.clientY; return Math.sqrt(dx * dx + dy * dy); }

            panCamera(deltaX, deltaY) {
                const speed = 0.02 * this.zoomLevel;
                const right = new THREE.Vector3(1, 0, 1).normalize(), up = new THREE.Vector3(-1, 0, 1).normalize();
                this.cameraTarget.add(right.multiplyScalar(deltaX * speed)).add(up.multiplyScalar(deltaY * speed));
                const maxBounds = this.gridSize * this.tileSize / 2;
                this.cameraTarget.x = Math.max(-maxBounds, Math.min(maxBounds, this.cameraTarget.x));
                this.cameraTarget.z = Math.max(-maxBounds, Math.min(maxBounds, this.cameraTarget.z));
            }

            zoomCamera(delta) {
                this.zoomLevel = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoomLevel + delta));
                const aspect = window.innerWidth / window.innerHeight, frustumSize = 20 * this.zoomLevel;
                Object.assign(this.camera, { left: frustumSize * aspect / -2, right: frustumSize * aspect / 2, top: frustumSize / 2, bottom: frustumSize / -2 });
                this.camera.updateProjectionMatrix();
            }

            updateCameraPosition() { this.camera.position.copy(this.cameraTarget.clone().add(this.cameraOffset)); this.camera.lookAt(this.cameraTarget); }

            handleKeyboardInput() {
                const speed = 0.3, keys = this.input.keys;
                if (keys['KeyW'] || keys['ArrowUp']) this.cameraTarget.z -= speed;
                if (keys['KeyS'] || keys['ArrowDown']) this.cameraTarget.z += speed;
                if (keys['KeyA'] || keys['ArrowLeft']) this.cameraTarget.x -= speed;
                if (keys['KeyD'] || keys['ArrowRight']) this.cameraTarget.x += speed;
                if (keys['KeyQ']) this.zoomCamera(0.02); if (keys['KeyE']) this.zoomCamera(-0.02);
                const maxBounds = this.gridSize * this.tileSize / 2;
                this.cameraTarget.x = Math.max(-maxBounds, Math.min(maxBounds, this.cameraTarget.x));
                this.cameraTarget.z = Math.max(-maxBounds, Math.min(maxBounds, this.cameraTarget.z));
            }

            handleResize() {
                const aspect = window.innerWidth / window.innerHeight, frustumSize = 20 * this.zoomLevel;
                Object.assign(this.camera, { left: frustumSize * aspect / -2, right: frustumSize * aspect / 2, top: frustumSize / 2, bottom: frustumSize / -2 });
                this.camera.updateProjectionMatrix(); this.renderer.setSize(window.innerWidth, window.innerHeight); this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            }

            start() { this.isRunning = true; this.animate(); document.getElementById('status').textContent = 'Running'; }

            animate() { if (!this.isRunning) return; requestAnimationFrame(() => this.animate()); this.update(); this.render(); this.updatePerformanceStats(); }

            update() {
                this.handleKeyboardInput(); this.updateCameraPosition();
                this.cloudSprites.forEach(c => { c.position.x += 0.01 * (0.5 + Math.random() * 0.2); if (c.position.x > this.gridSize * this.tileSize) c.position.x = -this.gridSize * this.tileSize; });
                if (this.selectedTile && this.tileHighlight) {
                    const tile = this.terrain.getTile(this.selectedTile.x, this.selectedTile.z);
                    if (tile) { this.tileHighlight.position.copy(tile.mesh.position); this.tileHighlight.position.y += 0.01; }
                }
            }

            render() { this.renderer.render(this.scene, this.camera); }

            updatePerformanceStats() {
                this.frameCount++;
                const now = performance.now();
                if (now - this.lastFpsUpdate >= 1000) {
                    this.currentFps = Math.round((this.frameCount * 1000) / (now - this.lastFpsUpdate));
                    this.frameCount = 0; this.lastFpsUpdate = now; document.getElementById('fps').textContent = this.currentFps;
                }
            }

            updateDebugInfo() {
                const update = () => {
                    if (!this.isRunning) return;
                    const pos = this.cameraTarget;
                    document.getElementById('cameraPos').textContent = `${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}`;
                    document.getElementById('zoomLevel').textContent = this.zoomLevel.toFixed(1);
                    requestAnimationFrame(update);
                };
                update();
            }
        }

        class TerrainSystem {
            constructor(gridSize, tileSize, heightLevels) {
                this.gridSize = gridSize; this.tileSize = tileSize; this.heightLevels = heightLevels;
                this.terrainGroup = new THREE.Group(); this.tiles = [];
                this.levelColors = [0x277da1, 0x4fc3f7, 0x43aa8b, 0x90be6d, 0xf9c74f, 0xf9844a, 0xf3722c, 0x577590];
            }

            generateTerrain() {
                for (let x = 0; x < this.gridSize; x++) {
                    this.tiles[x] = [];
                    for (let z = 0; z < this.gridSize; z++) {
                        const height = this.generateHeightForPosition(x, z);
                        const tile = this.createTile(x, z, height);
                        tile.castShadow = tile.receiveShadow = true;
                        this.tiles[x][z] = { mesh: tile, height, x, z };
                        this.terrainGroup.add(tile);
                    }
                }
            }

            generateHeightForPosition(x, z) {
                const centerX = this.gridSize / 2, centerZ = this.gridSize / 2;
                const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(z - centerZ, 2));
                const normalizedDistance = distance / (this.gridSize / 2);
                let height = Math.floor((1 - normalizedDistance) * this.heightLevels) + Math.floor((Math.random() - 0.5) * 3);
                return Math.max(0, Math.min(this.heightLevels - 1, height));
            }

            createTile(x, z, height) {
                const geometry = new THREE.BoxGeometry(this.tileSize * 0.9, 0.5 + height * 0.5, this.tileSize * 0.9);
                const material = new THREE.MeshLambertMaterial({ color: this.levelColors[height] });
                const tile = new THREE.Mesh(geometry, material);
                const worldX = (x - this.gridSize / 2) * this.tileSize, worldZ = (z - this.gridSize / 2) * this.tileSize, worldY = (0.5 + height * 0.5) / 2;
                tile.position.set(worldX, worldY, worldZ); tile.castShadow = tile.receiveShadow = true; tile.userData = { x, z, height };
                return tile;
            }

            getTile(x, z) { return (x >= 0 && x < this.gridSize && z >= 0 && z < this.gridSize) ? this.tiles[x][z] : null; }

            updateTileHeight(x, z, newHeight) {
                const tile = this.getTile(x, z);
                if (tile) {
                    tile.height = Math.max(0, Math.min(this.heightLevels - 1, newHeight));
                    const mesh = tile.mesh;
                    const newGeometry = new THREE.BoxGeometry(this.tileSize * 0.9, 0.5 + tile.height * 0.5, this.tileSize * 0.9);
                    mesh.geometry.dispose(); mesh.geometry = newGeometry; mesh.material.color.setHex(this.levelColors[tile.height]);
                    mesh.position.y = (0.5 + tile.height * 0.5) / 2;
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const game = new GameEngine();
            window.game = game;
        });
    </script>
</body>
</html>
